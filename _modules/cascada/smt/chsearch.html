<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cascada.smt.chsearch &mdash; CASCADA 1.0.rc0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> CASCADA
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">CASCADA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primitives_implemented.html">Primitives implemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cascada.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CASCADA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>cascada.smt.chsearch</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cascada.smt.chsearch</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Search for characteristics by modeling the search as a sequence of SMT problems.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">decimal</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">pysmt</span> <span class="kn">import</span> <span class="n">environment</span>
<span class="kn">from</span> <span class="nn">pysmt</span> <span class="kn">import</span> <span class="n">logics</span>

<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">operation</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">ssa</span> <span class="k">as</span> <span class="n">cascada_ssa</span>
<span class="kn">from</span> <span class="nn">cascada</span> <span class="kn">import</span> <span class="n">abstractproperty</span>
<span class="kn">from</span> <span class="nn">cascada.primitives</span> <span class="kn">import</span> <span class="n">blockcipher</span>
<span class="kn">from</span> <span class="nn">cascada.smt</span> <span class="kn">import</span> <span class="n">pysmttypes</span>


<span class="k">def</span> <span class="nf">_get_time</span><span class="p">():</span>
    <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">now</span><span class="o">.</span><span class="n">day</span><span class="p">,</span> <span class="n">now</span><span class="o">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">now</span><span class="o">.</span><span class="n">minute</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">smart_print</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;prepend_time&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_get_time</span><span class="p">()</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;prepend_time&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">fh</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">smart_print</span>


<span class="nb">zip</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">zip</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">CurrentSignatureType</span> <span class="o">=</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">ChModelSigType</span><span class="o">.</span><span class="n">Unique</span>
<span class="n">INCREMENT_NUM_ROUNDS</span> <span class="o">=</span> <span class="s2">&quot;increment_num_rounds&quot;</span>
<span class="sd">&quot;&quot;&quot;Message to increase the current number of rounds by one (see `round_based_ch_search`)&quot;&quot;&quot;</span>


<div class="viewcode-block" id="ChModelAssertType"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.ChModelAssertType">[docs]</a><span class="k">class</span> <span class="nc">ChModelAssertType</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the options available for the type of constraints</span>
<span class="sd">    of the characteristic model.</span>

<span class="sd">    See also `abstractproperty.chmodel.ChModel`.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        ValidityAndWeight: consider `abstractproperty.chmodel.ChModel.validity_assertions`</span>
<span class="sd">            and `abstractproperty.chmodel.ChModel.weight_assertions`</span>
<span class="sd">        ProbabilityOne: only consider `abstractproperty.chmodel.ChModel.pr_one_assertions`</span>
<span class="sd">        Validity: only consider `abstractproperty.chmodel.ChModel.validity_assertions`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ValidityAndWeight</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">Validity</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">ProbabilityOne</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span></div>


<div class="viewcode-block" id="PrintingMode"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.PrintingMode">[docs]</a><span class="k">class</span> <span class="nc">PrintingMode</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the options available for the information to print.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        Silent: nothing is printed</span>
<span class="sd">        WeightsAndSrepr: prints every time the target weight is increased</span>
<span class="sd">            or the final weight is modified, and prints the</span>
<span class="sd">            `abstractproperty.characteristic.Characteristic.srepr` method</span>
<span class="sd">            of all non-returned characteristics (together with the current time)</span>
<span class="sd">        WeightsAndVrepr: similar as `WeightsAndSrepr`, but the</span>
<span class="sd">            `abstractproperty.characteristic.Characteristic.vrepr` method is</span>
<span class="sd">            printed instead.</span>
<span class="sd">        Debug: similar as `WeightsAndSrepr`, but also prints all</span>
<span class="sd">            the constraints generated during the search</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Silent</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">WeightsAndSrepr</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">WeightsAndVrepr</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">Debug</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span></div>


<div class="viewcode-block" id="MissingVarWarning"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.MissingVarWarning">[docs]</a><span class="k">class</span> <span class="nc">MissingVarWarning</span><span class="p">(</span><span class="ne">UserWarning</span><span class="p">):</span>  <span class="c1"># _check_initial_constraints</span>
    <span class="sd">&quot;&quot;&quot;The class of warnings when a variable from an additional constraint</span>
<span class="sd">    is missing in the SMT problem (see `ChFinder`).&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ChFinder"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.ChFinder">[docs]</a><span class="k">class</span> <span class="nc">ChFinder</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search for characteristics by modeling the search as a sequence of SMT problems.</span>

<span class="sd">    Given a characteristic model (`abstractproperty.chmodel.ChModel`</span>
<span class="sd">    o `abstractproperty.chmodel.EncryptionChModel`)</span>
<span class="sd">    defined for a particular `Property` (e.g., `XorDiff` or `LinearMask`),</span>
<span class="sd">    this class finds characteristics</span>
<span class="sd">    (`abstractproperty.characteristic.Characteristic`</span>
<span class="sd">    o `abstractproperty.characteristic.EncryptionCharacteristic`)</span>
<span class="sd">    satisfying the characteristic model by modelling the search as a sequence</span>
<span class="sd">    of SMT problems in the bit-vector theory.</span>

<span class="sd">    Depending on ``assert_type``, the SMT problems contains the validity,</span>
<span class="sd">    probability-one and/or weight assertions from the</span>
<span class="sd">    `abstractproperty.chmodel.ChModel`.</span>
<span class="sd">    They might also contain a constraint fixing the</span>
<span class="sd">    characteristic weight variable to a constant value</span>
<span class="sd">    (in the case of `find_next_ch_increasing_weight`) or</span>
<span class="sd">    additional constraints provided in ``initial_constraints``</span>
<span class="sd">    or derived from ``var2ct_prop`` or ``exclude_zero_input_prop``.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The optional initialization argument ``var2ct_prop`` is a</span>
<span class="sd">        `collections.OrderedDict` mapping symbolic properties</span>
<span class="sd">        of the characteristic model to constant values.</span>
<span class="sd">        From each ``(sp, cp)`` pair in  ``var2ct_prop``,</span>
<span class="sd">        where ``sp`` is a symbolic `Property` and ``cp`` a constant `Property`,</span>
<span class="sd">        the constraint ``sp == cp`` is added to ``initial_constraints``.</span>
<span class="sd">        The dictionary ``var2ct_prop`` can also be filled with</span>
<span class="sd">        pairs of symbolic `Term` and `Constant` objects;</span>
<span class="sd">        in this case, they are first automatically converted to</span>
<span class="sd">        `Property` objects.</span>

<span class="sd">        If ``exclude_zero_input_prop`` is ``True``, and additional</span>
<span class="sd">        constraint is added preventing the input property to be zero.</span>

<span class="sd">        By defaut, an exception is raised if an additional constraint</span>
<span class="sd">        (one of the constraint from ``initial_constraints`` or one of the</span>
<span class="sd">        constraints derived from ``var2ct_prop`` or ``exclude_zero_input_prop``)</span>
<span class="sd">        contains a variable that does not appear in the SMT problem</span>
<span class="sd">        (i.e., `chmodel_asserts`).</span>
<span class="sd">        If the initialization argument ``raise_exception_missing_var`` is False,</span>
<span class="sd">        a warning with category `MissingVarWarning` is printed</span>
<span class="sd">        instead of raising an exception.</span>

<span class="sd">    .. note::</span>

<span class="sd">        If ``ch_model`` is an algebraic characteristic model (defined for</span>
<span class="sd">        the property `BitValue` or `WordValue`), the assertion type</span>
<span class="sd">        `ValidityAndWeight` in  ``assert_type`` is not supported</span>
<span class="sd">        (and `Validity` and `ProbabilityOne` are</span>
<span class="sd">        equivalent due to the definition of characteristic probability,</span>
<span class="sd">        see also `algebraic.chmodel.ChModel`).</span>

<span class="sd">        If the algebraic characteristic model does not contain</span>
<span class="sd">        external variables and a ciphertext value is provided in</span>
<span class="sd">        ``var2ct_prop`` or ``initial_constraints``, then the</span>
<span class="sd">        search for algebraic characteristics is equivalent to the</span>
<span class="sd">        search for preimages of the given ciphertext value.</span>
<span class="sd">        On the other hand, if the algebraic characteristic model</span>
<span class="sd">        contains external variables (e.g., round keys) and a</span>
<span class="sd">        plaintext-ciphertext pair is provided in</span>
<span class="sd">        ``var2ct_prop`` or ``initial_constraints``, then the</span>
<span class="sd">        search for algebraic characteristics is equivalent to the</span>
<span class="sd">        search for the external values (e.g., round keys)</span>
<span class="sd">        that make the underlying bit-vector function maps</span>
<span class="sd">        the given plaintext to the given ciphertext.</span>

<span class="sd">    The SMT problems are solved through pySMT_, which calls an</span>
<span class="sd">    off-the-shelf SMT solver supported by pySMT given by ``solver_name``</span>
<span class="sd">    (e.g., ``solver_name=&#39;btor&#39;`` sets Boolector_ as the SMT solver).</span>
<span class="sd">    The pySMT documentation_ explains how to install an SMT solver.</span>

<span class="sd">    .. _pySMT: https://github.com/pysmt/pysmt</span>
<span class="sd">    .. _Boolector: https://boolector.github.io</span>
<span class="sd">    .. _documentation: https://github.com/pysmt/pysmt</span>

<span class="sd">    This class provides two methods to search for characteristics:</span>
<span class="sd">    `find_next_ch` and `find_next_ch_increasing_weight`.</span>
<span class="sd">    Both methods are Python `generator` functions, returning an `iterator` that</span>
<span class="sd">    yields the `abstractproperty.characteristic.Characteristic` objects</span>
<span class="sd">    found in the search (see also this_).</span>
<span class="sd">    The characteristics returned are defined for</span>
<span class="sd">    the `Property` of the characteristic model.</span>

<span class="sd">    .. _this: https://docs.python.org/3/howto/functional.html?highlight=generator#generators</span>

<span class="sd">    .. note::</span>

<span class="sd">        The characteristics can be obtained in a for-loop over the iterator</span>
<span class="sd">        or retrieved one at a time with the `next` function, that is,</span>

<span class="sd">        .. code:: python</span>

<span class="sd">            [...]</span>
<span class="sd">            ch_finder = ChFinder(...)</span>
<span class="sd">            iterator = ch_finder.search_all()</span>
<span class="sd">            first_ch_found = next(iterator)</span>
<span class="sd">            for next_ch_found in iterator:</span>
<span class="sd">                [...]</span>

<span class="sd">        If `next` is used but not characteristic is found,</span>
<span class="sd">        an `StopIteration` exception is raised.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; # example of SMT problem of XorDiff-EncryptionCharacteristic of Speck32</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.chmodel import EncryptionChModel</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.chsearch import ChFinder, ChModelAssertType</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">        &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">        &gt;&gt;&gt; ch_model = EncryptionChModel(Speck32, XorDiff)</span>
<span class="sd">        &gt;&gt;&gt; assert_type = ChModelAssertType.ValidityAndWeight</span>
<span class="sd">        &gt;&gt;&gt; ch_finder = ChFinder(ch_model, assert_type, &quot;btor&quot;, exclude_zero_input_prop=True, solver_seed=0)</span>
<span class="sd">        &gt;&gt;&gt; ch_finder.formula_size()</span>
<span class="sd">        801</span>
<span class="sd">        &gt;&gt;&gt; print(ch_finder.hrepr(full_repr=False))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        ; initial constraints</span>
<span class="sd">        assert ~((dp0 :: dp1) == 0x00000000)</span>
<span class="sd">        ; characteristic model assertions</span>
<span class="sd">        assert ((~(... &lt;&lt; ...) ^ (dp1 &lt;&lt; 0x0001)) &amp; (~(... &lt;&lt; ...) ^ (dx1 &lt;&lt; 0x0001)) &amp;</span>
<span class="sd">            ((... &gt;&gt;&gt; ...) ^ dp1 ^ dx1 ^ ((dp0 &gt;&gt;&gt; 7) &lt;&lt; 0x0001))) == 0x0000</span>
<span class="sd">        assert ((~(... &lt;&lt; ...) ^ ((... ^ ...) &lt;&lt; 0x0001)) &amp; (~(... &lt;&lt; ...) ^ (dx6 &lt;&lt; 0x0001)) &amp;</span>
<span class="sd">            ((... &gt;&gt;&gt; ...) ^ ... ^ ... ^ dx6 ^ ((dx1 &gt;&gt;&gt; 7) &lt;&lt; 0x0001))) == 0x0000</span>
<span class="sd">        assert dx6 == dx7_out</span>
<span class="sd">        assert ((((dp1 &lt;&lt;&lt; 2) ^ dx1) &lt;&lt;&lt; 2) ^ dx6) == dx9_out</span>
<span class="sd">        assert w0 == PopCount(~((~... ^ dp1) &amp; (~... ^ dx1))[14:])</span>
<span class="sd">        assert w1 == PopCount(~((~... ^ ... ^ ...) &amp; (~... ^ dx6))[14:])</span>
<span class="sd">        assert w2 == 0b0</span>
<span class="sd">        assert w3 == 0b0</span>
<span class="sd">        assert w == ((0b0 :: w0) + (0b0 :: w1))</span>


<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; # example of SMT problem of LinearMask-Characteristic of Speck32.key_schedule</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.chmodel import ChModel</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.chsearch import ChFinder, ChModelAssertType</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">        &gt;&gt;&gt; Speck32_KS.set_num_rounds(2)</span>
<span class="sd">        &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, LinearMask, [&quot;mk0&quot;, &quot;mk1&quot;, &quot;mk2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; v2c = {ch_model.input_mask[2]: core.Constant(0, 16)}  # setting input_mask[2] to 0</span>
<span class="sd">        &gt;&gt;&gt; at = ChModelAssertType.ProbabilityOne</span>
<span class="sd">        &gt;&gt;&gt; ch_finder = ChFinder(ch_model, at, &quot;btor&quot;, var_prop2ct_prop=v2c, solver_seed=0)</span>
<span class="sd">        &gt;&gt;&gt; ch_finder.formula_size()</span>
<span class="sd">        80</span>
<span class="sd">        &gt;&gt;&gt; print(ch_finder.hrepr(full_repr=False))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        ; initial constraints</span>
<span class="sd">        assert mk2 == 0x0000</span>
<span class="sd">        ; characteristic model assertions</span>
<span class="sd">        assert (~((mx1 ^ (... &gt;&gt;&gt; ...)) | (mx1 ^ mk2__0)) == 0xffff) &amp;</span>
<span class="sd">            (((mx1 ^ (mk1 &gt;&gt;&gt; 7) ^ mk2__0)[:1]) == 0b000000000000000)</span>
<span class="sd">        assert ((mk2__1 &lt;&lt;&lt; 2) == mx1) &amp; ((mk2__1 &lt;&lt;&lt; 2) == mx3)</span>
<span class="sd">        assert (~((mx5 ^ (... &gt;&gt;&gt; ...)) | (mx5 ^ mx3__0)) == 0xffff) &amp;</span>
<span class="sd">            (((mx5 ^ (mk0 &gt;&gt;&gt; 7) ^ mx3__0)[:1]) == 0b000000000000000)</span>
<span class="sd">        assert ((mx3__1 &lt;&lt;&lt; 2) == mx5) &amp; ((mx3__1 &lt;&lt;&lt; 2) == mx8)</span>
<span class="sd">        assert (mk2 ^ mk2__0 ^ mk2__1) == mk2_out</span>
<span class="sd">        assert (mx3 ^ mx3__0 ^ mx3__1) == mx3_out</span>
<span class="sd">        assert mx8 == mx8_out</span>

<span class="sd">    Attributes:</span>
<span class="sd">        ch_model: the underlying characteristic model (a subclass of</span>
<span class="sd">            `abstractproperty.chmodel.ChModel` or</span>
<span class="sd">            `abstractproperty.chmodel.EncryptionChModel`)</span>
<span class="sd">        assert_type: the type of assertions (an element from `ChModelAssertType`)</span>
<span class="sd">        solver_name: the pySMT solver name_</span>
<span class="sd">        initial_constraints: the list of additional constraints (given as `Term`)</span>
<span class="sd">            to add to the SMT problems (by default an empty list)</span>
<span class="sd">        printing_mode: the information to print (an element of `PrintingMode`,</span>
<span class="sd">            by default `PrintingMode.Silent`)</span>
<span class="sd">        filename: the filename where the messages</span>
<span class="sd">            will be printed (by default the standard output is used)</span>
<span class="sd">        weight_prefix: the prefix to label the weight variables</span>
<span class="sd">        solver_seed: the seed for the SMT solver</span>
<span class="sd">        env: the associated `pysmt.environment.Environment`</span>
<span class="sd">            (by default a new one is created)</span>
<span class="sd">        chmodel_asserts: the list containing the main assertions (`Term` objects)</span>
<span class="sd">            common to the SMT problems</span>

<span class="sd">    .. _name: https://github.com/pysmt/pysmt#solvers-support</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_model</span><span class="p">,</span> <span class="n">assert_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span>
                 <span class="n">initial_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_zero_input_prop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">var_prop2ct_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">printing_mode</span><span class="o">=</span><span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">weight_prefix</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">solver_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">ChModel</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assert_type</span><span class="p">,</span> <span class="n">ChModelAssertType</span><span class="p">)</span>

        <span class="kn">from</span> <span class="nn">cascada.algebraic.value</span> <span class="kn">import</span> <span class="n">Value</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">,</span> <span class="n">Value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;searching for algebraic characteristics with&quot;</span>
                                 <span class="s2">&quot; assert_type == ValidityAndWeight is not supported&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">EncryptionChModel</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="n">initial_constraints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">var_prop2ct_prop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;searching for algebraic EncryptionCharacteristic is usually done&quot;</span>
                              <span class="s2">&quot; to find the round keys given additional constraints fixing the input&quot;</span>
                              <span class="s2">&quot; and output values, but no additional constraints were provided&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2prop</span> <span class="ow">and</span> <span class="n">initial_constraints</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">var_prop2ct_prop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;searching for algebraic characteristics is usually done&quot;</span>
                              <span class="s2">&quot; with initial constraints fixing the input and/or output values,&quot;</span>
                              <span class="s2">&quot; but no additional constraints were provided&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">var2prop</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">weight_prefix</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;characteristic model cannot contain variable names starting&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot; with the weight prefix </span><span class="si">{</span><span class="n">weight_prefix</span><span class="si">}</span><span class="s2"> (found </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">printing_mode</span><span class="p">,</span> <span class="n">PrintingMode</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;write&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">env</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">environment</span><span class="o">.</span><span class="n">push_env</span><span class="p">()</span>
            <span class="n">env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">env</span> <span class="o">==</span> <span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span>

        <span class="k">assert</span> <span class="n">solver_name</span> <span class="ow">in</span> <span class="n">env</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">all_solvers</span><span class="p">(</span><span class="n">logics</span><span class="o">.</span><span class="n">QF_BV</span><span class="p">),</span> \
            <span class="sa">f</span><span class="s2">&quot;solver_name=</span><span class="si">{</span><span class="n">solver_name</span><span class="si">}</span><span class="s2"> not in the list of available pySMT solvers &quot;</span> \
            <span class="sa">f</span><span class="s2">&quot;supporting the logic QF_BV = </span><span class="si">{</span><span class="n">env</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">_all_solvers</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># initialize initial_constraints</span>

        <span class="k">if</span> <span class="n">initial_constraints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_constraints</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
            <span class="n">initial_constraints</span> <span class="o">=</span> <span class="n">initial_constraints</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="n">exclude_zero_input_prop</span><span class="p">:</span>
            <span class="n">compact_input</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">Concat</span><span class="p">,</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">input_prop</span><span class="p">])</span>
            <span class="n">initial_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">operation</span><span class="o">.</span><span class="n">BvNot</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">compact_input</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">compact_input</span><span class="o">.</span><span class="n">width</span><span class="p">))))</span>

        <span class="k">if</span> <span class="n">var_prop2ct_prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_var_prop2ct_prop</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">vp</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                    <span class="n">vp</span> <span class="o">=</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                    <span class="n">cp</span> <span class="o">=</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
                <span class="n">new_var_prop2ct_prop</span><span class="p">[</span><span class="n">vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span>
            <span class="n">var_prop2ct_prop</span> <span class="o">=</span> <span class="n">new_var_prop2ct_prop</span>
            <span class="k">for</span> <span class="n">vp</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">initial_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">vp</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_prop2ct_prop</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#</span>

        <span class="k">if</span> <span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
            <span class="n">ch_weight</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">weight_prefix</span><span class="p">,</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">weight_width</span><span class="p">())</span>
            <span class="c1"># awvs = assignment weight variables</span>
            <span class="n">awvs</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">weight_prefix</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">om</span><span class="o">.</span><span class="n">weight_width</span><span class="p">())</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">om</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ch_model</span><span class="o">.</span><span class="n">assign_outprop2op_model</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
            <span class="c1"># error is the ch_model error without the weight truncation error</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">error</span><span class="p">()</span>  <span class="c1"># avoid recomputing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ch_weight</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">awvs</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="c1">#</span>

        <span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="n">ChFinder</span><span class="o">.</span><span class="n">_get_chmodel_asserts</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">assert_type</span><span class="p">,</span> <span class="n">ch_weight</span><span class="o">=</span><span class="n">ch_weight</span><span class="p">,</span> <span class="n">awvs</span><span class="o">=</span><span class="n">awvs</span><span class="p">)</span>

        <span class="n">vars_in_constraints</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chmodel_asserts</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;found assertion False in chmodel_asserts&quot;</span><span class="p">)</span>
            <span class="n">vars_in_constraints</span> <span class="o">|=</span> <span class="n">c</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span>

        <span class="n">ChFinder</span><span class="o">.</span><span class="n">_check_initial_constraints</span><span class="p">(</span>
            <span class="n">ch_model</span><span class="p">,</span> <span class="n">initial_constraints</span><span class="p">,</span> <span class="n">chmodel_asserts</span><span class="p">,</span>
            <span class="n">exclude_zero_input_prop</span><span class="p">,</span> <span class="n">var_prop2ct_prop</span><span class="p">,</span>
            <span class="n">vars_in_constraints</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span> <span class="o">=</span> <span class="n">ch_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">=</span> <span class="n">assert_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">=</span> <span class="n">solver_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span> <span class="o">=</span> <span class="n">initial_constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">=</span> <span class="n">printing_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_prefix</span> <span class="o">=</span> <span class="n">weight_prefix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span> <span class="o">=</span> <span class="n">solver_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> <span class="n">env</span>  <span class="c1"># .env is a property</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="n">chmodel_asserts</span>

        <span class="c1"># variables not added in docstring (private variables)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exclude_zero_input_prop</span> <span class="o">=</span> <span class="n">exclude_zero_input_prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_prop2ct_prop</span> <span class="o">=</span> <span class="n">var_prop2ct_prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span> <span class="o">=</span> <span class="n">ch_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_awvs</span> <span class="o">=</span> <span class="n">awvs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_error</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars_in_constraints</span> <span class="o">=</span> <span class="n">vars_in_constraints</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">env</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">==</span> <span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_env&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="ow">in</span> <span class="n">environment</span><span class="o">.</span><span class="n">ENVIRONMENTS_STACK</span><span class="p">:</span>
            <span class="n">environment</span><span class="o">.</span><span class="n">ENVIRONMENTS_STACK</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_env</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_chmodel_asserts</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">assert_type</span><span class="p">,</span> <span class="n">ch_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">awvs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">Validity</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">validity_assertions</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ch_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">awvs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">assertions</span> <span class="o">=</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">validity_assertions</span><span class="p">()</span>
            <span class="n">assertions</span> <span class="o">+=</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">weight_assertions</span><span class="p">(</span><span class="n">ch_weight</span><span class="p">,</span> <span class="n">awvs</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">assertions</span>
        <span class="k">elif</span> <span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">pr_one_assertions</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid assert_type&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_initial_constraints</span><span class="p">(</span>
            <span class="n">ch_model</span><span class="p">,</span> <span class="n">initial_constraints</span><span class="p">,</span> <span class="n">chmodel_asserts</span><span class="p">,</span>
            <span class="n">exclude_zero_input_prop</span><span class="p">,</span> <span class="n">var_prop2ct_prop</span><span class="p">,</span>
            <span class="n">vars_in_constraints</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span>
    <span class="p">):</span>
        <span class="k">for</span> <span class="n">var_prop</span><span class="p">,</span> <span class="n">ct_prop</span> <span class="ow">in</span> <span class="n">var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">var_prop</span><span class="o">.</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vars_in_constraints</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;var </span><span class="si">{</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2"> from var_prop2ct_prop is not &quot;</span> \
                      <span class="sa">f</span><span class="s2">&quot;present in chmodel_asserts = </span><span class="si">{</span><span class="n">chmodel_asserts</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">raise_exception_missing_var</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingVarWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude_zero_input_prop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">input_prop</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vars_in_constraints</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;exclude_zero_input_prop is True but some &quot;</span> \
                          <span class="sa">f</span><span class="s2">&quot;input var (</span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2">) is not present in &quot;</span> \
                          <span class="sa">f</span><span class="s2">&quot;chmodel_asserts = </span><span class="si">{</span><span class="n">chmodel_asserts</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">raise_exception_missing_var</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingVarWarning</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_constraints</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;found constraint False in initial_constraints&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vars_in_constraints</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;var </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> from initial_constraints[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">] = </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> is not &quot;</span> \
                          <span class="sa">f</span><span class="s2">&quot;present in chmodel_asserts = </span><span class="si">{</span><span class="n">chmodel_asserts</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">raise_exception_missing_var</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">MissingVarWarning</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_pysmt_model2ch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_var2ct</span><span class="p">,</span> <span class="n">target_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_pysmt_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_sat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_pysmt_model</span><span class="p">:</span>
            <span class="n">solution_var2ct</span> <span class="o">=</span> <span class="n">pysmttypes</span><span class="o">.</span><span class="n">pysmt_model2bv_model</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solution_var2ct</span> <span class="o">=</span> <span class="n">solution_var2ct</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># to build a characteristic using get_properties_for_initialization,</span>
        <span class="c1"># all input/external properties, and output properties of non-Identity are needed</span>
        <span class="c1"># (note that these needed properties are not free properties (not affecting the ch)</span>
        <span class="c1"># (Unique signature cannot be used since it ignores op_model.max_weight() != 0)</span>

        <span class="k">def</span> <span class="nf">get_needed_vars</span><span class="p">(</span><span class="n">my_ch_model</span><span class="p">):</span>
            <span class="n">var_needed</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">input_prop</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">ssa</span><span class="o">.</span><span class="n">_input_vars_not_used</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ext_var</span><span class="p">,</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="n">var_needed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ext_var</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">outprop</span><span class="p">,</span> <span class="n">op_model</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">assign_outprop2op_model</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># if op_model.max_weight() != 0:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">ModelIdentity</span><span class="p">):</span>
                    <span class="n">var_needed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outprop</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">var_needed</span>

        <span class="n">missing_signature_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">get_needed_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solution_var2ct</span><span class="p">:</span>
                <span class="n">missing_signature_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">solution_var2ct</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="c1"># universally-invalid characteristics are invalid regardless of non-input non-output properties</span>
        <span class="n">in_out_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">input_prop</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">output_prop</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_signature_vars</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_sat</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span> <span class="ow">or</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">in_out_vars</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">missing_signature_vars</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="n">smart_print</span> <span class="o">=</span> <span class="n">_get_smart_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="s1">&#39;satisfiable&#39;</span> <span class="k">if</span> <span class="n">is_sat</span> <span class="k">else</span> <span class="s1">&#39;unsatisfiable&#39;</span><span class="si">}</span><span class="s2"> assignment &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;of SMT problem for all values of </span><span class="si">{</span><span class="n">missing_signature_vars</span><span class="si">}</span><span class="s2">; &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;setting </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">missing_signature_vars</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;to 0 in yielded characteristic&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span><span class="p">])</span> <span class="o">!=</span> <span class="n">target_weight</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SMT ch. weight = </span><span class="si">{</span><span class="n">solution_var2ct</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;!= </span><span class="si">{</span><span class="n">target_weight</span><span class="si">}</span><span class="s2"> = target_weight&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">EncryptionChModel</span><span class="p">):</span>
            <span class="n">Characteristic_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_get_EncryptionCharacteristic_cls</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">ChModel</span><span class="p">)</span>
            <span class="n">Characteristic_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_get_Characteristic_cls</span><span class="p">()</span>

        <span class="n">init_props</span> <span class="o">=</span> <span class="n">Characteristic_cls</span><span class="o">.</span><span class="n">get_properties_for_initialization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">solution_var2ct</span><span class="p">)</span>
        <span class="n">input_prop</span><span class="p">,</span> <span class="n">output_prop</span><span class="p">,</span> <span class="n">external_props</span><span class="p">,</span> <span class="n">assign_outprop_list</span> <span class="o">=</span> <span class="n">init_props</span>

        <span class="c1"># # debugging</span>
        <span class="c1"># print(&quot;\n_pysmt_model2ch&quot;)</span>
        <span class="c1"># print(&quot;ch model:&quot;, self.ch_model)</span>
        <span class="c1"># print(&quot;solution_var2ct:&quot;, solution_var2ct)</span>
        <span class="c1"># print(&quot;vars needed:&quot;, get_needed_vars(self.ch_model))</span>
        <span class="c1"># print(&quot;get_properties_for_initialization():&quot;, init_props, &quot;\n&quot;)</span>
        <span class="c1">#</span>

        <span class="c1"># avoid *prop=*prop</span>
        <span class="n">last_ch_found</span> <span class="o">=</span> <span class="n">Characteristic_cls</span><span class="p">(</span>
            <span class="n">input_prop</span><span class="p">,</span> <span class="n">output_prop</span><span class="p">,</span> <span class="n">assign_outprop_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">external_props</span><span class="p">,</span>
            <span class="n">empirical_ch_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empirical_data_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_valid</span><span class="o">=</span><span class="n">is_sat</span><span class="p">)</span>

        <span class="c1"># checks</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last_ch_found</span><span class="p">,</span> <span class="n">Characteristic_cls</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">assert</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ProbabilityOne</span>
                   <span class="ow">and</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exclude_zero_input_prop</span><span class="p">:</span>
            <span class="n">compact_input</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                <span class="n">operation</span><span class="o">.</span><span class="n">Concat</span><span class="p">,</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">input_prop</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">compact_input</span> <span class="o">==</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">compact_input</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exclude_zero_input_prop is True but characteristic input is &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">last_ch_found</span><span class="o">.</span><span class="n">input_prop</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">last_ch_found_v2c</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">var_prop</span><span class="p">,</span> <span class="n">ct_prop</span> <span class="ow">in</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">solution_var2ct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">ct_prop</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ct_prop</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SMT solution contains </span><span class="si">{</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">solution_var2ct</span><span class="p">[</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot; but characteristic contains </span><span class="si">{</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">ct_prop</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">last_ch_found_v2c</span><span class="p">[</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct_prop</span><span class="o">.</span><span class="n">val</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_prop2ct_prop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var_prop</span><span class="p">,</span> <span class="n">ct_prop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ch_ct_prop</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">ct_prop</span><span class="p">)(</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">last_ch_found_v2c</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ct_prop</span> <span class="o">!=</span> <span class="n">ch_ct_prop</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">var_prop</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ct_prop</span><span class="si">}</span><span class="s2">) was added in var_prop2ct_prop&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot; but </span><span class="si">{</span><span class="n">var_prop</span><span class="si">}</span><span class="s2"> has value </span><span class="si">{</span><span class="n">ch_ct_prop</span><span class="si">}</span><span class="s2"> in the characteristic&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Full solution: </span><span class="si">{</span><span class="n">last_ch_found_v2c</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1"># solution_var2ct include weight variables</span>
            <span class="n">last_ch_found_v2c</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">last_ch_found_v2c</span><span class="p">,</span> <span class="o">**</span><span class="n">solution_var2ct</span><span class="p">}</span>
            <span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">last_ch_found_v2c</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">]</span>
            <span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvAnd</span><span class="p">,</span> <span class="n">chmodel_asserts</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_sat</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chmodel_asserts</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">))</span> <span class="ow">and</span> <span class="n">chmodel_asserts</span> <span class="o">!=</span> <span class="n">is_sat</span><span class="p">:</span>
                <span class="c1"># if is_sat=False, some variables might be missing</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">is_sat</span><span class="si">}</span><span class="s2"> != chmodel_asserts = (</span><span class="si">{</span><span class="n">chmodel_asserts</span><span class="si">}</span><span class="s2">) for the characteristic found&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">SMT solution = </span><span class="si">{</span><span class="n">solution_var2ct</span><span class="si">}</span><span class="s2">)&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Full solution: </span><span class="si">{</span><span class="n">last_ch_found_v2c</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">last_ch_found</span><span class="o">.</span><span class="n">_check_bv_weights</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">),</span>
                <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_awvs</span><span class="p">])</span>

            <span class="n">smt_weight</span> <span class="o">=</span> <span class="n">target_weight</span>  <span class="c1"># bv-weight (w/ truncate=True)</span>
            <span class="n">ch_weight</span> <span class="o">=</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">ch_weight</span>  <span class="c1"># decimal.Decimal recomputed</span>
            <span class="n">abs_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">smt_weight</span> <span class="o">-</span> <span class="n">ch_weight</span><span class="p">)</span><span class="o">.</span><span class="n">copy_abs</span><span class="p">()</span>

            <span class="c1"># extra error due to truncate=True</span>
            <span class="c1"># e.g., if fb=2, max error = 0.11b (= 0.75 decimal) = 1 - 2**2</span>
            <span class="c1"># last factor to avoid Python decimal error</span>
            <span class="n">fb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">num_frac_bits</span><span class="p">()</span>
            <span class="n">extra_error</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">fb</span><span class="p">))</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">fb</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">extra_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># extra_error = max(abs(ch_weight - math.ceil(ch_weight)), abs(ch_weight - math.floor(ch_weight)))</span>

            <span class="n">max_abs_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error</span> <span class="o">+</span> <span class="n">extra_error</span>
            <span class="n">max_abs_error</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="n">max_abs_error</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span>
                <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1.&quot;</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">decimal</span><span class="o">.</span><span class="n">ROUND_UP</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">abs_error</span> <span class="o">&gt;</span> <span class="n">max_abs_error</span><span class="p">:</span>
                <span class="n">aux_ws</span> <span class="o">=</span> <span class="p">[(</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">solution_var2ct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight_prefix</span><span class="p">)]</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;absolute error between integer weight </span><span class="si">{</span><span class="n">smt_weight</span><span class="si">}</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;(found by the SMT solver from </span><span class="si">{</span><span class="n">aux_ws</span><span class="si">}</span><span class="s2">) and decimal weight </span><span class="si">{</span><span class="n">ch_weight</span><span class="si">}</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;(recomputed in Characteristic) is </span><span class="si">{</span><span class="n">abs_error</span><span class="si">}</span><span class="s2">, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;which is greater than maximum absolute error given by &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;ch_model-error=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error</span><span class="si">}</span><span class="s2"> + extra_error=</span><span class="si">{</span><span class="n">extra_error</span><span class="si">}</span><span class="s2">&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">last_ch_found</span>

<div class="viewcode-block" id="ChFinder.find_next_ch"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.ChFinder.find_next_ch">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_ch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yield_assignment</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that yields the characteristics found in the SMT-based search.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method requires that `assert_type` is either</span>
<span class="sd">            `Validity` or `ProbabilityOne` (and not `ValidityAndWeight`).</span>

<span class="sd">        This method searches for characteristic using SMT solvers.</span>
<span class="sd">        The decision problem of whether there exists a characteristic</span>
<span class="sd">        (following the characteristic model ``ch_model``)</span>
<span class="sd">        is encoded as an SMT problem and given to the SMT solver,</span>
<span class="sd">        which checks its satisfiability.</span>

<span class="sd">        If the SMT solver finds the first problem satisfiable,</span>
<span class="sd">        an assignment of the variables that makes the problem satisfiable is</span>
<span class="sd">        obtained, and a `abstractproperty.characteristic.Characteristic`</span>
<span class="sd">        object is created and *yielded*.</span>

<span class="sd">        .. note::</span>
<span class="sd">            If ``yield_assignment`` is ``True``, the assignment</span>
<span class="sd">            (as a dictionary mapping `Variable` to `Constant` objects)</span>
<span class="sd">            is yielded instead of the characteristic.</span>

<span class="sd">        Afterwards, an additional constraint is added to the SMT problem</span>
<span class="sd">        to exclude the characteristic yielded and this procedure is repeated</span>
<span class="sd">        until all characteristics are found.</span>

<span class="sd">            &gt;&gt;&gt; # example of search for LinearMask-Characteristic of Speck32.key_schedule</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.chmodel import ChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.smt.chsearch import ChFinder, ChModelAssertType</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, LinearMask, [&quot;mk0&quot;, &quot;mk1&quot;, &quot;mk2&quot;])</span>
<span class="sd">            &gt;&gt;&gt; v2c = {ch_model.input_mask[2]: core.Constant(0, 16)}  # setting input_mask[2] to 0</span>
<span class="sd">            &gt;&gt;&gt; at = ChModelAssertType.ProbabilityOne</span>
<span class="sd">            &gt;&gt;&gt; ch_finder = ChFinder(ch_model, at, &quot;btor&quot;, var_prop2ct_prop=v2c, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; for ch in ch_finder.find_next_ch(): print(ch.srepr()) # all 2-rounds probability-one trails</span>
<span class="sd">            Ch(w=0, id=0000 0000 0000, od=0000 0000 0000)</span>
<span class="sd">            Ch(w=0, id=0080 0080 0000, od=4001 4000 0001)</span>
<span class="sd">            Ch(w=0, id=0080 0000 0000, od=0000 4001 0001)</span>
<span class="sd">            Ch(w=0, id=0000 0080 0000, od=4001 0001 0000)</span>
<span class="sd">            &gt;&gt;&gt; # example of search for BitValue-EncryptionCharacteristic of Speck32</span>
<span class="sd">            &gt;&gt;&gt; from cascada.algebraic.value import BitValue</span>
<span class="sd">            &gt;&gt;&gt; from cascada.algebraic.chmodel import EncryptionChModel</span>
<span class="sd">            &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">            &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = EncryptionChModel(Speck32, BitValue)</span>
<span class="sd">            &gt;&gt;&gt; input_output_vals = ch_model.input_val + ch_model.output_val</span>
<span class="sd">            &gt;&gt;&gt; # setting each input and output word to 0x0001</span>
<span class="sd">            &gt;&gt;&gt; v2c = {v: core.Constant(1, 16) for v in input_output_vals}</span>
<span class="sd">            &gt;&gt;&gt; at = ChModelAssertType.Validity</span>
<span class="sd">            &gt;&gt;&gt; ch_finder = ChFinder(ch_model, at, &quot;btor&quot;, var_prop2ct_prop=v2c, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; found_ch = next(ch_finder.find_next_ch())</span>
<span class="sd">            &gt;&gt;&gt; round_sep = found_ch.get_round_separators()</span>
<span class="sd">            &gt;&gt;&gt; for round_ch in found_ch.split(round_sep): print(round_ch)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            Characteristic(ch_weight=0, assignment_weights=[0, 0, 0],</span>
<span class="sd">                input_val=[0x0001, 0x0001], output_val=[0x0004, 0x0000], external_vals=[0x0205],</span>
<span class="sd">                assign_outval_list=[0x0201, 0x0004, 0x0000])</span>
<span class="sd">            Characteristic(ch_weight=0, assignment_weights=[0, 0, 0],</span>
<span class="sd">                input_val=[0x0004, 0x0000], output_val=[0x0001, 0x0001], external_vals=[0x0801],</span>
<span class="sd">                assign_outval_list=[0x0800, 0x0001, 0x0001])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;find_next_ch requires assert_type != ChModelAssertType.ValidityAndWeight&quot;</span><span class="p">)</span>

        <span class="n">smart_print</span> <span class="o">=</span> <span class="n">_get_smart_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">symbolic_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">CurrentSignatureType</span><span class="p">)</span>

        <span class="n">parse_shifts_rotations</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">bv2pysmt</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">pysmttypes</span><span class="o">.</span><span class="n">bv2pysmt</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="n">parse_shifts_rotations</span><span class="o">=</span><span class="n">parse_shifts_rotations</span><span class="p">)</span>

        <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span><span class="p">:</span>
                <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;solver_options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;seed&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">}}</span>  <span class="c1"># btor seed uint32</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;random_seed&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">}</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span> <span class="n">logic</span><span class="o">=</span><span class="n">logics</span><span class="o">.</span><span class="n">QF_BV</span><span class="p">,</span> <span class="o">**</span><span class="n">solver_kwargs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">):</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">bv_model</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">last_ch_found</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bv_model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbolic_sig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;empty signature of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">last_ch_found</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">last_ch_sig</span> <span class="o">=</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">CurrentSignatureType</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">last_ch_sig</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">symbolic_sig</span><span class="p">:</span>
                        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">var2prop</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">bv_model</span><span class="p">)</span>
                        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                        <span class="n">last_ch_sig</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
                <span class="c1"># disable simplification due to recursion error</span>
                <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
                    <span class="n">exclude_last_ch</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                        <span class="n">operation</span><span class="o">.</span><span class="n">BvOr</span><span class="p">,</span>
                        <span class="p">[</span><span class="o">~</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">ls</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">ls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbolic_sig</span><span class="p">,</span> <span class="n">last_ch_sig</span><span class="p">)]</span>
                    <span class="p">)</span>
                <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">exclude_last_ch</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;exclude_last_ch: </span><span class="si">{</span><span class="n">exclude_last_ch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">satisfiable</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">satisfiable</span><span class="p">:</span>
                <span class="n">bv_model</span> <span class="o">=</span> <span class="n">pysmttypes</span><span class="o">.</span><span class="n">pysmt_model2bv_model</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">get_model</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">yield_assignment</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">bv_model</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">last_ch_found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pysmt_model2ch</span><span class="p">(</span><span class="n">bv_model</span><span class="p">,</span> <span class="n">is_pysmt_model</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">last_ch_found</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">solver</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_compute_empirical_ch_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_found</span><span class="p">,</span> <span class="n">empirical_weight_options</span><span class="p">):</span>
        <span class="n">ch_found</span><span class="o">.</span><span class="n">compute_empirical_ch_weight</span><span class="p">(</span><span class="o">**</span><span class="n">empirical_weight_options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_empirical_ch_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_found</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ch_found</span><span class="o">.</span><span class="n">empirical_ch_weight</span>

    <span class="k">def</span> <span class="nf">_get_ch_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_found</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ch_found</span><span class="o">.</span><span class="n">ch_weight</span>

    <span class="k">def</span> <span class="nf">_new_final_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_found</span><span class="p">,</span> <span class="n">prev_final_weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the new final weight given the previous characteristic yielded.</span>

<span class="sd">        Let B the error bound of the characteristic model.</span>
<span class="sd">        For the just found characteristic F, let F.W be the decimal weight</span>
<span class="sd">        and F.SW the SMT weight.</span>

<span class="sd">        If there exists a better characteristics G, then F.W ‹ G.W</span>
<span class="sd">        and G.SW ›= F.SW. But then, G.SW cannot be greater than</span>
<span class="sd">        F.W + B. Thus, the new final weight is at least F.W + B.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_final_weight</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">ch_found</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">prev_final_weight</span><span class="p">,</span> <span class="n">new_final_weight</span><span class="p">)</span>

<div class="viewcode-block" id="ChFinder.find_next_ch_increasing_weight"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.ChFinder.find_next_ch_increasing_weight">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_ch_increasing_weight</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">initial_weight</span><span class="p">,</span> <span class="n">final_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empirical_weight_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">stop_after_optimal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">yield_weight</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that yields the characteristics found in the SMT-based search</span>
<span class="sd">        with increasing weight order.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method requires that `assert_type` is `ValidityAndWeight`</span>
<span class="sd">            (and not `Validity` nor `ProbabilityOne`).</span>

<span class="sd">        This method searches for optimal characteristics (with optimal probability)</span>
<span class="sd">        using SMT solvers as follows.</span>

<span class="sd">        First, the probability space is decomposed into many intervals</span>
<span class="sd">        :math:`I_w = (2^{-w-1}, 2^{-w}]`,</span>
<span class="sd">        where ``w = initial_weight, initial_weight + 1, ..., final_weight``.</span>
<span class="sd">        For each interval, the decision problem of whether there exists a</span>
<span class="sd">        characteristic (following the characteristic model ``ch_model``)</span>
<span class="sd">        with probability :math:`p \in I_w` is encoded as an</span>
<span class="sd">        SMT problem. Note that a characteristic has probability :math:`p \in I_w`</span>
<span class="sd">        if and only if its integer weight (the integer part of the weight)</span>
<span class="sd">        is equal to :math:`w`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            See `abstractproperty.characteristic.Characteristic` for</span>
<span class="sd">            the characteristic probability and weight considered here.</span>

<span class="sd">        The SMT problems are provided to the SMT solver,</span>
<span class="sd">        which checks their satisfiability in increasing weight order.</span>
<span class="sd">        When the SMT solver finds the first problem satisfisable,</span>
<span class="sd">        an assignment of the variables that makes the problem satisfiable is</span>
<span class="sd">        obtained, and a `abstractproperty.characteristic.Characteristic`</span>
<span class="sd">        object is created and *yielded*.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If ``yield_weight`` is ``True``, a tuple is yielded instead,</span>
<span class="sd">            containing the target weight :math:`w` and the characteristic.</span>

<span class="sd">            If ``empirical_weight_options`` is provided, before yielding</span>
<span class="sd">            the characteristic, the empirical weight</span>
<span class="sd">            of the characteristic is computed by calling the method</span>
<span class="sd">            `abstractproperty.characteristic.Characteristic.compute_empirical_ch_weight`</span>
<span class="sd">            with the given options as arguments (see below for an explanation</span>
<span class="sd">            of ``empirical_weight_options``).</span>
<span class="sd">            Importantly, if the empirical weight computed is ``math.inf``,</span>
<span class="sd">            this characteristic is NOT yielded and the search continues.</span>
<span class="sd">            If ``empirical_weight_options`` is not provided, all characteristics</span>
<span class="sd">            found are yielded.</span>

<span class="sd">        If the error bound of the associated characteristic model</span>
<span class="sd">        (see `abstractproperty.chmodel.ChModel.error`) is zero,</span>
<span class="sd">        the first characteristic yielded is optimal in the sense that</span>
<span class="sd">        there are no characteristics with integer weight strictly smaller,</span>
<span class="sd">        and the search finishes (if ``stop_after_optimal is True``,</span>
<span class="sd">        otherwise it continues until all characteristics are found).</span>

<span class="sd">        .. note::</span>

<span class="sd">            Note the first characteristic yielded is optimal for the</span>
<span class="sd">            characteristic probability here considered, which might be</span>
<span class="sd">            an approximation of the actual characteristic probability</span>
<span class="sd">            (e.g., see `differential.characteristic.Characteristic`</span>
<span class="sd">            or `linear.characteristic.Characteristic`).</span>

<span class="sd">        Let :math:`\hat{w}` the weight of the first characteristic yielded.</span>
<span class="sd">        If the error bound of the associated characteristic model is</span>
<span class="sd">        :math:`e &gt; 0`, then the search continues yielding all characteristics</span>
<span class="sd">        with weights between :math:`\hat{w}` and :math:`\hat{w} + e`.</span>
<span class="sd">        After all these characteristics have been yielded,</span>
<span class="sd">        the optimal characteristic (the characteristic among all yielded</span>
<span class="sd">        characteristics with the lowest</span>
<span class="sd">        `abstractproperty.characteristic.Characteristic.ch_weight`)</span>
<span class="sd">        is yielded again and the search finishes</span>
<span class="sd">        (if ``stop_after_optimal is True``,  otherwise it continues until all</span>
<span class="sd">        characteristics are found).</span>

<span class="sd">        .. note::</span>

<span class="sd">            After the iterator is exhausted, the last characteristic yielded</span>
<span class="sd">            is always the optimal, but the optimal characteristic is only yielded</span>
<span class="sd">            twice if it is different from the previous characteristic yielded.</span>

<span class="sd">            Moreoever, if ``yield_weight`` is ``True``, the second time</span>
<span class="sd">            the optimal characteristic is yielded a tuple is also yielded,</span>
<span class="sd">            but the first entry in the tuple contains ``None``</span>
<span class="sd">            (the target weight of the optimal characteristic is</span>
<span class="sd">            yielded the first time the optimal characteristic is yielded).</span>

<span class="sd">        ::</span>

<span class="sd">            &gt;&gt;&gt; # example of search for XorDiff-EncryptionCharacteristic of Speck32</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff, RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.chmodel import ChModel, EncryptionChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.smt.chsearch import ChFinder, ChModelAssertType</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">            &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = EncryptionChModel(Speck32, XorDiff)</span>
<span class="sd">            &gt;&gt;&gt; assert_type = ChModelAssertType.ValidityAndWeight</span>
<span class="sd">            &gt;&gt;&gt; ch_finder = ChFinder(ch_model, assert_type, &quot;btor&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; # no need to exclude the input zero XOR difference if initial_weight != 0</span>
<span class="sd">            &gt;&gt;&gt; ewo = {&quot;seed&quot;: 0}  # no need to specify all args</span>
<span class="sd">            &gt;&gt;&gt; next(ch_finder.find_next_ch_increasing_weight(1, empirical_weight_options=ewo))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            EncryptionCharacteristic(ch_weight=1, empirical_ch_weight=1.027020213933709037746664618,</span>
<span class="sd">                assignment_weights=[1, 0, 0, 0],</span>
<span class="sd">                input_diff=[0x0010, 0x2000], output_diff=[0x8000, 0x8002], external_diffs=[0x0000, 0x0000],</span>
<span class="sd">                assign_outdiff_list=[0x0000, 0x8000, 0x8000, 0x8002])</span>
<span class="sd">            &gt;&gt;&gt; # example of search for RXDiff-Characteristic of Speck32.key_schedule</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, RXDiff, [&quot;dmk0&quot;, &quot;dmk1&quot;, &quot;dmk2&quot;])</span>
<span class="sd">            &gt;&gt;&gt; dmk0, dmk1 = ch_model.input_diff[:2]</span>
<span class="sd">            &gt;&gt;&gt; v2c = {dmk0: core.Constant(0, 16), dmk1: core.Constant(0, 16)}</span>
<span class="sd">            &gt;&gt;&gt; ch_finder = ChFinder(ch_model, assert_type, &quot;btor&quot;, var_prop2ct_prop=v2c, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; for ch in ch_finder.find_next_ch_increasing_weight(1): print(ch.srepr())  # doctest: +ELLIPSIS</span>
<span class="sd">            Ch(w=2.830, id=0000 0000 0000, od=0000 0001 0007)</span>
<span class="sd">            ...</span>
<span class="sd">            Ch(w=3.830, id=0000 0000 8000, od=8000 8002 800b)</span>
<span class="sd">            ...</span>
<span class="sd">            Ch(w=4.830, id=0000 0000 0001, od=0001 0005 001b)</span>
<span class="sd">            ...</span>
<span class="sd">            Ch(w=4.830, id=0000 0000 8000, od=8000 8002 800e)</span>
<span class="sd">            Ch(w=2.830, id=0000 0000 0000, od=0000 0001 0007)</span>

<span class="sd">        Args:</span>
<span class="sd">            initial_weight: the initial weight to start the search</span>
<span class="sd">            final_weight: the last weight to consider in the search</span>
<span class="sd">                (by default ``math.inf``)</span>
<span class="sd">            empirical_weight_options: (optional) a dictionary containing</span>
<span class="sd">                the arguments of</span>
<span class="sd">                `abstractproperty.characteristic.Characteristic.compute_empirical_ch_weight`</span>
<span class="sd">                (used similar as ``**kwargs``, that is,</span>
<span class="sd">                ``compute_empirical_ch_weight(**empirical_weight_options)``</span>
<span class="sd">            yield_weight: if ``True``, the target weight of the SMT problem</span>
<span class="sd">                is also yielded (default ``False``)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_weight</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">initial_weight</span> <span class="o">&gt;=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">initial_weight</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exclude_zero_input_prop</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;the constraint excluding the zero input property is being added&quot;</span>
                          <span class="s2">&quot; to the SMT problem but might be redundant since initial_weight &gt; 0&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">final_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">final_weight</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">final_weight</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">final_weight</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">final_weight</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">initial_weight</span> <span class="o">&lt;=</span> <span class="n">final_weight</span>

        <span class="k">if</span> <span class="n">empirical_weight_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">empirical_weight_options</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">empirical_weight_options</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">ewos</span> <span class="o">=</span> <span class="n">empirical_weight_options</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ewos</span> <span class="o">=</span> <span class="p">[</span><span class="n">empirical_weight_options</span><span class="p">]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;num_input_samples&quot;</span><span class="p">,</span> <span class="s2">&quot;num_external_samples&quot;</span><span class="p">,</span> <span class="s2">&quot;split_by_max_weight&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;split_by_rounds&quot;</span><span class="p">,</span> <span class="s2">&quot;seed&quot;</span><span class="p">,</span> <span class="s2">&quot;C_code&quot;</span><span class="p">,</span> <span class="s2">&quot;num_parallel_processes&quot;</span><span class="p">}</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ewo</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">ewo</span> <span class="ow">in</span> <span class="n">ewos</span> <span class="k">if</span> <span class="n">ewo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">!=</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;find_next_ch_increasing_weight requires assert_type == &quot;</span>
                             <span class="s2">&quot;ChModelAssertType.ValidityAndWeight&quot;</span><span class="p">)</span>

        <span class="n">smart_print</span> <span class="o">=</span> <span class="n">_get_smart_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">symbolic_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">CurrentSignatureType</span><span class="p">)</span>

        <span class="n">parse_shifts_rotations</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">bv2pysmt</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">pysmttypes</span><span class="o">.</span><span class="n">bv2pysmt</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="n">parse_shifts_rotations</span><span class="o">=</span><span class="n">parse_shifts_rotations</span><span class="p">)</span>

        <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span><span class="p">:</span>
                <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;solver_options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;seed&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">}}</span>  <span class="c1"># btor seed uint32</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;random_seed&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">}</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span> <span class="n">logic</span><span class="o">=</span><span class="n">logics</span><span class="o">.</span><span class="n">QF_BV</span><span class="p">,</span> <span class="o">**</span><span class="n">solver_kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">):</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">best_ch_found</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_ch_weight</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">last_ch_found</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">target_weight</span> <span class="o">=</span> <span class="n">initial_weight</span>

        <span class="k">while</span> <span class="n">target_weight</span> <span class="o">&lt;</span> <span class="n">final_weight</span> <span class="ow">or</span> <span class="p">(</span><span class="n">target_weight</span> <span class="o">==</span> <span class="n">final_weight</span> <span class="ow">and</span> <span class="n">last_ch_found</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>
            <span class="n">target_weight_constraint</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">target_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">target_weight_constraint</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solving for weight = </span><span class="si">{</span><span class="n">target_weight</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># find all ch with given target_weight</span>
                <span class="k">if</span> <span class="n">last_ch_found</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbolic_sig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;empty signature of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="n">last_ch_sig</span> <span class="o">=</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">CurrentSignatureType</span><span class="p">)</span>
                    <span class="c1"># disable simplification due to recursion error</span>
                    <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
                        <span class="n">exclude_last_ch</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                            <span class="n">operation</span><span class="o">.</span><span class="n">BvOr</span><span class="p">,</span>
                            <span class="p">[</span><span class="o">~</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">ls</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">ls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbolic_sig</span><span class="p">,</span> <span class="n">last_ch_sig</span><span class="p">)]</span>
                        <span class="p">)</span>
                    <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">exclude_last_ch</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;exclude_last_ch: </span><span class="si">{</span><span class="n">exclude_last_ch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">satisfiable</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">satisfiable</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">last_ch_found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pysmt_model2ch</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">get_model</span><span class="p">(),</span> <span class="n">target_weight</span><span class="p">)</span>

                    <span class="n">valid_ch</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">empirical_weight_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_compute_empirical_ch_weight</span><span class="p">(</span><span class="n">last_ch_found</span><span class="p">,</span> <span class="n">empirical_weight_options</span><span class="p">)</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_empirical_ch_weight</span><span class="p">(</span><span class="n">last_ch_found</span><span class="p">)</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">WeightsAndSrepr</span><span class="p">:</span>
                                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid characteristic found | </span><span class="si">{</span><span class="n">last_ch_found</span><span class="o">.</span><span class="n">srepr</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="n">PrintingMode</span><span class="o">.</span><span class="n">WeightsAndVrepr</span><span class="p">,</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">]:</span>
                                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid characteristic found | </span><span class="si">{</span><span class="n">last_ch_found</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="n">valid_ch</span> <span class="o">=</span> <span class="kc">False</span>

                    <span class="k">if</span> <span class="n">valid_ch</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">yield_weight</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="p">(</span><span class="n">target_weight</span><span class="p">,</span> <span class="n">last_ch_found</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">last_ch_found</span>

                        <span class="k">if</span> <span class="n">best_ch_weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ch_weight</span><span class="p">(</span><span class="n">last_ch_found</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">best_ch_weight</span><span class="p">:</span>
                            <span class="n">best_ch_found</span> <span class="o">=</span> <span class="n">last_ch_found</span>
                            <span class="n">best_ch_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ch_weight</span><span class="p">(</span><span class="n">best_ch_found</span><span class="p">)</span>
                            <span class="n">new_final_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_final_weight</span><span class="p">(</span><span class="n">best_ch_found</span><span class="p">,</span> <span class="n">final_weight</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">stop_after_optimal</span> <span class="ow">and</span> <span class="n">new_final_weight</span> <span class="o">!=</span> <span class="n">final_weight</span><span class="p">:</span>
                                <span class="n">final_weight</span> <span class="o">=</span> <span class="n">new_final_weight</span>
                                <span class="k">del</span> <span class="n">new_final_weight</span>
                                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">:</span>
                                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final weight decreased to </span><span class="si">{</span><span class="n">final_weight</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">final_weight</span> <span class="o">&lt;=</span> <span class="n">target_weight</span><span class="p">:</span>
                                    <span class="k">break</span>  <span class="c1"># found optimal</span>

            <span class="c1"># target_weight exhausted</span>
            <span class="n">target_weight</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">best_ch_found</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">best_ch_found</span> <span class="o">!=</span> <span class="n">last_ch_found</span><span class="p">:</span>
                <span class="c1"># no need to return twice the same ch</span>
                <span class="k">if</span> <span class="n">yield_weight</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">best_ch_found</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">best_ch_found</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">last_ch_found</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="n">solver</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span></div>

<div class="viewcode-block" id="ChFinder.formula_size"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.ChFinder.formula_size">[docs]</a>    <span class="k">def</span> <span class="nf">formula_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">measure</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the size of the underlying SMT problem.</span>

<span class="sd">        See `pysmt.oracles.SizeOracle` for choosing ``measure``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">environment</span><span class="o">.</span><span class="n">push_env</span><span class="p">()</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">env</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span>
        <span class="n">bv2pysmt</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">pysmttypes</span><span class="o">.</span><span class="n">bv2pysmt</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">env</span><span class="o">.</span><span class="n">sizeo</span><span class="o">.</span><span class="n">get_size</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">measure</span><span class="p">)</span>
        <span class="n">environment</span><span class="o">.</span><span class="n">pop_env</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span>
        <span class="k">return</span> <span class="n">size</span></div>

<div class="viewcode-block" id="ChFinder.hrepr"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.ChFinder.hrepr">[docs]</a>    <span class="k">def</span> <span class="nf">hrepr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_repr</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a human-readable representation of the base SMT problem.</span>

<span class="sd">        The base SMT problem is the SMT problem containing the validity,</span>
<span class="sd">        probability-one and/or weight assertions (depending on ``assert_type``)</span>
<span class="sd">        and the additional constraints from `initial_constraints`,</span>
<span class="sd">        but excluding constraints created during the search such as</span>
<span class="sd">        the constraints fixing the characteristic weight variable to a</span>
<span class="sd">        constant value in `find_next_ch_increasing_weight`.</span>

<span class="sd">        If ``full_repr`` is False, the short string representation srepr is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">representation</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">:</span>
            <span class="n">representation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;; initial constraints&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">:</span>
                <span class="n">representation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;assert </span><span class="si">{</span><span class="n">c</span> <span class="k">if</span> <span class="n">full_repr</span> <span class="k">else</span> <span class="n">c</span><span class="o">.</span><span class="n">srepr</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">representation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;; characteristic model assertions&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">:</span>
            <span class="n">representation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;assert </span><span class="si">{</span><span class="n">c</span> <span class="k">if</span> <span class="n">full_repr</span> <span class="k">else</span> <span class="n">c</span><span class="o">.</span><span class="n">srepr</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">representation</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CipherChFinder"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.CipherChFinder">[docs]</a><span class="k">class</span> <span class="nc">CipherChFinder</span><span class="p">(</span><span class="n">ChFinder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search for cipher characteristics by modeling the search as a sequence of SMT problems.</span>

<span class="sd">    Given a characteristic model of a `Cipher`</span>
<span class="sd">    (`abstractproperty.chmodel.CipherChModel`)</span>
<span class="sd">    defined for a particular `Property` (e.g., `XorDiff` or `BitValue`),</span>
<span class="sd">    this class finds characteristics</span>
<span class="sd">    (`abstractproperty.characteristic.CipherCharacteristic`)</span>
<span class="sd">    satisfying the characteristic model by modelling the search</span>
<span class="sd">    as a sequence of SMT problems in the bit-vector theory.</span>

<span class="sd">    To initialize a `CipherChFinder` object, first two auxiliary instances of</span>
<span class="sd">    `ChFinder` are created:</span>

<span class="sd">    - ``ks_finder``: a `ChFinder` with arguments</span>
<span class="sd">      ``ch_model.ks_ch_model``, ``ks_assert_type``</span>
<span class="sd">      ``ks_exclude_zero_input_prop`` and ``ks_weight_prefix``</span>
<span class="sd">    - ``enc_finder``: a `ChFinder` with arguments</span>
<span class="sd">      ``ch_model.enc_ch_model``, ``enc_assert_type``,</span>
<span class="sd">      ``enc_exclude_zero_input_prop`` amd ``enc_weight_prefix``</span>

<span class="sd">    Both ``ks_finder`` and ``enc_finder`` (together with the `CipherChFinder` object)</span>
<span class="sd">    share the arguments `solver_name`, `printing_mode`,</span>
<span class="sd">    `filename`,  `solver_seed` and `env`.</span>

<span class="sd">    Then, these two auxiliary `ChFinder` objects are merged into a `CipherChFinder`</span>
<span class="sd">    (which is also an instance of `ChFinder`) as follows:</span>

<span class="sd">    - ``solver_name``, ``printing_mode``, ``filename``,  ``solver_seed``</span>
<span class="sd">      ``env`` are the same as the ones from ``ks_finder`` and ``enc_finder``</span>
<span class="sd">    - ``ch_model`` is set to the characteristic model of the cipher</span>
<span class="sd">      (a subclass of `abstractproperty.chmodel.CipherChModel`)</span>
<span class="sd">    - ``assert_type`` is set as the *largest* assertion type, following</span>
<span class="sd">      the order `ValidityAndWeight` &gt; `Validity` &gt; `ProbabilityOne`</span>
<span class="sd">    - ``initial_constraints`` contains all initial constraints</span>
<span class="sd">      (including the ones derived from ``ks_exclude_zero_input_prop``,</span>
<span class="sd">      ``enc_exclude_zero_input_prop`` and ``var_prop2ct_prop``)</span>
<span class="sd">    - ``chmodel_asserts`` is the union of `chmodel_asserts` of</span>
<span class="sd">      ``ks_finder`` and ``enc_finder``</span>

<span class="sd">    See also `ChFinder`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.chmodel import CipherChModel</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.chsearch import CipherChFinder, ChModelAssertType</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">        &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">        &gt;&gt;&gt; ch_model = CipherChModel(Speck32, XorDiff)</span>
<span class="sd">        &gt;&gt;&gt; assert_type = ChModelAssertType.ValidityAndWeight</span>
<span class="sd">        &gt;&gt;&gt; ch_finder = CipherChFinder(ch_model, assert_type, assert_type, &quot;btor&quot;,</span>
<span class="sd">        ...                            enc_exclude_zero_input_prop=True, solver_seed=0)</span>
<span class="sd">        &gt;&gt;&gt; ch_finder.formula_size()</span>
<span class="sd">        1290</span>
<span class="sd">        &gt;&gt;&gt; print(ch_finder.hrepr(full_repr=False))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        ; initial constraints</span>
<span class="sd">        assert ~((dp0 :: dp1) == 0x00000000)</span>
<span class="sd">        ; characteristic model assertions</span>
<span class="sd">        assert ((~(... &lt;&lt; ...) ^ (dmk1 &lt;&lt; 0x0001)) &amp; (~(... &lt;&lt; ...) ^ (dk1 &lt;&lt; 0x0001)) &amp;</span>
<span class="sd">            ((... &gt;&gt;&gt; ...) ^ dmk1 ^ dk1 ^ ((dmk0 &gt;&gt;&gt; 7) &lt;&lt; 0x0001))) == 0x0000</span>
<span class="sd">        assert dmk1 == dmk1_out</span>
<span class="sd">        assert ((dmk1 &lt;&lt;&lt; 2) ^ dk1) == dk3_out</span>
<span class="sd">        assert wk0 == PopCount(~((~... ^ dmk1) &amp; (~... ^ dk1))[14:])</span>
<span class="sd">        assert wk1 == 0b0</span>
<span class="sd">        assert wk2 == 0b0</span>
<span class="sd">        assert wk == wk0</span>
<span class="sd">        assert ((~(... &lt;&lt; ...) ^ (dp1 &lt;&lt; 0x0001)) &amp; (~(... &lt;&lt; ...) ^ (dx1 &lt;&lt; 0x0001)) &amp;</span>
<span class="sd">            ((... &gt;&gt;&gt; ...) ^ dp1 ^ dx1 ^ ((dp0 &gt;&gt;&gt; 7) &lt;&lt; 0x0001))) == 0x0000</span>
<span class="sd">        assert ((~(... &lt;&lt; ...) ^ ((... ^ ...) &lt;&lt; 0x0001)) &amp; (~(... &lt;&lt; ...) ^ (dx6 &lt;&lt; 0x0001)) &amp;</span>
<span class="sd">            ((... &gt;&gt;&gt; ...) ^ ... ^ ... ^ dx6 ^ (((... ^ ...) &gt;&gt;&gt; 7) &lt;&lt; 0x0001))) == 0x0000</span>
<span class="sd">        assert (dx6 ^ dk3_out) == dx7_out</span>
<span class="sd">        assert ((((dp1 &lt;&lt;&lt; 2) ^ dx1 ^ dmk1_out) &lt;&lt;&lt; 2) ^ dx6 ^ dk3_out) == dx9_out</span>
<span class="sd">        assert we0 == PopCount(~((~... ^ dp1) &amp; (~... ^ dx1))[14:])</span>
<span class="sd">        assert we1 == PopCount(~((~... ^ ... ^ ...) &amp; (~... ^ dx6))[14:])</span>
<span class="sd">        assert we2 == 0b0</span>
<span class="sd">        assert we3 == 0b0</span>
<span class="sd">        assert we == ((0b0 :: we0) + (0b0 :: we1))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_model</span><span class="p">,</span> <span class="n">ks_assert_type</span><span class="p">,</span> <span class="n">enc_assert_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span>
                 <span class="n">initial_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ks_exclude_zero_input_prop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">enc_exclude_zero_input_prop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">var_prop2ct_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">printing_mode</span><span class="o">=</span><span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ks_weight_prefix</span><span class="o">=</span><span class="s2">&quot;wk&quot;</span><span class="p">,</span> <span class="n">enc_weight_prefix</span><span class="o">=</span><span class="s2">&quot;we&quot;</span><span class="p">,</span> <span class="n">solver_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">CipherChModel</span><span class="p">)</span>

        <span class="n">ks_finder</span> <span class="o">=</span> <span class="n">ChFinder</span><span class="p">(</span>
            <span class="n">ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="p">,</span> <span class="n">assert_type</span><span class="o">=</span><span class="n">ks_assert_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="n">solver_name</span><span class="p">,</span>
            <span class="n">initial_constraints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_zero_input_prop</span><span class="o">=</span><span class="n">ks_exclude_zero_input_prop</span><span class="p">,</span>
            <span class="n">var_prop2ct_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">printing_mode</span><span class="o">=</span><span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_prefix</span><span class="o">=</span><span class="n">ks_weight_prefix</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># initial_constraints=[] to avoid algebraic warning</span>
        <span class="n">enc_finder</span> <span class="o">=</span> <span class="n">ChFinder</span><span class="p">(</span>
            <span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="p">,</span> <span class="n">assert_type</span><span class="o">=</span><span class="n">enc_assert_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="n">solver_name</span><span class="p">,</span>
            <span class="n">initial_constraints</span><span class="o">=</span><span class="p">[],</span> <span class="n">exclude_zero_input_prop</span><span class="o">=</span><span class="n">enc_exclude_zero_input_prop</span><span class="p">,</span>
            <span class="n">var_prop2ct_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">printing_mode</span><span class="o">=</span><span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">weight_prefix</span><span class="o">=</span><span class="n">enc_weight_prefix</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">env</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">env</span> <span class="o">==</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">env</span>

        <span class="c1"># initialize initial_constraints</span>
        
        <span class="k">if</span> <span class="n">initial_constraints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial_constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_constraints</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
            <span class="n">initial_constraints</span> <span class="o">=</span> <span class="n">initial_constraints</span><span class="p">[:]</span>

        <span class="n">initial_constraints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">)</span>
        <span class="n">initial_constraints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">)</span>

        <span class="c1"># *_exclude_zero_input_prop processed in *_finder&#39;s init method</span>

        <span class="n">prop_type</span> <span class="o">=</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">prop_type</span>
        <span class="k">assert</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">prop_type</span> <span class="o">==</span> <span class="n">prop_type</span>

        <span class="k">if</span> <span class="n">var_prop2ct_prop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_var_prop2ct_prop</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">vp</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                    <span class="n">vp</span> <span class="o">=</span> <span class="n">prop_type</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                    <span class="n">cp</span> <span class="o">=</span> <span class="n">prop_type</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>
                <span class="n">new_var_prop2ct_prop</span><span class="p">[</span><span class="n">vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span>
            <span class="n">var_prop2ct_prop</span> <span class="o">=</span> <span class="n">new_var_prop2ct_prop</span>
            <span class="k">for</span> <span class="n">vp</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">initial_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">vp</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_prop2ct_prop</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1">#</span>

        <span class="n">kat</span><span class="p">,</span> <span class="n">eat</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">assert_type</span><span class="p">,</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">assert_type</span>
        <span class="n">CMAT</span> <span class="o">=</span> <span class="n">ChModelAssertType</span>
        <span class="k">if</span> <span class="n">kat</span> <span class="o">==</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span> <span class="ow">and</span> <span class="n">eat</span> <span class="o">==</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
            <span class="n">max_weight</span> <span class="o">=</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">max_weight</span><span class="p">(</span><span class="n">truncate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">max_weight</span> <span class="o">+=</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">max_weight</span><span class="p">(</span><span class="n">truncate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">max_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_weight</span><span class="o">.</span><span class="n">bit_length</span><span class="p">(),</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="n">ch_weight</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">zero_extend</span><span class="p">(</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="p">,</span> <span class="n">max_width</span> <span class="o">-</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="n">ch_weight</span> <span class="o">+=</span> <span class="n">operation</span><span class="o">.</span><span class="n">zero_extend</span><span class="p">(</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="p">,</span> <span class="n">max_width</span> <span class="o">-</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">error</span><span class="p">()</span> <span class="o">+</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">error</span><span class="p">()</span>
            <span class="n">assert_type</span> <span class="o">=</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span>  <span class="c1"># for super() calls</span>
        <span class="k">elif</span> <span class="n">kat</span> <span class="ow">in</span> <span class="p">[</span><span class="n">CMAT</span><span class="o">.</span><span class="n">Validity</span><span class="p">,</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">]</span> <span class="ow">and</span> <span class="n">eat</span> <span class="o">==</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_error</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">ch_weight</span> <span class="o">=</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">error</span><span class="p">()</span>
            <span class="n">assert_type</span> <span class="o">=</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span>
        <span class="k">elif</span> <span class="n">kat</span> <span class="o">==</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span> <span class="ow">and</span> <span class="n">eat</span> <span class="ow">in</span> <span class="p">[</span><span class="n">CMAT</span><span class="o">.</span><span class="n">Validity</span><span class="p">,</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_error</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">ch_weight</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">error</span><span class="p">()</span>
            <span class="n">assert_type</span> <span class="o">=</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">kat</span> <span class="ow">in</span> <span class="p">[</span><span class="n">CMAT</span><span class="o">.</span><span class="n">Validity</span><span class="p">,</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">]</span> <span class="ow">and</span> <span class="n">eat</span> <span class="ow">in</span> <span class="p">[</span><span class="n">CMAT</span><span class="o">.</span><span class="n">Validity</span><span class="p">,</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_error</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_error</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">ch_weight</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">Validity</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">kat</span><span class="p">,</span> <span class="n">eat</span><span class="p">]:</span>
                <span class="n">assert_type</span> <span class="o">=</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ProbabilityOne</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">assert_type</span> <span class="o">=</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">Validity</span>

        <span class="c1">#</span>

        <span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">chmodel_asserts</span> <span class="o">+</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">chmodel_asserts</span>
        <span class="n">vars_in_constraints</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_vars_in_constraints</span> <span class="o">|</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_vars_in_constraints</span>

        <span class="n">ChFinder</span><span class="o">.</span><span class="n">_check_initial_constraints</span><span class="p">(</span>
            <span class="n">ks_finder</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">initial_constraints</span><span class="p">,</span> <span class="n">chmodel_asserts</span><span class="p">,</span>
            <span class="n">ks_exclude_zero_input_prop</span><span class="p">,</span> <span class="n">var_prop2ct_prop</span><span class="p">,</span> <span class="n">vars_in_constraints</span><span class="p">,</span>
            <span class="n">raise_exception_missing_var</span>
        <span class="p">)</span>
        <span class="n">ChFinder</span><span class="o">.</span><span class="n">_check_initial_constraints</span><span class="p">(</span>
            <span class="n">enc_finder</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">initial_constraints</span><span class="p">,</span> <span class="n">chmodel_asserts</span><span class="p">,</span>
            <span class="n">enc_exclude_zero_input_prop</span><span class="p">,</span> <span class="n">var_prop2ct_prop</span><span class="p">,</span> <span class="n">vars_in_constraints</span><span class="p">,</span>
            <span class="n">raise_exception_missing_var</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span> <span class="o">=</span> <span class="n">ks_finder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span> <span class="o">=</span> <span class="n">enc_finder</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span> <span class="o">=</span> <span class="n">ch_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">=</span> <span class="n">assert_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">=</span> <span class="n">solver_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span> <span class="o">=</span> <span class="n">initial_constraints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">=</span> <span class="n">printing_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_prefix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span> <span class="o">=</span> <span class="n">solver_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="n">chmodel_asserts</span>

        <span class="c1"># variables not added in docstring (private variables)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exclude_zero_input_prop</span> <span class="o">=</span> <span class="n">ks_exclude_zero_input_prop</span> <span class="ow">and</span> <span class="n">enc_exclude_zero_input_prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_prop2ct_prop</span> <span class="o">=</span> <span class="n">var_prop2ct_prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span> <span class="o">=</span> <span class="n">ch_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_error</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars_in_constraints</span> <span class="o">=</span> <span class="n">vars_in_constraints</span>

    <span class="k">def</span> <span class="nf">_pysmt_model2ch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_var2ct</span><span class="p">,</span> <span class="n">target_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_pysmt_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_sat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">is_sat</span> <span class="ow">is</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">is_pysmt_model</span><span class="p">:</span>
            <span class="n">solution_var2ct</span> <span class="o">=</span> <span class="n">pysmttypes</span><span class="o">.</span><span class="n">pysmt_model2bv_model</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solution_var2ct</span> <span class="o">=</span> <span class="n">solution_var2ct</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_get_needed_vars</span><span class="p">(</span><span class="n">my_ch_model</span><span class="p">):</span>
            <span class="n">var_needed</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">input_prop</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">ssa</span><span class="o">.</span><span class="n">_input_vars_not_used</span><span class="p">]</span>
            <span class="c1"># # ks_ch_model has no external vars and enc_ch_model gets those from ks_ch_model.output</span>
            <span class="c1"># for ext_var, prop in my_ch_model.external_var2prop.items():</span>
            <span class="c1">#     if not isinstance(prop.val, core.Constant):</span>
            <span class="c1">#         var_needed.append(ext_var)</span>
            <span class="k">for</span> <span class="n">outprop</span><span class="p">,</span> <span class="n">op_model</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">assign_outprop2op_model</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># if op_model.max_weight() != 0:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">ModelIdentity</span><span class="p">):</span>
                    <span class="n">var_needed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outprop</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">var_needed</span>

        <span class="k">def</span> <span class="nf">get_needed_vars</span><span class="p">(</span><span class="n">my_cipher_ch_model</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_get_needed_vars</span><span class="p">(</span><span class="n">my_cipher_ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="p">)</span> <span class="o">+</span> <span class="n">_get_needed_vars</span><span class="p">(</span><span class="n">my_cipher_ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="p">)</span>

        <span class="n">missing_signature_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">get_needed_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solution_var2ct</span><span class="p">:</span>
                <span class="n">missing_signature_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">solution_var2ct</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">missing_signature_vars</span><span class="p">:</span>
            <span class="n">smart_print</span> <span class="o">=</span> <span class="n">_get_smart_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="s1">&#39;satisfiable&#39;</span> <span class="k">if</span> <span class="n">is_sat</span> <span class="k">else</span> <span class="s1">&#39;unsatisfiable&#39;</span><span class="si">}</span><span class="s2"> assignment &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;of SMT problem for all values of </span><span class="si">{</span><span class="n">missing_signature_vars</span><span class="si">}</span><span class="s2">; &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;setting </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">missing_signature_vars</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;to 0 in yielded characteristic&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">))</span> <span class="o">!=</span> <span class="n">target_weight</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SMT ch. weight = </span><span class="si">{</span><span class="n">solution_var2ct</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;!= </span><span class="si">{</span><span class="n">target_weight</span><span class="si">}</span><span class="s2"> = target_weight&quot;</span><span class="p">)</span>

        <span class="n">CipherCharacteristic_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_get_CipherCharacteristic_cls</span><span class="p">()</span>

        <span class="n">init_props</span> <span class="o">=</span> <span class="n">CipherCharacteristic_cls</span><span class="o">.</span><span class="n">get_properties_for_initialization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">solution_var2ct</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_props</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
        <span class="n">ks_input_prop</span><span class="p">,</span> <span class="n">ks_output_prop</span><span class="p">,</span> <span class="n">ks_assign_outprop_list</span> <span class="o">=</span> <span class="n">init_props</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">enc_input_prop</span><span class="p">,</span> <span class="n">enc_output_prop</span><span class="p">,</span> <span class="n">enc_assign_outprop_list</span> <span class="o">=</span> <span class="n">init_props</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>

        <span class="c1"># # debugging</span>
        <span class="c1"># print(&quot;\n_pysmt_model2ch&quot;)</span>
        <span class="c1"># print(&quot;ch model:&quot;, self.ch_model)</span>
        <span class="c1"># print(&quot;ch model ks ssa :&quot;, self.ch_model.ks_ch_model.ssa)</span>
        <span class="c1"># print(&quot;ch model enc ssa :&quot;, self.ch_model.enc_ch_model.ssa)</span>
        <span class="c1"># print(&quot;solution_var2ct:&quot;, solution_var2ct)</span>
        <span class="c1"># print(&quot;vars needed:&quot;, get_needed_vars(self.ch_model))</span>
        <span class="c1"># print(&quot;missing_signature_vars:&quot;, missing_signature_vars), &quot;\n&quot;)</span>
        <span class="c1">#</span>

        <span class="c1"># avoid *_props=*_props (super might not abstract)</span>
        <span class="n">last_ch_found</span> <span class="o">=</span> <span class="n">CipherCharacteristic_cls</span><span class="p">(</span>
            <span class="n">ks_input_prop</span><span class="p">,</span>
            <span class="n">ks_output_prop</span><span class="p">,</span>
            <span class="n">ks_assign_outprop_list</span><span class="p">,</span>
            <span class="n">enc_input_prop</span><span class="p">,</span>
            <span class="n">enc_output_prop</span><span class="p">,</span>
            <span class="n">enc_assign_outprop_list</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span>
            <span class="c1"># ks_free_props,</span>
            <span class="c1"># enc_free_props,</span>
            <span class="n">ks_empirical_ch_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ks_empirical_data_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">enc_empirical_ch_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">enc_empirical_data_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ks_is_valid</span><span class="o">=</span><span class="n">is_sat</span><span class="p">,</span>
            <span class="n">enc_is_valid</span><span class="o">=</span><span class="n">is_sat</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last_ch_found</span><span class="p">,</span> <span class="n">CipherCharacteristic_cls</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">assert</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ProbabilityOne</span>
                   <span class="ow">and</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ProbabilityOne</span>
                   <span class="ow">and</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">aux_finder</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="p">]):</span>
            <span class="n">aux_prefix</span> <span class="o">=</span> <span class="s2">&quot;ks&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;enc&quot;</span>
            <span class="n">aux_ch</span> <span class="o">=</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">ks_characteristic</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">enc_characteristic</span>
            <span class="k">if</span> <span class="n">aux_finder</span><span class="o">.</span><span class="n">_exclude_zero_input_prop</span><span class="p">:</span>
                <span class="n">compact_input</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">Concat</span><span class="p">,</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">aux_ch</span><span class="o">.</span><span class="n">input_prop</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">compact_input</span> <span class="o">==</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">compact_input</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;exclude_</span><span class="si">{</span><span class="n">aux_prefix</span><span class="si">}</span><span class="s2">_zero_input_prop is True but </span><span class="si">{</span><span class="n">aux_prefix</span><span class="si">}</span><span class="s2">-&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;characteristic input is </span><span class="si">{</span><span class="n">aux_ch</span><span class="o">.</span><span class="n">input_prop</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">last_ch_found_v2c</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">var_prop</span><span class="p">,</span> <span class="n">ct_prop</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="n">last_ch_found</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
                <span class="n">last_ch_found</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">solution_var2ct</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">ct_prop</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ct_prop</span><span class="o">.</span><span class="n">val</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SMT solution contains </span><span class="si">{</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">solution_var2ct</span><span class="p">[</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot; but characteristic contains </span><span class="si">{</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">ct_prop</span><span class="o">.</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">last_ch_found_v2c</span><span class="p">[</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct_prop</span><span class="o">.</span><span class="n">val</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_prop2ct_prop</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var_prop</span><span class="p">,</span> <span class="n">ct_prop</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_prop2ct_prop</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ch_ct_prop</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">ct_prop</span><span class="p">)(</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">last_ch_found_v2c</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ct_prop</span> <span class="o">!=</span> <span class="n">ch_ct_prop</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">var_prop</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ct_prop</span><span class="si">}</span><span class="s2">) was added in var_prop2ct_prop&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;but </span><span class="si">{</span><span class="n">var_prop</span><span class="si">}</span><span class="s2"> has value </span><span class="si">{</span><span class="n">ch_ct_prop</span><span class="si">}</span><span class="s2"> in the characteristic&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Full solution: </span><span class="si">{</span><span class="n">last_ch_found_v2c</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
            <span class="c1"># solution_var2ct include weight variables</span>
            <span class="n">last_ch_found_v2c</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">last_ch_found_v2c</span><span class="p">,</span> <span class="o">**</span><span class="n">solution_var2ct</span><span class="p">}</span>
            <span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">last_ch_found_v2c</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">]</span>
            <span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvAnd</span><span class="p">,</span> <span class="n">chmodel_asserts</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">is_sat</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chmodel_asserts</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">))</span> <span class="ow">and</span> <span class="n">chmodel_asserts</span> <span class="o">!=</span> <span class="n">is_sat</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">is_sat</span><span class="si">}</span><span class="s2"> != chmodel_asserts = (</span><span class="si">{</span><span class="n">chmodel_asserts</span><span class="si">}</span><span class="s2">) for the characteristic found&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">SMT solution = </span><span class="si">{</span><span class="n">solution_var2ct</span><span class="si">}</span><span class="s2">)&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Full solution: </span><span class="si">{</span><span class="n">last_ch_found_v2c</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">target_weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
                <span class="n">last_ch_found</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">_check_bv_weights</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">),</span>
                    <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">_awvs</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
                <span class="n">last_ch_found</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">_check_bv_weights</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">),</span>
                    <span class="p">[</span><span class="n">w</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">_awvs</span><span class="p">])</span>

            <span class="n">smt_weight</span> <span class="o">=</span> <span class="n">target_weight</span>
            <span class="n">ch_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ch_weight</span><span class="p">(</span><span class="n">last_ch_found</span><span class="p">,</span> <span class="n">add_aux_probability</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">abs_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">smt_weight</span> <span class="o">-</span> <span class="n">ch_weight</span><span class="p">)</span><span class="o">.</span><span class="n">copy_abs</span><span class="p">()</span>

            <span class="c1"># extra error due to truncate=True</span>
            <span class="n">ks_extra_error</span><span class="p">,</span> <span class="n">enc_extra_error</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
                <span class="n">ks_fb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">num_frac_bits</span><span class="p">()</span>
                <span class="n">ks_extra_error</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">ks_fb</span><span class="p">))</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ks_fb</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ks_extra_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
                <span class="n">enc_fb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">num_frac_bits</span><span class="p">()</span>
                <span class="n">enc_extra_error</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">enc_fb</span><span class="p">))</span>
                <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">enc_fb</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">enc_extra_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># # the following extra_error does not consider individual ks and enc error</span>
            <span class="c1"># extra_error = max(abs(ch_weight - math.ceil(ch_weight)), abs(ch_weight - math.floor(ch_weight)))</span>

            <span class="n">max_abs_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error</span> <span class="o">+</span> <span class="n">ks_extra_error</span> <span class="o">+</span> <span class="n">enc_extra_error</span>
            <span class="n">max_abs_error</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="n">max_abs_error</span><span class="p">)</span><span class="o">.</span><span class="n">quantize</span><span class="p">(</span>
                <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1.&quot;</span> <span class="o">+</span> <span class="s2">&quot;0&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">getcontext</span><span class="p">()</span><span class="o">.</span><span class="n">prec</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)),</span> <span class="n">rounding</span><span class="o">=</span><span class="n">decimal</span><span class="o">.</span><span class="n">ROUND_UP</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">abs_error</span> <span class="o">&gt;</span> <span class="n">max_abs_error</span><span class="p">:</span>
                <span class="n">aux_ws</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">kfwp</span><span class="p">,</span> <span class="n">ecwp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">weight_prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">weight_prefix</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">solution_var2ct</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">kfwp</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">kfwp</span><span class="p">))</span> <span class="ow">or</span> \
                            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">ecwp</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">ecwp</span><span class="p">)):</span>
                        <span class="n">aux_ws</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;absolute error between integer weight </span><span class="si">{</span><span class="n">smt_weight</span><span class="si">}</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;(found by the SMT solver from </span><span class="si">{</span><span class="n">aux_ws</span><span class="si">}</span><span class="s2">) and decimal weight </span><span class="si">{</span><span class="n">ch_weight</span><span class="si">}</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;(recomputed in CipherCharacteristic) is </span><span class="si">{</span><span class="n">abs_error</span><span class="si">}</span><span class="s2">, &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;which is greater than maximum absolute error given by &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;ch_model-error=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_error</span><span class="si">}</span><span class="s2"> + extra_error=</span><span class="si">{</span><span class="n">ks_extra_error</span><span class="o">+</span><span class="n">enc_extra_error</span><span class="si">}</span><span class="s2">&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">last_ch_found</span>

<div class="viewcode-block" id="CipherChFinder.find_next_ch"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.CipherChFinder.find_next_ch">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_ch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that yields the characteristics found in the SMT-based search.</span>

<span class="sd">        See also `ChFinder.find_next_ch`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.algebraic.value import BitValue</span>
<span class="sd">            &gt;&gt;&gt; from cascada.algebraic.chmodel import CipherChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.smt.chsearch import CipherChFinder, ChModelAssertType</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">            &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = CipherChModel(Speck32, BitValue)</span>
<span class="sd">            &gt;&gt;&gt; input_output_vals = ch_model.enc_ch_model.input_val + ch_model.enc_ch_model.output_val</span>
<span class="sd">            &gt;&gt;&gt; # setting each input and output plaintext word to 0x0001</span>
<span class="sd">            &gt;&gt;&gt; v2c = {v: core.Constant(1, 16) for v in input_output_vals}</span>
<span class="sd">            &gt;&gt;&gt; assert_type = ChModelAssertType.Validity</span>
<span class="sd">            &gt;&gt;&gt; ch_finder = CipherChFinder(ch_model, assert_type, assert_type, &quot;btor&quot;,</span>
<span class="sd">            ...                            var_prop2ct_prop=v2c, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; found_enc_ch = next(ch_finder.find_next_ch()).enc_characteristic</span>
<span class="sd">            &gt;&gt;&gt; round_sep = found_enc_ch.get_round_separators()</span>
<span class="sd">            &gt;&gt;&gt; for round_enc_ch in found_enc_ch.split(round_sep): print(round_enc_ch)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            Characteristic(ch_weight=0, assignment_weights=[0, 0, 0],</span>
<span class="sd">                input_val=[0x0001, 0x0001], output_val=[0x0004, 0x0000], external_vals=[0x0205],</span>
<span class="sd">                assign_outval_list=[0x0201, 0x0004, 0x0000])</span>
<span class="sd">            Characteristic(ch_weight=0, assignment_weights=[0, 0, 0],</span>
<span class="sd">                input_val=[0x0004, 0x0000], output_val=[0x0001, 0x0001], external_vals=[0x0801],</span>
<span class="sd">                assign_outval_list=[0x0800, 0x0001, 0x0001])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">find_next_ch</span><span class="p">()</span></div>

<div class="viewcode-block" id="CipherChFinder.fix_key_schedule_ch_weight"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.CipherChFinder.fix_key_schedule_ch_weight">[docs]</a>    <span class="k">def</span> <span class="nf">fix_key_schedule_ch_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integer_weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the constraint that fixes the key-schedule weight to the given integer weight.&quot;&quot;&quot;</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">integer_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span></div>

<div class="viewcode-block" id="CipherChFinder.fix_encryption_ch_weight"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.CipherChFinder.fix_encryption_ch_weight">[docs]</a>    <span class="k">def</span> <span class="nf">fix_encryption_ch_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integer_weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the constraint that fixes the encryption weight to the given integer weight.&quot;&quot;&quot;</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">integer_weight</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span><span class="p">,</span> <span class="n">weight</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_compute_empirical_ch_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_found</span><span class="p">,</span> <span class="n">empirical_weight_options</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">empirical_weight_options</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ch_found</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">compute_empirical_ch_weight</span><span class="p">(</span><span class="o">**</span><span class="n">empirical_weight_options</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">empirical_weight_options</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ch_found</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">compute_empirical_ch_weight</span><span class="p">(</span><span class="o">**</span><span class="n">empirical_weight_options</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_get_empirical_ch_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_found</span><span class="p">):</span>
        <span class="n">kew</span> <span class="o">=</span> <span class="n">ch_found</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">empirical_ch_weight</span>
        <span class="n">eew</span> <span class="o">=</span> <span class="n">ch_found</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">empirical_ch_weight</span>
        <span class="k">assert</span> <span class="ow">not</span><span class="p">(</span><span class="n">kew</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">eew</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kew</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kew</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">eew</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eew</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="ow">in</span> <span class="p">[</span><span class="n">kew</span><span class="p">,</span> <span class="n">eew</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">kew</span> <span class="o">+</span> <span class="n">eew</span>

    <span class="k">def</span> <span class="nf">_get_ch_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_found</span><span class="p">,</span> <span class="n">add_aux_probability</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">kat</span><span class="p">,</span> <span class="n">eat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">assert_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span><span class="o">.</span><span class="n">assert_type</span>
        <span class="n">CMAT</span> <span class="o">=</span> <span class="n">ChModelAssertType</span>
        <span class="k">if</span> <span class="n">kat</span> <span class="o">==</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span> <span class="ow">and</span> <span class="n">eat</span> <span class="o">==</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ch_found</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">+</span> <span class="n">ch_found</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">ch_weight</span>
        <span class="k">elif</span> <span class="n">kat</span> <span class="ow">in</span> <span class="p">[</span><span class="n">CMAT</span><span class="o">.</span><span class="n">Validity</span><span class="p">,</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">]</span> <span class="ow">and</span> <span class="n">eat</span> <span class="o">==</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span><span class="p">:</span>
            <span class="c1"># if ks-weight == 0, aux_probability = 1 - 1 = 0, and returned weight = enc-weight</span>
            <span class="c1"># if ks-weight &gt; 0, aux_probability = &gt; 0, and returned weight = enc-weight + epsilon</span>
            <span class="k">if</span> <span class="n">add_aux_probability</span><span class="p">:</span>
                <span class="n">aux_probability</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">ch_found</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">ch_weight</span><span class="p">))</span>
                <span class="k">assert</span> <span class="n">aux_probability</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">aux_probability</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux_probability</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">ch_found</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">+</span> <span class="n">aux_probability</span>
        <span class="k">elif</span> <span class="n">kat</span> <span class="o">==</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ValidityAndWeight</span> <span class="ow">and</span> <span class="n">eat</span> <span class="ow">in</span> <span class="p">[</span><span class="n">CMAT</span><span class="o">.</span><span class="n">Validity</span><span class="p">,</span> <span class="n">CMAT</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">add_aux_probability</span><span class="p">:</span>
                <span class="n">aux_probability</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">ch_found</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">ch_weight</span><span class="p">))</span>
                <span class="k">assert</span> <span class="n">aux_probability</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">aux_probability</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux_probability</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">ch_found</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">+</span> <span class="n">aux_probability</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid assert types: </span><span class="si">{</span><span class="n">kat</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">eat</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_new_final_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_found</span><span class="p">,</span> <span class="n">prev_final_weight</span><span class="p">):</span>
        <span class="n">new_ch_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_ch_weight</span><span class="p">(</span><span class="n">ch_found</span><span class="p">,</span> <span class="n">add_aux_probability</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_final_weight</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">new_ch_weight</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">prev_final_weight</span><span class="p">,</span> <span class="n">new_final_weight</span><span class="p">)</span>

<div class="viewcode-block" id="CipherChFinder.find_next_ch_increasing_weight"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.CipherChFinder.find_next_ch_increasing_weight">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_ch_increasing_weight</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">initial_weight</span><span class="p">,</span> <span class="n">final_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ks_empirical_weight_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">enc_empirical_weight_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">stop_after_optimal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">yield_weight</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that yields the characteristics found in the SMT-based search.</span>

<span class="sd">        This method searches for optimal characteristics (with optimal probability)</span>
<span class="sd">        using SMT solvers (see `ChFinder`).</span>

<span class="sd">        In particular, the search creates decision problems</span>
<span class="sd">        of whether there exists a characteristic with probability</span>
<span class="sd">        :math:`p \in I_w`, where a characteristic has probability</span>
<span class="sd">        :math:`p \in I_w` if and only if its integer weight</span>
<span class="sd">        (the integer part of the weight) is equal to :math:`w`.</span>

<span class="sd">        The main difference between `ChFinder.find_next_ch_increasing_weight`</span>
<span class="sd">        and this method is that this method defined the weight of a</span>
<span class="sd">        ``CipherCharacteristic`` depending on the type of the assertions.</span>

<span class="sd">        - If both ``ks_assert_type`` and ``enc_assert_type`` are</span>
<span class="sd">          `ValidityAndWeight`, then the weight of a</span>
<span class="sd">          ``CipherCharacteristic``</span>
<span class="sd">          is defined as the sum of the weight of the key-schedule</span>
<span class="sd">          characteristic and the weight of the encryption characteristic.</span>
<span class="sd">        - If only ``ks_assert_type`` is `ValidityAndWeight`,</span>
<span class="sd">          then the weight is defined as the weight of the key-schedule</span>
<span class="sd">          characteristic.</span>
<span class="sd">        - If only ``enc_assert_type`` is `ValidityAndWeight`,</span>
<span class="sd">          then the weight is defined as the weight of the encryption</span>
<span class="sd">          characteristic.</span>

<span class="sd">        .. note::</span>

<span class="sd">            For example, if only ``enc_assert_type`` is `ValidityAndWeight`,</span>
<span class="sd">            the search starts finding characteristics where</span>
<span class="sd">            the integer weight of the encryption characteristic is</span>
<span class="sd">            equal to the initial weight.</span>

<span class="sd">        The argument ``ks_empirical_weight_options``</span>
<span class="sd">        (resp. ``enc_empirical_weight_options``) specifies the options</span>
<span class="sd">        for the computation of the empirical weight over the key-schedule</span>
<span class="sd">        (resp. encryption) characteristic. If only one of them is given</span>
<span class="sd">        (and the other one is ``None``), then only one of the empirical</span>
<span class="sd">        weights is computed and used to determine whether to yield</span>
<span class="sd">        the characteristic found.</span>

<span class="sd">        See also `ChFinder.find_next_ch_increasing_weight`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.chmodel import CipherChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.smt.chsearch import CipherChFinder, ChModelAssertType</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">            &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = CipherChModel(Speck32, RXDiff)</span>
<span class="sd">            &gt;&gt;&gt; assert_type = ChModelAssertType.ValidityAndWeight</span>
<span class="sd">            &gt;&gt;&gt; ch_finder = CipherChFinder(ch_model, assert_type, assert_type, &quot;btor&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; iterator = ch_finder.find_next_ch_increasing_weight(1)</span>
<span class="sd">            &gt;&gt;&gt; print(next(iterator).srepr())</span>
<span class="sd">            Ch(ks_ch=Ch(w=1.415, id=0000 0000, od=0000 0000), enc_ch=Ch(w=2.830, id=0000 0000, od=0000 0000))</span>
<span class="sd">            &gt;&gt;&gt; print(next(iterator).srepr())</span>
<span class="sd">            Ch(ks_ch=Ch(w=1.415, id=0000 8000, od=8000 8002), enc_ch=Ch(w=2.830, id=0040 0000, od=8003 8003))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ks_empirical_weight_options</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">enc_empirical_weight_options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">empirical_weight_options</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">empirical_weight_options</span> <span class="o">=</span> <span class="p">[</span><span class="n">ks_empirical_weight_options</span><span class="p">,</span> <span class="n">enc_empirical_weight_options</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">find_next_ch_increasing_weight</span>\
            <span class="p">(</span><span class="n">initial_weight</span><span class="p">,</span> <span class="n">final_weight</span><span class="o">=</span><span class="n">final_weight</span><span class="p">,</span>
             <span class="n">empirical_weight_options</span><span class="o">=</span><span class="n">empirical_weight_options</span><span class="p">,</span>
             <span class="n">stop_after_optimal</span><span class="o">=</span><span class="n">stop_after_optimal</span><span class="p">,</span> <span class="n">yield_weight</span><span class="o">=</span><span class="n">yield_weight</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="round_based_ch_search"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.round_based_ch_search">[docs]</a><span class="k">def</span> <span class="nf">round_based_ch_search</span><span class="p">(</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">initial_num_rounds</span><span class="p">,</span> <span class="n">final_num_rounds</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="n">assert_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span>
        <span class="n">extra_chmodel_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># op_model_class2options,</span>
        <span class="n">extra_chfinder_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># exclude, ic, v2c, pm, fn, env, weight_prefix, solver_seed</span>
        <span class="n">extra_findnextchweight_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># initial_weight, final_weight, ewo</span>
        <span class="o">**</span><span class="n">kwargs</span>  <span class="c1"># find_cipher_ch</span>
        <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search for characteristics of round-based functions over multiple number of rounds.</span>

<span class="sd">    This function searches for characteristics of ``func`` (a `RoundBasedFunction`)</span>
<span class="sd">    by modelling the search as a sequence of SMT problems (using `ChFinder`),</span>
<span class="sd">    but the search is perfomed iteratively over the number of rounds of ``func``.</span>
<span class="sd">    That is, first characteristics covering ``initial_num_rounds`` rounds</span>
<span class="sd">    are searched, then ``initial_num_rounds + 1``, until ``final_num_rounds``.</span>

<span class="sd">    This function proceed as follows:</span>

<span class="sd">    1. Set the number of rounds of ``func`` to ``initial_num_rounds``.</span>
<span class="sd">    2. Create a `abstractproperty.chmodel.ChModel`</span>
<span class="sd">       (resp. `abstractproperty.chmodel.EncryptionChModel`) object using as</span>
<span class="sd">       arguments ``func``, ``prop_type`` and ``extra_chmodel_args``.</span>
<span class="sd">    3. Create a `ChFinder` object with arguments the characteristic model</span>
<span class="sd">       created in step 2, ``assert_type``, ``solver_name`` and</span>
<span class="sd">       ``extra_chfinder_args``.</span>
<span class="sd">    4. Loop over the generator `ChFinder.find_next_ch` or</span>
<span class="sd">       `ChFinder.find_next_ch_increasing_weight` (depending on</span>
<span class="sd">       ``assert_type``), and yield all characteristics from the</span>
<span class="sd">       generator (together with the current number of rounds).</span>
<span class="sd">    5. After the generator has been exhausted, the search is finished if</span>
<span class="sd">       the current number of rounds is ``final_num_rounds``.</span>
<span class="sd">       Otherwise, increase the number of rounds by one, set ``func``</span>
<span class="sd">       to this number of rounds, and go to step 2.</span>

<span class="sd">    In particular, this function is a Python `generator` function</span>
<span class="sd">    (see `ChFinder`), returning an `iterator` that yields</span>
<span class="sd">    tuples containing the current number of rounds and the last</span>
<span class="sd">    characteristic (an `abstractproperty.characteristic.Characteristic`</span>
<span class="sd">    if ``func`` is a `RoundBasedFunction` object, or</span>
<span class="sd">    a `abstractproperty.characteristic.EncryptionCharacteristic` if</span>
<span class="sd">    ``func`` is a `RoundBasedFunction`-encryption function</span>
<span class="sd">    of a `Cipher`) found in the search.</span>

<span class="sd">    The argument ``prop_type`` is a particular `Property` such as `XorDiff`</span>
<span class="sd">    or `LinearMask`. For ``assert_type`` and ``solver_name``, see `ChFinder`.</span>
<span class="sd">    The optional arguments ``extra_chmodel_args``, ``extra_chfinder_args``</span>
<span class="sd">    and ``extra_findnextchweight_args`` can be given as dictionaries</span>
<span class="sd">    (in the form of ``**kwargs``) containing additional arguments</span>
<span class="sd">    for ``ChModel/EncryptionChModel``, `ChFinder` and</span>
<span class="sd">    `ChFinder.find_next_ch_increasing_weight` calls respectively.</span>

<span class="sd">    It is possible to abort the current search for the current number of rounds</span>
<span class="sd">    and start the search with one more round by passing_ the</span>
<span class="sd">    value `INCREMENT_NUM_ROUNDS`</span>
<span class="sd">    to the generator iterator with `generator.send`.</span>

<span class="sd">    .. _passing: https://docs.python.org/3/howto/functional.html?highlight=generator#passing-values-into-a-generator</span>

<span class="sd">    .. note::</span>

<span class="sd">        In other words, step 4 in the previous description can be early</span>
<span class="sd">        aborted as follows</span>

<span class="sd">        .. code:: python</span>

<span class="sd">            [...]</span>
<span class="sd">            iterator = round_based_ch_search(...)</span>
<span class="sd">            n1, ch_found = next(iterator)</span>
<span class="sd">            iterator.send(INCREMENT_NUM_ROUNDS)</span>
<span class="sd">            n2, ch_found = next(iterator)  # n2 &gt; n1</span>
<span class="sd">            [...]</span>

<span class="sd">        Although `generator.send` yields a new value of the iteration,</span>
<span class="sd">        this function does not yield anything meaningful in the ``send`` calls.</span>

<span class="sd">    The function `round_based_ch_search` is mostly meant to be used with</span>
<span class="sd">    `ChModelAssertType.ValidityAndWeight`, as the minimum weight obtain</span>
<span class="sd">    in one round is used as the initial weight for the next round.</span>
<span class="sd">    In other words, if all the characteristics covering :math:`r` number</span>
<span class="sd">    of rounds were found with SMT problems for integer weights</span>
<span class="sd">    (see `ChFinder.find_next_ch_increasing_weight`)</span>
<span class="sd">    larger than :math:`w`, then :math:`w` is set as the initial weight</span>
<span class="sd">    for the search for characteristics covering :math:`r+1` rounds.</span>

<span class="sd">    .. note::</span>

<span class="sd">        All SMT problems modelling a characteristic covering</span>
<span class="sd">        :math:`r+1` rounds for integer weights less or equal</span>
<span class="sd">        than :math:`r - 1` are unsatisfiable due to our definition</span>
<span class="sd">        of characteristic weight (see</span>
<span class="sd">        `abstractproperty.characteristic.Characteristic` and</span>
<span class="sd">        `differential.characteristic.Characteristic` or</span>
<span class="sd">        `linear.characteristic.Characteristic` for some examples)</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; # example of searching for XorDiff Characteristic over a BvFunction</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.chsearch import ChModelAssertType, round_based_ch_search, INCREMENT_NUM_ROUNDS</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32_ks = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">        &gt;&gt;&gt; assert_type = ChModelAssertType.ValidityAndWeight</span>
<span class="sd">        &gt;&gt;&gt; iterator = round_based_ch_search(Speck32_ks, 2, 5, XorDiff, assert_type, &quot;btor&quot;,</span>
<span class="sd">        ...     extra_chfinder_args={&quot;exclude_zero_input_prop&quot;: True, &quot;solver_seed&quot;:0},</span>
<span class="sd">        ...     extra_findnextchweight_args={&quot;initial_weight&quot;: 0})</span>
<span class="sd">        &gt;&gt;&gt; for (num_rounds, ch) in iterator:</span>
<span class="sd">        ...     print(num_rounds, &quot;:&quot;, ch.srepr())</span>
<span class="sd">        2 : Ch(w=0, id=0040 0000 0000, od=0000 0000 8000)</span>
<span class="sd">        3 : Ch(w=0, id=0040 0000 0000 0000, od=0000 0000 0000 8000)</span>
<span class="sd">        4 : Ch(w=0, id=0040 0000 0000 0000, od=0000 0000 0000 8000 8002)</span>
<span class="sd">        5 : Ch(w=1, id=0040 0000 0000 0000, od=0000 0000 0000 8000 8002 8008)</span>
<span class="sd">        &gt;&gt;&gt; # example of searching for LinearMask EncryptionCharacteristic over a Cipher</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">        &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">        &gt;&gt;&gt; assert_type = ChModelAssertType.ProbabilityOne</span>
<span class="sd">        &gt;&gt;&gt; iterator = round_based_ch_search(Speck32, 2, 3, LinearMask, assert_type, &quot;btor&quot;,</span>
<span class="sd">        ...     extra_chfinder_args={&quot;solver_seed&quot;:0})</span>
<span class="sd">        &gt;&gt;&gt; num_rounds, ch = next(iterator)</span>
<span class="sd">        &gt;&gt;&gt; print(num_rounds, &quot;:&quot;, ch.srepr())</span>
<span class="sd">        2 : Ch(w=0, id=0000 0000, od=0000 0000)</span>
<span class="sd">        &gt;&gt;&gt; num_rounds, ch = next(iterator)</span>
<span class="sd">        &gt;&gt;&gt; print(num_rounds, &quot;:&quot;, ch.srepr())</span>
<span class="sd">        2 : Ch(w=0, id=0080 4021, od=0201 0200)</span>
<span class="sd">        &gt;&gt;&gt; iterator.send(INCREMENT_NUM_ROUNDS)  # stop current num_rounds and increment by 1</span>
<span class="sd">        &gt;&gt;&gt; num_rounds, ch = next(iterator)</span>
<span class="sd">        &gt;&gt;&gt; print(num_rounds, &quot;:&quot;, ch.srepr())</span>
<span class="sd">        3 : Ch(w=0, id=0000 0000, od=0000 0000)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">cascada_ssa</span><span class="o">.</span><span class="n">RoundBasedFunction</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">blockcipher</span><span class="o">.</span><span class="n">Cipher</span><span class="p">)</span> <span class="ow">and</span>
             <span class="nb">issubclass</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">encryption</span><span class="p">,</span> <span class="n">cascada_ssa</span><span class="o">.</span><span class="n">RoundBasedFunction</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2"> is not a RoundBasedFunction or a Cipher&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">initial_num_rounds</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">final_num_rounds</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">initial_num_rounds</span> <span class="o">&lt;=</span> <span class="n">final_num_rounds</span>

    <span class="k">if</span> <span class="n">extra_chmodel_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extra_chmodel_args</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extra_chmodel_args</span> <span class="o">=</span> <span class="n">extra_chmodel_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">extra_chfinder_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extra_chfinder_args</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extra_chfinder_args</span> <span class="o">=</span> <span class="n">extra_chfinder_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">extra_findnextchweight_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extra_findnextchweight_args</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extra_findnextchweight_args</span> <span class="o">=</span> <span class="n">extra_findnextchweight_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">printing_mode</span> <span class="o">=</span> <span class="n">extra_chfinder_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;printing_mode&quot;</span><span class="p">,</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">extra_chfinder_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;filename&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">smart_print</span> <span class="o">=</span> <span class="n">_get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">find_cipher_ch</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;find_cipher_ch&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid arguments: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">find_cipher_ch</span><span class="p">:</span>
        <span class="n">list_assert_type</span> <span class="o">=</span> <span class="n">assert_type</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_assert_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">assert_type</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span> <span class="ow">in</span> <span class="n">list_assert_type</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;yield_weight&quot;</span> <span class="ow">in</span> <span class="n">extra_findnextchweight_args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;extra_findnextchweight_args cannot contain yield_weight&quot;</span><span class="p">)</span>
        <span class="n">extra_findnextchweight_args</span><span class="p">[</span><span class="s2">&quot;yield_weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s2">&quot;initial_weight&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">extra_findnextchweight_args</span><span class="p">:</span>
            <span class="n">extra_findnextchweight_args</span><span class="p">[</span><span class="s2">&quot;initial_weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;setting extra_findnextchweight_args[&#39;initial_weight&#39;] to 0&quot;</span><span class="p">)</span>
        <span class="c1"># warning already raised in find_next_ch_increasing_weight if exclude zero input + non-zero weight</span>

    <span class="kn">from</span> <span class="nn">cascada.differential.difference</span> <span class="kn">import</span> <span class="n">XorDiff</span><span class="p">,</span> <span class="n">RXDiff</span>
    <span class="kn">from</span> <span class="nn">cascada.linear.mask</span> <span class="kn">import</span> <span class="n">LinearMask</span>
    <span class="kn">from</span> <span class="nn">cascada.algebraic.value</span> <span class="kn">import</span> <span class="n">BitValue</span><span class="p">,</span> <span class="n">WordValue</span>

    <span class="k">if</span> <span class="n">prop_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">XorDiff</span><span class="p">,</span> <span class="n">RXDiff</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">cascada.differential.chmodel</span> <span class="kn">import</span> <span class="n">ChModel</span><span class="p">,</span> <span class="n">EncryptionChModel</span><span class="p">,</span> <span class="n">CipherChModel</span>
    <span class="k">elif</span> <span class="n">prop_type</span> <span class="o">==</span> <span class="n">LinearMask</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">find_cipher_ch</span> <span class="ow">is</span> <span class="kc">False</span>
        <span class="kn">from</span> <span class="nn">cascada.linear.chmodel</span> <span class="kn">import</span> <span class="n">ChModel</span><span class="p">,</span> <span class="n">EncryptionChModel</span>
    <span class="k">elif</span> <span class="n">prop_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">BitValue</span><span class="p">,</span> <span class="n">WordValue</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">cascada.algebraic.chmodel</span> <span class="kn">import</span> <span class="n">ChModel</span><span class="p">,</span> <span class="n">EncryptionChModel</span><span class="p">,</span> <span class="n">CipherChModel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;prop_type not in </span><span class="si">{</span><span class="p">[</span><span class="n">XorDiff</span><span class="p">,</span> <span class="n">RXDiff</span><span class="p">,</span> <span class="n">LinearMask</span><span class="p">,</span> <span class="n">BitValue</span><span class="p">,</span> <span class="n">WordValue</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">num_rounds</span> <span class="o">=</span> <span class="n">initial_num_rounds</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">func</span><span class="o">.</span><span class="n">set_num_rounds</span><span class="p">(</span><span class="n">num_rounds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_rounds</span> <span class="o">!=</span> <span class="n">initial_num_rounds</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current number of rounds: </span><span class="si">{</span><span class="n">num_rounds</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">blockcipher</span><span class="o">.</span><span class="n">Cipher</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">find_cipher_ch</span><span class="p">:</span>
                <span class="n">ch_model</span> <span class="o">=</span> <span class="n">CipherChModel</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_chmodel_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ch_model</span> <span class="o">=</span> <span class="n">EncryptionChModel</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_chmodel_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="n">EncryptionChModel</span><span class="o">.</span><span class="n">_prefix</span>
            <span class="n">input_prop_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">p</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">input_widths</span><span class="p">))]</span>
            <span class="n">ch_model</span> <span class="o">=</span> <span class="n">ChModel</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="n">input_prop_names</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_chmodel_args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Characteristic model: </span><span class="si">{</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">find_cipher_ch</span><span class="p">:</span>
            <span class="n">ch_finder</span> <span class="o">=</span> <span class="n">CipherChFinder</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">assert_type</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">assert_type</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">solver_name</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_chfinder_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ch_finder</span> <span class="o">=</span> <span class="n">ChFinder</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">assert_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_chfinder_args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;Size of the base SMT problem:&quot;</span><span class="p">,</span> <span class="n">ch_finder</span><span class="o">.</span><span class="n">formula_size</span><span class="p">())</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Base SMT problem:</span><span class="se">\n</span><span class="si">{</span><span class="n">ch_finder</span><span class="o">.</span><span class="n">hrepr</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">found_ch</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ValidityAndWeight</span> <span class="ow">in</span> <span class="n">list_assert_type</span><span class="p">:</span>
            <span class="n">min_target_weight</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">target_weight</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">ch_finder</span><span class="o">.</span><span class="n">find_next_ch_increasing_weight</span><span class="p">(</span><span class="o">**</span><span class="n">extra_findnextchweight_args</span><span class="p">):</span>
                <span class="n">found_ch</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">min_target_weight</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">min_target_weight</span><span class="p">,</span> <span class="n">target_weight</span><span class="p">)</span>
                <span class="n">sent_value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="p">(</span><span class="n">num_rounds</span><span class="p">,</span> <span class="n">ch</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">sent_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sent_value</span> <span class="o">==</span> <span class="n">INCREMENT_NUM_ROUNDS</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="kc">None</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;value </span><span class="si">{</span><span class="n">sent_value</span><span class="si">}</span><span class="s2"> is sent to the generator &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;but only sending INCREMENT_NUM_ROUNDS&quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot; affects the generator&quot;</span><span class="p">)</span>
            <span class="n">extra_findnextchweight_args</span><span class="p">[</span><span class="s2">&quot;initial_weight&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_target_weight</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">ch_finder</span><span class="o">.</span><span class="n">find_next_ch</span><span class="p">():</span>
                <span class="n">found_ch</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">sent_value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="p">(</span><span class="n">num_rounds</span><span class="p">,</span> <span class="n">ch</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">sent_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sent_value</span> <span class="o">==</span> <span class="n">INCREMENT_NUM_ROUNDS</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="kc">None</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;value </span><span class="si">{</span><span class="n">sent_value</span><span class="si">}</span><span class="s2"> is sent to the generator &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;but only sending INCREMENT_NUM_ROUNDS&quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot; affects the generator&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_ch</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;No characteristic found&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">elif</span> <span class="n">num_rounds</span> <span class="o">==</span> <span class="n">final_num_rounds</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_rounds</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">num_rounds</span> <span class="o">&lt;=</span> <span class="n">final_num_rounds</span></div>


<div class="viewcode-block" id="round_based_cipher_ch_search"><a class="viewcode-back" href="../../../cascada.smt.chsearch.html#cascada.smt.chsearch.round_based_cipher_ch_search">[docs]</a><span class="k">def</span> <span class="nf">round_based_cipher_ch_search</span><span class="p">(</span>
        <span class="n">cipher</span><span class="p">,</span> <span class="n">initial_num_rounds</span><span class="p">,</span> <span class="n">final_num_rounds</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="n">ks_assert_type</span><span class="p">,</span> <span class="n">enc_assert_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span>
        <span class="n">extra_cipherchmodel_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_cipherchfinder_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extra_findnextchweight_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search for characteristics of iterated ciphers over multiple number of rounds.</span>

<span class="sd">    This function is similar to `round_based_cipher_ch_search` but searching for</span>
<span class="sd">    `abstractproperty.characteristic.CipherCharacteristic` instead of</span>
<span class="sd">    `abstractproperty.characteristic.Characteristic`.</span>

<span class="sd">    In particular, this function creates an `abstractproperty.chmodel.CipherChModel`</span>
<span class="sd">    and an `CipherChFinder` objects instead of an `abstractproperty.chmodel.ChModel`</span>
<span class="sd">    and an `ChFinder` objects.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.chsearch import ChModelAssertType, round_based_cipher_ch_search</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">        &gt;&gt;&gt; at = ChModelAssertType.ValidityAndWeight</span>
<span class="sd">        &gt;&gt;&gt; iterator = round_based_cipher_ch_search(Speck32, 2, 5, XorDiff, at, at, &quot;btor&quot;,</span>
<span class="sd">        ...     extra_cipherchfinder_args={&quot;ks_exclude_zero_input_prop&quot;: True, &quot;solver_seed&quot;: 0},</span>
<span class="sd">        ...     extra_findnextchweight_args={&quot;initial_weight&quot;: 0})</span>
<span class="sd">        &gt;&gt;&gt; for (num_rounds, ch) in iterator:</span>
<span class="sd">        ...     print(num_rounds, &quot;:&quot;, ch.srepr())  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        2 : Ch(ks_ch=Ch(w=0, id=0040 0000, od=0000 8000),</span>
<span class="sd">              enc_ch=Ch(w=0, id=0000 0000, od=8000 8000))</span>
<span class="sd">        3 : Ch(ks_ch=Ch(w=0, id=0040 0000 0000, od=0000 0000 8000),</span>
<span class="sd">              enc_ch=Ch(w=0, id=0000 0000, od=8000 8000))</span>
<span class="sd">        4 : Ch(ks_ch=Ch(w=0, id=0040 0000 0000 0000, od=0000 0000 0000 8000),</span>
<span class="sd">              enc_ch=Ch(w=0, id=0000 0000, od=8000 8000))</span>
<span class="sd">        5 : Ch(ks_ch=Ch(w=0, id=0040 0000 0000 0000, od=0000 0000 0000 8000 8002),</span>
<span class="sd">              enc_ch=Ch(w=1, id=0000 0000, od=0102 0100))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">round_based_ch_search</span><span class="p">(</span>
        <span class="n">cipher</span><span class="p">,</span> <span class="n">initial_num_rounds</span><span class="p">,</span> <span class="n">final_num_rounds</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="p">[</span><span class="n">ks_assert_type</span><span class="p">,</span> <span class="n">enc_assert_type</span><span class="p">],</span> <span class="n">solver_name</span><span class="p">,</span>
        <span class="n">extra_chmodel_args</span><span class="o">=</span><span class="n">extra_cipherchmodel_args</span><span class="p">,</span>
        <span class="n">extra_chfinder_args</span><span class="o">=</span><span class="n">extra_cipherchfinder_args</span><span class="p">,</span>
        <span class="n">extra_findnextchweight_args</span><span class="o">=</span><span class="n">extra_findnextchweight_args</span><span class="p">,</span>
        <span class="n">find_cipher_ch</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Adrián Ranea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>