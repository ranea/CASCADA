<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cascada.smt.invalidpropsearch &mdash; CASCADA 1.0.rc0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> CASCADA
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">CASCADA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primitives_implemented.html">Primitives implemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cascada.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CASCADA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>cascada.smt.invalidpropsearch</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cascada.smt.invalidpropsearch</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Search for zero-probability (invalid) properties</span>
<span class="sd">(e.g., impossible differentials or zero-correlation hulls)</span>
<span class="sd">by modeling the search as a sequence of SMT problems.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">enum</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">pysmt</span> <span class="kn">import</span> <span class="n">logics</span>

<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">operation</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">ssa</span> <span class="k">as</span> <span class="n">cascada_ssa</span>
<span class="kn">from</span> <span class="nn">cascada</span> <span class="kn">import</span> <span class="n">abstractproperty</span>
<span class="kn">from</span> <span class="nn">cascada.primitives</span> <span class="kn">import</span> <span class="n">blockcipher</span>
<span class="kn">from</span> <span class="nn">cascada.smt</span> <span class="kn">import</span> <span class="n">pysmttypes</span>
<span class="kn">from</span> <span class="nn">cascada.smt</span> <span class="kn">import</span> <span class="n">chsearch</span>

<span class="kn">from</span> <span class="nn">cascada.smt.wrappedchmodel</span> <span class="kn">import</span> <span class="n">get_wrapped_chmodel</span><span class="p">,</span> <span class="n">get_wrapped_cipher_chmodel</span>  <span class="c1"># needed</span>


<span class="nb">zip</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">zip</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">PrintingMode</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">PrintingMode</span>
<span class="n">INCREMENT_NUM_ROUNDS</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">INCREMENT_NUM_ROUNDS</span>


<div class="viewcode-block" id="ActiveBitMode"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.ActiveBitMode">[docs]</a><span class="k">class</span> <span class="nc">ActiveBitMode</span><span class="p">(</span><span class="n">enum</span><span class="o">.</span><span class="n">Enum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the subsets of bit-vectors available depending on</span>
<span class="sd">    which bits are activated (set to 1) for ``find_next_invalidprop_activebitmode``.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        Default: all bit-vectors</span>
<span class="sd">        SingleBit: bit-vectors with up to one bit activated (zero included)</span>
<span class="sd">        MSBbit: bit-vectors with up to the most significant bit activated (zero included)</span>
<span class="sd">        Zero: the zero bit-vector</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Default</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">SingleBit</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">MSBit</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span>
    <span class="n">Zero</span> <span class="o">=</span> <span class="n">enum</span><span class="o">.</span><span class="n">auto</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">_generate_bitvectors</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="n">total_num_active_bits</span><span class="p">,</span> <span class="n">active_bits_mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate lists of bit-vectors.</span>

<span class="sd">    Given ``widths`` as a list ``[w_1, ..., w_t]`` of t integers,</span>
<span class="sd">    this method generate all lists ``[bv_1, ..., bv_t]`` of t bit-vectors,</span>
<span class="sd">    where:</span>

<span class="sd">    * the `ActiveBitMode` of each ``bv_i`` is ``active_bits_mode``</span>
<span class="sd">    * the sum of active bits of  ``[bv_1, ..., bv_t]`` is ``total_num_active_bits``</span>
<span class="sd">    * ``bv_i`` has width ``w_i``.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; list(_generate_bitvectors([2, 2], 1, ActiveBitMode.Default))</span>
<span class="sd">        [[0b01, 0b00], [0b10, 0b00], [0b00, 0b01], [0b00, 0b10]]</span>
<span class="sd">        &gt;&gt;&gt; list(_generate_bitvectors([2, 2], 1, ActiveBitMode.SingleBit))</span>
<span class="sd">        [[0b01, 0b00], [0b00, 0b01]]</span>
<span class="sd">        &gt;&gt;&gt; list(_generate_bitvectors([2, 2], 1, ActiveBitMode.MSBit))</span>
<span class="sd">        [[0b10, 0b00], [0b00, 0b10]]</span>
<span class="sd">        &gt;&gt;&gt; list(_generate_bitvectors([2, 2], 0, ActiveBitMode.Zero))</span>
<span class="sd">        [[0b00, 0b00]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">active_bits_mode</span> <span class="o">==</span> <span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">Zero</span> <span class="ow">or</span> <span class="n">total_num_active_bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">total_num_active_bits</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;total_num_active_bits != 0 but active_bits_mode=Zero&quot;</span><span class="p">)</span>
        <span class="k">yield</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">active_bits_mode</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">SingleBit</span><span class="p">,</span> <span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">MSBit</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">combination</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)),</span> <span class="n">total_num_active_bits</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">active_bits_mode</span> <span class="o">==</span> <span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">MSBit</span><span class="p">:</span>
                <span class="n">iterables</span> <span class="o">=</span> <span class="p">[[</span><span class="n">w_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># active_bits_mode == SingleBit</span>
                <span class="n">iterables</span> <span class="o">=</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">w_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">w_combination</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">iterables</span><span class="p">):</span>
                <span class="n">bv_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">counter_w_c</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">index_w</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">index_w</span> <span class="ow">in</span> <span class="n">combination</span><span class="p">:</span>
                        <span class="n">bv_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">w_combination</span><span class="p">[</span><span class="n">counter_w_c</span><span class="p">],</span> <span class="n">w</span><span class="p">))</span>
                        <span class="n">counter_w_c</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bv_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                <span class="k">yield</span> <span class="n">bv_list</span>

    <span class="k">elif</span> <span class="n">active_bits_mode</span> <span class="o">==</span> <span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">Default</span><span class="p">:</span>
        <span class="c1"># Source: https://stackoverflow.com/a/10838990 and</span>
        <span class="c1">#   https://en.wikipedia.org/wiki/Combinatorial_number_system#Applications.</span>
        <span class="k">assert</span> <span class="n">total_num_active_bits</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">total_width</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">total_width</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">total_num_active_bits</span>

        <span class="k">def</span> <span class="nf">next_combination</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">x</span>
            <span class="k">return</span> <span class="n">v</span> <span class="o">+</span> <span class="p">(((</span><span class="n">v</span> <span class="o">^</span> <span class="n">x</span><span class="p">)</span> <span class="o">//</span> <span class="n">u</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># smallest number with k active bits</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bv</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">bv_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sum_w</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">:</span>
                <span class="n">bv_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bv</span><span class="p">[</span><span class="n">sum_w</span> <span class="o">+</span> <span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">sum_w</span><span class="p">])</span>
                <span class="n">sum_w</span> <span class="o">+=</span> <span class="n">w</span>
            <span class="k">yield</span> <span class="n">bv_list</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">next_combination</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid active_bits_mode&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="InvalidPropFinder"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.InvalidPropFinder">[docs]</a><span class="k">class</span> <span class="nc">InvalidPropFinder</span><span class="p">(</span><span class="n">chsearch</span><span class="o">.</span><span class="n">ChFinder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search for zero-probability (invalid) property pairs by modeling the search as a sequence of SMT problems.</span>

<span class="sd">    Given a characteristic model</span>
<span class="sd">    defined for a particular `Property` (e.g., `XorDiff` or `LinearMask`),</span>
<span class="sd">    this class finds *universally-invalid* characteristics</span>
<span class="sd">    following the characteristic model by modelling the search as a sequence</span>
<span class="sd">    of SMT problems in the bit-vector theory.</span>

<span class="sd">    A *universally-invalid* characteristic is a characteristic</span>
<span class="sd">    where the characteristic input property :math:`\\alpha`</span>
<span class="sd">    propagates to the characteristic output property :math:`\\beta`</span>
<span class="sd">    with probability zero regardless of the intermediate properties</span>
<span class="sd">    (i.e., for all assignments of the intermediate properties).</span>
<span class="sd">    In other words, the input-output property pair</span>
<span class="sd">    :math:`(\\alpha, \\beta)` has zero propagation probability.</span>

<span class="sd">    .. note::</span>
<span class="sd">        For the `Difference` (resp. `LinearMask`) property,</span>
<span class="sd">        a universally-invalid characteristic is actually an impossible</span>
<span class="sd">        differential (resp. a zero-correlation hull).</span>

<span class="sd">        Search for universally-invalid algebraic characteristic is not supported.</span>

<span class="sd">    Consider the SMT problem :math:`\Omega` of whether there exists a</span>
<span class="sd">    valid characteristic with constant input property :math:`\\alpha`</span>
<span class="sd">    and constant output property :math:`\\beta`</span>
<span class="sd">    (and where the intermediate properties are not specified).</span>
<span class="sd">    The main idea of the SMT-based search is that one can check whether</span>
<span class="sd">    :math:`\\alpha` propagates to :math:`\\beta` with probability zero</span>
<span class="sd">    by checking whether :math:`\Omega` is unsatisfisable (UNSAT).</span>
<span class="sd">    Note that only the validity constraints are needed to build :math:`\Omega`;</span>
<span class="sd">    the weight constraints are ignored when searching for universally-invalid characteristics.</span>

<span class="sd">    The initialization argument ``ch_model`` must be a subclass of</span>
<span class="sd">    `abstractproperty.chmodel.ChModel` with up to one non-trivial transitions</span>
<span class="sd">    (`abstractproperty.opmodel.OpModel` excluding `ModelIdentity`),</span>
<span class="sd">    since a zero-probability characteristic with up to one non-trivial transitions</span>
<span class="sd">    is a universally-invalid characteristic.</span>
<span class="sd">    For a characteristic model with more than one non-trivial transitions,</span>
<span class="sd">    the function `get_wrapped_chmodel` can be used to wrap the characteristic</span>
<span class="sd">    model into an equivalent characteristic model with one non-trivial transition.</span>

<span class="sd">    An `InvalidPropFinder` object is also an instance of `ChFinder` where</span>
<span class="sd">    `assert_type` is `Validity` and with the given initialization arguments</span>
<span class="sd">    ``ch_model``,  ``solver_name``, ``printing_mode``, ``filename``, ``solver_seed``</span>
<span class="sd">    and ``env=env``. See also `ChFinder`.</span>

<span class="sd">    Similar as `ChFinder`,  the methods of `InvalidPropFinder` that search for</span>
<span class="sd">    universally-invalid characteristics are Python `generator` functions,</span>
<span class="sd">    returning an `iterator` that yields the universally-invalid characteristics</span>
<span class="sd">    found in the search.</span>
<span class="sd">    If initialization argument ``ch_model`` is a `abstractproperty.chmodel.ChModel`</span>
<span class="sd">    (resp. `abstractproperty.chmodel.EncryptionChModel`),</span>
<span class="sd">    then these methods yield</span>
<span class="sd">    `abstractproperty.characteristic.Characteristic`</span>
<span class="sd">    (resp. `abstractproperty.characteristic.EncryptionCharacteristic`) objects.</span>

<span class="sd">    If the initialization argument ``check_universally_invalid_ch_found`` is ``True``,</span>
<span class="sd">    all universally-invalid characteristics found in the search are checked by searching</span>
<span class="sd">    for a valid characteristic with the same input and output property with</span>
<span class="sd">    `ChFinder.find_next_ch`.</span>

<span class="sd">        &gt;&gt;&gt; # example of SMT problem of universally-invalid LinearMask-EncryptionCharacteristic of (wrapped) Speck32</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.chmodel import EncryptionChModel</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.invalidpropsearch import InvalidPropFinder</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">        &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">        &gt;&gt;&gt; wrapped_ch_model = get_wrapped_chmodel(EncryptionChModel(Speck32, LinearMask))</span>
<span class="sd">        &gt;&gt;&gt; invalid_prop_finder = InvalidPropFinder(wrapped_ch_model, &quot;z3&quot;, solver_seed=0)</span>
<span class="sd">        &gt;&gt;&gt; invalid_prop_finder.formula_size()</span>
<span class="sd">        133</span>
<span class="sd">        &gt;&gt;&gt; print(invalid_prop_finder.hrepr(full_repr=True))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        ; characteristic model assertions</span>
<span class="sd">        assert (_mx0 == (mx9_out :: mx7_out)) &amp;</span>
<span class="sd">            ((~((mx1 ^ (_mp0 &gt;&gt;&gt; 7)) | (mx1 ^ mp1__0)) | _tmp20affb7ca27930ce775156bcc0ecaf20) == 0xffff) &amp;</span>
<span class="sd">            ((_tmp20affb7ca27930ce775156bcc0ecaf20 ^ (_tmp20affb7ca27930ce775156bcc0ecaf20 &gt;&gt; 0x0001) ^</span>
<span class="sd">                ((mx1 ^ (_mp0 &gt;&gt;&gt; 7) ^ mp1__0) &gt;&gt; 0x0001)) == 0x0000) &amp;</span>
<span class="sd">            (mx1 == _mk0) &amp; (mx1 == mx2) &amp; (((_mp1 ^ mp1__0) &lt;&lt;&lt; 2) == mx2__0) &amp; (((_mp1 ^ mp1__0) &lt;&lt;&lt; 2) == mx4) &amp;</span>
<span class="sd">            ((~((mx6 ^ ((mx2 ^ mx2__0) &gt;&gt;&gt; 7)) | (mx6 ^ mx4__0)) | _tmp824d7e7c80d9889507eb4e5d5c7be280) == 0xffff) &amp;</span>
<span class="sd">            ((_tmp824d7e7c80d9889507eb4e5d5c7be280 ^ (_tmp824d7e7c80d9889507eb4e5d5c7be280 &gt;&gt; 0x0001) ^</span>
<span class="sd">                ((mx6 ^ ((mx2 ^ mx2__0) &gt;&gt;&gt; 7) ^ mx4__0) &gt;&gt; 0x0001)) == 0x0000) &amp;</span>
<span class="sd">            (mx6 == _mk1) &amp; (mx6 == mx7) &amp; (((mx4 ^ mx4__0) &lt;&lt;&lt; 2) == mx7__0) &amp;</span>
<span class="sd">            (((mx4 ^ mx4__0) &lt;&lt;&lt; 2) == mx9) &amp; ((mx7 ^ mx7__0) == mx7_out) &amp; (mx9 == mx9_out)</span>
<span class="sd">        assert PropExtract_{·, 15, 0}(_mx0) == _mx1_out</span>
<span class="sd">        assert PropExtract_{·, 31, 16}(_mx0) == _mx2_out</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; # example of SMT problem of universally-invalid XorDiff-Characteristic of Speck32-KeySchedule</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.chmodel import ChModel</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.invalidpropsearch import InvalidPropFinder</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">        &gt;&gt;&gt; Speck32_KS.set_num_rounds(1)</span>
<span class="sd">        &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, XorDiff, [&quot;mk0&quot;, &quot;mk1&quot;])</span>
<span class="sd">        &gt;&gt;&gt; invalid_prop_finder = InvalidPropFinder(ch_model, &quot;z3&quot;, solver_seed=0)</span>
<span class="sd">        &gt;&gt;&gt; invalid_prop_finder.formula_size()</span>
<span class="sd">        42</span>
<span class="sd">        &gt;&gt;&gt; print(invalid_prop_finder.hrepr(full_repr=True))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        ; characteristic model assertions</span>
<span class="sd">        assert ((~((mk0 &gt;&gt;&gt; 7) &lt;&lt; 0x0001) ^ (mk1 &lt;&lt; 0x0001)) &amp; (~((mk0 &gt;&gt;&gt; 7) &lt;&lt; 0x0001) ^ (dx1 &lt;&lt; 0x0001)) &amp;</span>
<span class="sd">            ((mk0 &gt;&gt;&gt; 7) ^ mk1 ^ dx1 ^ ((mk0 &gt;&gt;&gt; 7) &lt;&lt; 0x0001))) == 0x0000</span>
<span class="sd">        assert mk1 == mk1_out</span>
<span class="sd">        assert ((mk1 &lt;&lt;&lt; 2) ^ dx1) == dx3_out</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_model</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span> <span class="n">check_universally_invalid_ch_found</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="c1"># initial_constraints=None, var_prop2ct_prop=None,  exclude_zero_input_prop=None,</span>
                 <span class="n">printing_mode</span><span class="o">=</span><span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">solver_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># weight_prefix=&quot;w&quot;,</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">ChModel</span><span class="p">)</span>

        <span class="n">non_id_opmodels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">op_model</span> <span class="ow">in</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">assign_outprop2op_model</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># PropConcat/PropExtract don&#39;t create OpModel objects</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">ModelIdentity</span><span class="p">):</span>
                <span class="n">non_id_opmodels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_model</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_id_opmodels</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;characteristic model has more than 1 OpModel (excluding Identity-based ones)&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">non-trivial OpModel (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">non_id_opmodels</span><span class="p">)</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">non_id_opmodels</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">ch_model</span><span class="p">,</span> <span class="n">assert_type</span><span class="o">=</span><span class="n">chsearch</span><span class="o">.</span><span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">Validity</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="n">solver_name</span><span class="p">,</span>
            <span class="c1"># initial_constraints=initial_constraints, var_prop2ct_prop=var_prop2ct_prop,</span>
            <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">printing_mode</span><span class="o">=</span><span class="n">printing_mode</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">solver_seed</span><span class="o">=</span><span class="n">solver_seed</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_universally_invalid_ch_found</span> <span class="o">=</span> <span class="n">check_universally_invalid_ch_found</span>

    <span class="c1"># ch_model_* properties abstracted for InvalidCipherProp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ch_model_input_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">input_prop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ch_model_output_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">output_prop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ch_model_assign_outprop2op_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">assign_outprop2op_model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ch_model_prop_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">_prop_label</span>

    <span class="k">def</span> <span class="nf">_get_uni_inv_ch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ct_outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">solution_var2ct</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the characteristic object from the constant input and output properties.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">solution_var2ct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ct_inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ct_outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">solution_var2ct</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">ct_inputs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ct_outputs</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">ct_inputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var_prop</span><span class="p">,</span> <span class="n">ct</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_input_prop</span><span class="p">,</span> <span class="n">ct_inputs</span><span class="p">):</span>
                <span class="n">solution_var2ct</span><span class="p">[</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct</span>
        <span class="k">if</span> <span class="n">ct_outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">var_prop</span><span class="p">,</span> <span class="n">ct</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_output_prop</span><span class="p">,</span> <span class="n">ct_outputs</span><span class="p">):</span>
                <span class="n">solution_var2ct</span><span class="p">[</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct</span>

        <span class="k">for</span> <span class="n">var_prop</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_input_prop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_output_prop</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">var_prop</span><span class="o">.</span><span class="n">val</span> <span class="ow">in</span> <span class="n">solution_var2ct</span>

        <span class="c1"># get_properties_for_initialization finds all intermediate properties</span>
        <span class="c1"># (from ct_inputs and starting from the beginning) up to</span>
        <span class="c1"># the output property OUTP of the non-Identity transition.</span>
        <span class="c1"># Since OUTP only depends on the output properties of the ch. model,</span>
        <span class="c1"># OUTP is obtained through backward propagation using an SMT-solver</span>
        <span class="c1"># (get_properties_for_initialization only does forward propagation)</span>

        <span class="n">constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">out_prop</span><span class="p">,</span> <span class="n">op_model</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_assign_outprop2op_model</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_model</span><span class="o">.</span><span class="n">validity_constraint</span><span class="p">(</span><span class="n">out_prop</span><span class="p">))</span>

        <span class="n">extra_constraint</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">solution_var2ct</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">extra_constraint</span> <span class="o">&amp;=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="c1"># # debugging</span>
        <span class="c1"># print(&quot;\n_get_uni_inv_ch&quot;)</span>
        <span class="c1"># print(&quot;ch model:&quot;, self.ch_model)</span>
        <span class="c1"># if hasattr(self.ch_model, &quot;_unwrapped_ch_model&quot;):</span>
        <span class="c1">#     print(&quot;ch model unwrapped:&quot;, self.ch_model._unwrapped_ch_model)</span>
        <span class="c1"># if hasattr(self.ch_model, &quot;_unwrapped_cipher_ch_model&quot;):</span>
        <span class="c1">#     print(&quot;ch model unwrapped:&quot;, self.ch_model._unwrapped_cipher_ch_model)</span>
        <span class="c1"># print(&quot;ct_inputs:&quot;, ct_inputs)</span>
        <span class="c1"># print(&quot;ct_outputs:&quot;, ct_outputs)</span>
        <span class="c1"># print(&quot;solution_var2ct:&quot;, solution_var2ct)</span>
        <span class="c1"># print(&quot;constraints:&quot;)</span>
        <span class="c1"># for c in constraints:</span>
        <span class="c1">#     print(&quot;\t&quot;, c)</span>
        <span class="c1"># print(&quot;extra_constraint:&quot;, extra_constraint)</span>
        <span class="c1"># print()</span>
        <span class="c1">#</span>

        <span class="n">chsearch</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">push_env</span><span class="p">()</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span>
        <span class="n">psr</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">bv2pysmt</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">pysmttypes</span><span class="o">.</span><span class="n">bv2pysmt</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">,</span> <span class="n">parse_shifts_rotations</span><span class="o">=</span><span class="n">psr</span><span class="p">)</span>

        <span class="n">found_unique_extended_solution</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># r = num constraints to remove</span>
            <span class="k">for</span> <span class="n">constraint_indices</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)),</span> <span class="n">r</span><span class="p">):</span>
                <span class="n">and_constraint</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">constraint_indices</span><span class="p">:</span>
                            <span class="n">and_constraint</span> <span class="o">&amp;=</span> <span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">and_constraint</span> <span class="o">&amp;=</span> <span class="n">extra_constraint</span>

                <span class="n">pysmt_formula</span> <span class="o">=</span> <span class="n">bv2pysmt</span><span class="p">(</span><span class="n">and_constraint</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">pysmt_model</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">get_model</span><span class="p">(</span><span class="n">pysmt_formula</span><span class="p">,</span> <span class="n">logic</span><span class="o">=</span><span class="n">logics</span><span class="o">.</span><span class="n">QF_BV</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pysmt_model</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># # debugging</span>
                    <span class="c1"># print(f&quot;_get_uni_inv_ch | no solution found without constraints {constraint_indices}&quot;)</span>
                    <span class="c1">#</span>
                    <span class="k">continue</span>

                <span class="n">extended_solution_var2ct</span> <span class="o">=</span> <span class="n">pysmttypes</span><span class="o">.</span><span class="n">pysmt_model2bv_model</span><span class="p">(</span><span class="n">pysmt_model</span><span class="p">)</span>
                <span class="n">exclude_last_solution</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">model_var</span><span class="p">,</span> <span class="n">model_val</span> <span class="ow">in</span> <span class="n">extended_solution_var2ct</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">exclude_last_solution</span> <span class="o">|=</span> <span class="o">~</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">model_var</span><span class="p">,</span> <span class="n">model_val</span><span class="p">)</span>
                <span class="n">pysmt_formula</span> <span class="o">=</span> <span class="n">bv2pysmt</span><span class="p">(</span><span class="n">and_constraint</span> <span class="o">&amp;</span> <span class="n">exclude_last_solution</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">env</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">is_sat</span><span class="p">(</span><span class="n">pysmt_formula</span><span class="p">,</span> <span class="n">logic</span><span class="o">=</span><span class="n">logics</span><span class="o">.</span><span class="n">QF_BV</span><span class="p">):</span>
                    <span class="c1"># # debugging</span>
                    <span class="c1"># second_sol = pysmttypes.pysmt_model2bv_model(env.factory.get_model(pysmt_formula, logic=logics.QF_BV))</span>
                    <span class="c1"># print(f&quot;_get_uni_inv_ch | found 2 solutions without constraints {constraint_indices}: &quot;,</span>
                    <span class="c1">#       f&quot;{extended_solution_var2ct}, {second_sol}&quot;)</span>
                    <span class="c1">#</span>
                    <span class="k">continue</span>

                <span class="n">found_unique_extended_solution</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">found_unique_extended_solution</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">assert</span> <span class="n">found_unique_extended_solution</span> <span class="ow">is</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">:</span>
            <span class="n">contradictions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">out_prop</span><span class="p">,</span> <span class="n">op_model</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_assign_outprop2op_model</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">constraint_indices</span><span class="p">:</span>
                    <span class="n">contradictions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">out_prop</span><span class="p">,</span> <span class="n">op_model</span><span class="p">))</span>
            <span class="n">smart_print</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">_get_smart_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Contradiction found in transitions </span><span class="si">{</span><span class="n">contradictions</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">chsearch</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">pop_env</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span>

        <span class="k">for</span> <span class="n">sol_var</span><span class="p">,</span> <span class="n">sol_val</span> <span class="ow">in</span> <span class="n">solution_var2ct</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="n">extended_solution_var2ct</span><span class="p">[</span><span class="n">sol_var</span><span class="p">]</span> <span class="o">==</span> <span class="n">sol_val</span>

        <span class="c1"># extra checks done in _pysmt_model2ch</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pysmt_model2ch</span><span class="p">(</span><span class="n">extended_solution_var2ct</span><span class="p">,</span> <span class="n">is_pysmt_model</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_sat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uni_inv_ch_found</span><span class="p">,</span> <span class="n">external_var2ct</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">ChModel</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span> <span class="o">==</span> <span class="n">uni_inv_ch_found</span><span class="o">.</span><span class="n">ch_model</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="s2">&quot;_unwrapped_ch_model&quot;</span><span class="p">):</span>
            <span class="n">list_ch_model</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">_unwrapped_ch_model</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">_unwrapped_ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">list_ch_model</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ch_model</span> <span class="ow">in</span> <span class="n">list_ch_model</span><span class="p">:</span>
            <span class="n">var_prop2ct_prop</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">vp</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ch_model</span><span class="o">.</span><span class="n">input_prop</span><span class="p">,</span> <span class="n">uni_inv_ch_found</span><span class="o">.</span><span class="n">input_prop</span><span class="p">):</span>
                <span class="n">var_prop2ct_prop</span><span class="p">[</span><span class="n">vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span>
            <span class="k">for</span> <span class="n">vp</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ch_model</span><span class="o">.</span><span class="n">output_prop</span><span class="p">,</span> <span class="n">uni_inv_ch_found</span><span class="o">.</span><span class="n">output_prop</span><span class="p">):</span>
                <span class="n">var_prop2ct_prop</span><span class="p">[</span><span class="n">vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span>
            <span class="k">if</span> <span class="n">external_var2ct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">prop</span><span class="p">),</span> <span class="p">(</span><span class="n">other_var</span><span class="p">,</span> <span class="n">other_ct</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                        <span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">external_var2ct</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">):</span>
                    <span class="k">assert</span> <span class="n">var</span> <span class="o">==</span> <span class="n">other_var</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                        <span class="k">assert</span> <span class="n">prop</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">other_ct</span>
                    <span class="n">var_prop2ct_prop</span><span class="p">[</span><span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">(</span><span class="n">var</span><span class="p">)]</span> <span class="o">=</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">(</span><span class="n">other_ct</span><span class="p">)</span>
            <span class="n">ch_finder</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChFinder</span><span class="p">(</span>
                <span class="n">ch_model</span><span class="p">,</span> <span class="n">assert_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span>
                <span class="n">var_prop2ct_prop</span><span class="o">=</span><span class="n">var_prop2ct_prop</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">printing_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">solver_seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">valid_ch_found</span> <span class="ow">in</span> <span class="n">ch_finder</span><span class="o">.</span><span class="n">find_next_ch</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;last characteristic found:&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - </span><span class="si">{</span><span class="n">uni_inv_ch_found</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">uni_inv_ch_found</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">in the search is not universally-invalid; found compatible valid characteristic:&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - </span><span class="si">{</span><span class="n">valid_ch_found</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">ChFinder:</span><span class="se">\n</span><span class="s2"> - ch_model: </span><span class="si">{</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - var_prop2ct_prop: </span><span class="si">{</span><span class="n">var_prop2ct_prop</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - assertions: </span><span class="si">{</span><span class="n">ch_finder</span><span class="o">.</span><span class="n">initial_constraints</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">ch_finder</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">ch_finder</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">==</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span>

<div class="viewcode-block" id="InvalidPropFinder.find_next_invalidprop_activebitmode"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.InvalidPropFinder.find_next_invalidprop_activebitmode">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_invalidprop_activebitmode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_num_active_bits</span><span class="p">,</span> <span class="n">input_prop_activebitmode</span><span class="p">,</span> <span class="n">output_prop_activebitmode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that yields the universally-invalid characteristics found in the SMT-based search</span>
<span class="sd">        with given `ActiveBitMode`.</span>

<span class="sd">        This method searches for universally-invalid characteristic using SMT solvers by checking</span>
<span class="sd">        one-by-one all input and output properties with given `ActiveBitMode`.</span>

<span class="sd">        Given a particular input and output properties :math:`(\\alpha, \\beta)`,</span>
<span class="sd">        the main subroutine of this method (herein call the *check subroutine*)</span>
<span class="sd">        checks whether :math:`\\alpha`</span>
<span class="sd">        propagates to :math:`\\beta` with probability zero by checking</span>
<span class="sd">        with an SMT solver whether the SMT problem, of whether there exists</span>
<span class="sd">        a valid characteristic with input property :math:`\\alpha` and output property</span>
<span class="sd">        :math:`\\beta`, is unsatisfisable (UNSAT).</span>
<span class="sd">        If the problem is UNSAT, the universally-invalid</span>
<span class="sd">        `abstractproperty.characteristic.Characteristic` object with</span>
<span class="sd">        input and output properties :math:`(\\alpha, \\beta)`</span>
<span class="sd">        is created and *yielded*.</span>

<span class="sd">        The check subroutine is repeated for all input and output properties where</span>
<span class="sd">        the `ActiveBitMode` of each word in the input (resp. output) property is</span>
<span class="sd">        ``input_prop_activebitmode`` (resp. ``output_prop_activebitmode``).</span>
<span class="sd">        The search starts considering input and output properties where</span>
<span class="sd">        the total number of active bits is ``initial_num_active_bits``,</span>
<span class="sd">        and the total number of active bits is incremented when</span>
<span class="sd">        all the input and output properties are checked.</span>

<span class="sd">            &gt;&gt;&gt; # example of search for universally-invalid LinearMask-EncryptionCharacteristic of (wrapped) Speck32</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.chmodel import EncryptionChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.smt.invalidpropsearch import InvalidPropFinder, ActiveBitMode</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">            &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; wrapped_ch_model = get_wrapped_chmodel(EncryptionChModel(Speck32, LinearMask))</span>
<span class="sd">            &gt;&gt;&gt; invalid_prop_finder = InvalidPropFinder(wrapped_ch_model, &quot;btor&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; inab, ipabm, opabm = 1, ActiveBitMode.MSBit, ActiveBitMode.MSBit</span>
<span class="sd">            &gt;&gt;&gt; for ch in invalid_prop_finder.find_next_invalidprop_activebitmode(inab, ipabm, opabm):</span>
<span class="sd">            ...     print(ch.srepr())</span>
<span class="sd">            Ch(w=Infinity, id=8000 0000, od=8000 0000)</span>
<span class="sd">            Ch(w=Infinity, id=8000 0000, od=0000 8000)</span>
<span class="sd">            Ch(w=Infinity, id=0000 8000, od=8000 0000)</span>
<span class="sd">            Ch(w=Infinity, id=0000 8000, od=0000 8000)</span>
<span class="sd">            Ch(w=Infinity, id=8000 0000, od=8000 8000)</span>
<span class="sd">            Ch(w=Infinity, id=0000 8000, od=8000 8000)</span>
<span class="sd">            Ch(w=Infinity, id=8000 8000, od=8000 0000)</span>
<span class="sd">            Ch(w=Infinity, id=8000 8000, od=0000 8000)</span>
<span class="sd">            Ch(w=Infinity, id=8000 8000, od=8000 8000)</span>
<span class="sd">            &gt;&gt;&gt; # example of SMT problem of universally-invalid XorDiff-Characteristic of Speck32-KeySchedule</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.chmodel import ChModel</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS.set_num_rounds(1)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, XorDiff, [&quot;mk0&quot;, &quot;mk1&quot;])</span>
<span class="sd">            &gt;&gt;&gt; invalid_prop_finder = InvalidPropFinder(ch_model, &quot;btor&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; inab, ipabm, opabm = 1, ActiveBitMode.SingleBit, ActiveBitMode.SingleBit</span>
<span class="sd">            &gt;&gt;&gt; ch = next(invalid_prop_finder.find_next_invalidprop_activebitmode(inab, ipabm, opabm))</span>
<span class="sd">            &gt;&gt;&gt; print(ch)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            Characteristic(ch_weight=inf, assignment_weights=[inf, inf, 0],</span>
<span class="sd">                input_diff=[0x0001, 0x0000], output_diff=[0x0001, 0x0000],</span>
<span class="sd">                assign_outdiff_list=[0x0000, 0x0001, 0x0000])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">smart_print</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">_get_smart_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

        <span class="c1"># initializing the solver</span>

        <span class="n">parse_shifts_rotations</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">bv2pysmt</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">pysmttypes</span><span class="o">.</span><span class="n">bv2pysmt</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="n">parse_shifts_rotations</span><span class="o">=</span><span class="n">parse_shifts_rotations</span><span class="p">)</span>

        <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span><span class="p">:</span>
                <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;solver_options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;seed&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">}}</span>  <span class="c1"># btor seed uint32</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;random_seed&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">}</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span> <span class="n">logic</span><span class="o">=</span><span class="n">logics</span><span class="o">.</span><span class="n">QF_BV</span><span class="p">,</span> <span class="o">**</span><span class="n">solver_kwargs</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">):</span>
            <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1"># setting max/min in/out/ num/mode active bit</span>

        <span class="n">in_abmode</span> <span class="o">=</span> <span class="n">input_prop_activebitmode</span>  <span class="c1"># all variables using in/out</span>
        <span class="n">out_abmode</span> <span class="o">=</span> <span class="n">output_prop_activebitmode</span>

        <span class="k">if</span> <span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">Zero</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">in_abmode</span><span class="p">,</span> <span class="n">out_abmode</span><span class="p">]</span> <span class="ow">and</span> <span class="n">initial_num_active_bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">initial_num_active_bits</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">in_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_input_prop</span><span class="p">]</span>
        <span class="n">out_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_output_prop</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">abmode2max_min_num_active_bits</span><span class="p">(</span><span class="n">my_abmode</span><span class="p">,</span> <span class="n">my_list_widths</span><span class="p">):</span>
            <span class="n">my_min_num_active_bits</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">my_abmode</span> <span class="o">==</span> <span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">Default</span><span class="p">:</span>
                <span class="n">my_max_num_active_bits</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">my_list_widths</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">my_abmode</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">SingleBit</span><span class="p">,</span> <span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">MSBit</span><span class="p">]:</span>
                <span class="n">my_max_num_active_bits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_list_widths</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">my_abmode</span> <span class="o">==</span> <span class="n">ActiveBitMode</span><span class="o">.</span><span class="n">Zero</span><span class="p">:</span>
                <span class="n">my_max_num_active_bits</span> <span class="o">=</span> <span class="n">my_min_num_active_bits</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid mode&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">my_max_num_active_bits</span><span class="p">,</span> <span class="n">my_min_num_active_bits</span>

        <span class="n">in_max_num_ab</span><span class="p">,</span> <span class="n">in_min_num_ab</span> <span class="o">=</span> <span class="n">abmode2max_min_num_active_bits</span><span class="p">(</span><span class="n">in_abmode</span><span class="p">,</span> <span class="n">in_widths</span><span class="p">)</span>
        <span class="n">out_max_num_ab</span><span class="p">,</span> <span class="n">out_min_num_ab</span> <span class="o">=</span> <span class="n">abmode2max_min_num_active_bits</span><span class="p">(</span><span class="n">out_abmode</span><span class="p">,</span> <span class="n">out_widths</span><span class="p">)</span>
        <span class="c1"># max_in_out_active_bits = max_in_active_bits + max_out_active_bits</span>

        <span class="n">prop_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_prop_label</span>  <span class="c1"># e.g., diff, mask</span>

        <span class="c1">#</span>

        <span class="k">for</span> <span class="n">in_out_num_ab</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">initial_num_active_bits</span><span class="p">,</span> <span class="n">in_max_num_ab</span> <span class="o">+</span> <span class="n">out_max_num_ab</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">in_num_ab</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_min_num_ab</span><span class="p">,</span> <span class="n">in_max_num_ab</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">out_num_ab</span> <span class="o">=</span> <span class="n">in_out_num_ab</span> <span class="o">-</span> <span class="n">in_num_ab</span>
                <span class="k">if</span> <span class="n">out_num_ab</span> <span class="o">&lt;</span> <span class="n">out_min_num_ab</span> <span class="ow">or</span> <span class="n">out_num_ab</span> <span class="o">&gt;</span> <span class="n">out_max_num_ab</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Finding input/output </span><span class="si">{</span><span class="n">prop_label</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">in_num_ab</span><span class="si">}</span><span class="s2"> input&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot; and </span><span class="si">{</span><span class="n">out_num_ab</span><span class="si">}</span><span class="s2"> output active bits&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">in_ct_words</span> <span class="ow">in</span> <span class="n">_generate_bitvectors</span><span class="p">(</span><span class="n">in_widths</span><span class="p">,</span> <span class="n">in_num_ab</span><span class="p">,</span> <span class="n">in_abmode</span><span class="p">):</span>
                    <span class="n">solver</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>

                    <span class="k">for</span> <span class="n">var_prop</span><span class="p">,</span> <span class="n">ct</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_input_prop</span><span class="p">,</span> <span class="n">in_ct_words</span><span class="p">):</span>
                        <span class="n">constraint</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>
                        <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fixed input </span><span class="si">{</span><span class="n">prop_label</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">in_ct_words</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">out_ct_words</span> <span class="ow">in</span> <span class="n">_generate_bitvectors</span><span class="p">(</span><span class="n">out_widths</span><span class="p">,</span> <span class="n">out_num_ab</span><span class="p">,</span> <span class="n">out_abmode</span><span class="p">):</span>
                        <span class="n">solver</span><span class="o">.</span><span class="n">push</span><span class="p">()</span>

                        <span class="k">for</span> <span class="n">var_prop</span><span class="p">,</span> <span class="n">ct</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_output_prop</span><span class="p">,</span> <span class="n">out_ct_words</span><span class="p">):</span>
                            <span class="n">constraint</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">var_prop</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>
                            <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fixed output </span><span class="si">{</span><span class="n">prop_label</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">out_ct_words</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                        <span class="n">satisfiable</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="n">satisfiable</span><span class="p">:</span>
                            <span class="n">last_ch_found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_uni_inv_ch</span><span class="p">(</span><span class="n">in_ct_words</span><span class="p">,</span> <span class="n">out_ct_words</span><span class="p">)</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_universally_invalid_ch_found</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">last_ch_found</span><span class="p">)</span>
                            <span class="k">yield</span> <span class="n">last_ch_found</span>

                        <span class="n">solver</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">solver</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span></div>

<div class="viewcode-block" id="InvalidPropFinder.find_next_invalidprop_miss_in_the_middle"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.InvalidPropFinder.find_next_invalidprop_miss_in_the_middle">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_invalidprop_miss_in_the_middle</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">ch_model_E0</span><span class="p">,</span> <span class="n">ch_model_E2</span><span class="p">,</span>
            <span class="n">ch_model_E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ch_model_external_E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">exclude_zero_input_prop_E0</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">exclude_zero_input_prop_E2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">exclude_zero_input_prop_external_E</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that yields the universally-invalid characteristics found in the SMT+MitM-based search.</span>

<span class="sd">        This method searches for universally-invalid characteristic using SMT problems</span>
<span class="sd">        and the miss-in-the-middle approach.</span>

<span class="sd">        Let :math:`E` be a function split into three functions</span>
<span class="sd">        :math:`E = E_2 \circ E_1 \circ E_0`.</span>
<span class="sd">        Let :math:`((p_0, p_1), (p_2, p_3))` denote a *partial* characteristic</span>
<span class="sd">        over :math:`E`, that is, a characteristic over :math:`E` where:</span>

<span class="sd">        * :math:`(p_0, p_1)` are the non-zero input and output properties of a</span>
<span class="sd">          characteristic with probability 1 over :math:`E_0`</span>
<span class="sd">        * :math:`(p_2, p_3)` are the non-zero input and output properties of a</span>
<span class="sd">          characteristic with probability 1 over :math:`E_2`</span>
<span class="sd">        * no relation is imposed between :math:`(p_1, p_2)`, the input and output</span>
<span class="sd">          properties of :math:`E_1`.</span>

<span class="sd">        The underlying function of ``self.ch_model`` corresponds to :math:`E_1`,</span>
<span class="sd">        the underlying function of the `abstractproperty.chmodel.ChModel`</span>
<span class="sd">        ``ch_model_E0`` corresponds to :math:`E_0`,</span>
<span class="sd">        and the underlying function of the `abstractproperty.chmodel.ChModel`</span>
<span class="sd">        ``ch_model_E2`` corresponds to :math:`E_2`.</span>
<span class="sd">        The underlying function of the `abstractproperty.chmodel.ChModel`</span>
<span class="sd">        ``ch_model_E`` corresponds to :math:`E`,</span>
<span class="sd">        but this argument is optional (more on that later).</span>

<span class="sd">        By default the input properties of ``ch_model_E0`` and</span>
<span class="sd">        ``ch_model_E2`` are excluded to be zero, but this can be</span>
<span class="sd">        changed with the optional arguments ``exclude_zero_input_prop_*``.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method requires that for any probability-one characteristic</span>
<span class="sd">            over :math:`E_0` with input-output property :math:`(p_0, p_1)`,</span>
<span class="sd">            there is no other probability-one characteristic over :math:`E_0`</span>
<span class="sd">            with input property :math:`p_0` but output property :math:`\\neq p_1`.</span>

<span class="sd">            Similarly, for any probability-one characteristic</span>
<span class="sd">            over :math:`E_2` with input-output property :math:`(p_2, p_3)`,</span>
<span class="sd">            there is no other probability-one characteristic over :math:`E_2`</span>
<span class="sd">            with output property :math:`p3` but input property :math:`\\neq p_2`.</span>

<span class="sd">            If :math:`E_0` and :math:`E_2` are permutations, then these two</span>
<span class="sd">            requirements are satisfied for `Difference` and `LinearMask`</span>
<span class="sd">            properties.</span>

<span class="sd">        If the optional argument ``ch_model_external_E`` is given as a</span>
<span class="sd">        `abstractproperty.chmodel.ChModel` with input and output properties</span>
<span class="sd">        :math:`(q_0, q_1)`, the definition of a partial characteristic is</span>
<span class="sd">        extended to :math:`((p_0, p_1), (p_2, p_3), (q_0, q_1)`</span>
<span class="sd">        such that :math:`(q_0, q_1)` are the input and output properties of a</span>
<span class="sd">        characteristic with probability 1 where :math:`q_1` is the list of</span>
<span class="sd">        external variables of :math:`E` (see `SSA`).</span>
<span class="sd">        If ``ch_model_external_E`` is given,</span>
<span class="sd">        the argument  ``exclude_zero_input_prop_external_E``</span>
<span class="sd">        that determines whether to exclude non-zero :math:`q_0`</span>
<span class="sd">        must also be given.</span>

<span class="sd">        .. note::</span>
<span class="sd">            The functions :math:`(E_0, E_1, E_2)` can be easily obtained</span>
<span class="sd">            from a `RoundBasedFunction` :math:`E` that includes</span>
<span class="sd">            `add_round_outputs` calls in its ``eval``.</span>

<span class="sd">            For example, obtaining :math:`E_0` from the round ``ns`` to</span>
<span class="sd">            ``ns+ne0`` (``ns`` denoting the initial number of skipped rounds),</span>
<span class="sd">            :math:`E_1` as the next ``ne1`` rounds, and :math:`E_2`</span>
<span class="sd">            as the next ``ne2`` rounds can be done as follows:</span>

<span class="sd">            .. code:: python</span>

<span class="sd">                [...]</span>
<span class="sd">                ns, ne0, ne1, ne2 = ...</span>
<span class="sd">                MyRoundBasedFunction.set_num_rounds(ns+ne0+ne1+ne2)</span>
<span class="sd">                ch_model_E = ChModel(MyRoundBasedFunction, ...)</span>
<span class="sd">                rs = ch_model.get_round_separators()</span>
<span class="sd">                # the end of the i-th round (i=1,2,...) is rs[i-1]</span>
<span class="sd">                e0_rs, e1_rs = rs[ns+ne0-1], rs[ns+ne0+ne1-1]</span>
<span class="sd">                ch_model_E0, ch_model_E1, ch_model_E2 = ch_model_E.split([e0_rs, e1_rs])</span>
<span class="sd">                ch_model_E1 = get_wrapped_chmodel(ch_model_E1)  # in case ch_model_E1 2+ non-trivial transitions</span>
<span class="sd">                invalid_prop_finder = InvalidPropFinder(ch_model_E1, ...)</span>
<span class="sd">                invalid_prop_finder.find_next_invalidprop_miss_in_the_middle(</span>
<span class="sd">                    ch_model_E0=ch_model_E0, ch_model_E2=ch_model_E2, ch_model_E=ch_model_E)</span>

<span class="sd">            Alternatively, one can use the function `round_based_invalidprop_search`</span>
<span class="sd">            which automates the generation of :math:`(E_0, E_1, E_2)`</span>
<span class="sd">            and applies this method iteratively on the number of rounds.</span>

<span class="sd">        This method finds universally-invalid characteristics by searching for all</span>
<span class="sd">        partial characteristics over :math:`E` using `ChFinder.find_next_ch`,</span>
<span class="sd">        and for each partial characteristic we apply the *check subroutine*</span>
<span class="sd">        to check whether :math:`p_1` propagates to :math:`p_2` with</span>
<span class="sd">        zero probability over :math:`E_1`.</span>
<span class="sd">        The check subroutine is explained in `find_next_invalidprop_activebitmode`.</span>

<span class="sd">        For each partial characteristic :math:`((p_0, p_1), (p_2, p_3))` found,</span>
<span class="sd">        if the check subroutine finds that :math:`p_1` propagates to :math:`p_2`</span>
<span class="sd">        with zero probability, a tuple of 3</span>
<span class="sd">        `abstractproperty.characteristic.Characteristic` is  *yielded*:</span>

<span class="sd">        * the first characteristic corresponds to the characteristic with probability 1</span>
<span class="sd">          over :math:`E_0` with input and output properties :math:`(p_0, p_1)`</span>
<span class="sd">        * the second characteristic corresponds to the universally-invalid characteristic over :math:`E_1`</span>
<span class="sd">          with input and output properties :math:`(p_1, p_2)`</span>
<span class="sd">        * the third characteristic corresponds to the characteristic with probability 1</span>
<span class="sd">          over :math:`E_2` with input and output properties :math:`(p_2, p_3)`</span>

<span class="sd">        Since the first and third characteristics have probability one,</span>
<span class="sd">        the concatenation of these three characteristics is a universally-invalid</span>
<span class="sd">        characteristic over :math:`E` (regardless of the external variables of :math:`E`)</span>

<span class="sd">        If the optional argument ``ch_model_external_E`` is given,</span>
<span class="sd">        instead a tuple of 4 characteristic is yieled; the 4-th</span>
<span class="sd">        characteristic corresponds to the characteristic with probability 1</span>
<span class="sd">        with input and output properties :math:`(q_0, q_1)`.</span>
<span class="sd">        In this case, the concatenation of the first 3 characteristics is a universally-invalid</span>
<span class="sd">        characteristic over :math:`E` *for* the external properties</span>
<span class="sd">        given by the outputs of the 4-th characteristic.</span>

<span class="sd">        If the initialization argument ``check_universally_invalid_ch_found`` is ``True``,</span>
<span class="sd">        all universally-invalid characteristics found over :math:`E_1` in the search</span>
<span class="sd">        are checked by searching for a valid characteristic with the same</span>
<span class="sd">        input and output property with `ChFinder.find_next_ch`.</span>
<span class="sd">        In addition, if the optional argument ``ch_model_E`` is given,</span>
<span class="sd">        then the universally-invalid characteristic over :math:`E` (the concatenation</span>
<span class="sd">        of the characteristic founds over  :math:`E_0`, :math:`E_1`</span>
<span class="sd">        and :math:`E_2`) is also checked in a similar way.</span>

<span class="sd">            &gt;&gt;&gt; # example of search for universally-invalid LinearMask-EncryptionCharacteristic of (wrapped) Speck32</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.chmodel import EncryptionChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.smt.invalidpropsearch import InvalidPropFinder</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">            &gt;&gt;&gt; Speck32.set_num_rounds(3)</span>
<span class="sd">            &gt;&gt;&gt; ch_model_E = EncryptionChModel(Speck32, LinearMask)</span>
<span class="sd">            &gt;&gt;&gt; ch_model_E0, ch_model_E1, ch_model_E2 = ch_model_E.split(ch_model_E.get_round_separators())</span>
<span class="sd">            &gt;&gt;&gt; ch_model_E1 = get_wrapped_chmodel(ch_model_E1)</span>
<span class="sd">            &gt;&gt;&gt; invalid_prop_finder = InvalidPropFinder(ch_model_E1, &quot;btor&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; tuple_iterator = invalid_prop_finder.find_next_invalidprop_miss_in_the_middle(ch_model_E0, ch_model_E2)</span>
<span class="sd">            &gt;&gt;&gt; for i, (pr1_ch_E0, uni_inv_ch_E1, pr1_ch_E2) in enumerate(tuple_iterator):</span>
<span class="sd">            ...     print(pr1_ch_E0.srepr(), uni_inv_ch_E1.srepr(), pr1_ch_E2.srepr())</span>
<span class="sd">            ...     if i == 2: break</span>
<span class="sd">            Ch(w=0, id=0000 0001, od=0004 0004) Ch(w=Infinity, id=0004 0004, od=0000 0001) Ch(w=0, id=0000 0001, od=0004 0004)</span>
<span class="sd">            Ch(w=0, id=0000 0001, od=0004 0004) Ch(w=Infinity, id=0004 0004, od=0080 e001) Ch(w=0, id=0080 e001, od=8002 8003)</span>
<span class="sd">            Ch(w=0, id=0000 0001, od=0004 0004) Ch(w=Infinity, id=0004 0004, od=0080 f001) Ch(w=0, id=0080 f001, od=c002 c003)</span>
<span class="sd">            &gt;&gt;&gt; # example of SMT problem of universally-invalid XorDiff-Characteristic of Speck32-KeySchedule</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.chmodel import ChModel</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS.set_num_rounds(3)</span>
<span class="sd">            &gt;&gt;&gt; ch_model_E = ChModel(Speck32_KS, XorDiff, [&quot;mk0&quot;, &quot;mk1&quot;, &quot;mk2&quot;, &quot;mk3&quot;])</span>
<span class="sd">            &gt;&gt;&gt; ch_model_E0, ch_model_E1, ch_model_E2 = ch_model_E.split(ch_model_E.get_round_separators())</span>
<span class="sd">            &gt;&gt;&gt; invalid_prop_finder = InvalidPropFinder(ch_model_E1, &quot;btor&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; ti = invalid_prop_finder.find_next_invalidprop_miss_in_the_middle(ch_model_E0, ch_model_E2, ch_model_E=ch_model_E)</span>
<span class="sd">            &gt;&gt;&gt; pr1_ch_E0, uni_inv_ch_E1, pr1_ch_E2 = next(ti)</span>
<span class="sd">            &gt;&gt;&gt; print(pr1_ch_E0)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            Characteristic(ch_weight=0, assignment_weights=[0, 0, 0, 0, 0],</span>
<span class="sd">                input_diff=[0x0001, 0x0001, 0x0000, 0x0000], output_diff=[0x0001, 0x0000, 0x0001, 0x0000],</span>
<span class="sd">                assign_outdiff_list=[0x0000, 0x0001, 0x0000, 0x0001, 0x0000])</span>
<span class="sd">            &gt;&gt;&gt; print(uni_inv_ch_E1)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            Characteristic(ch_weight=inf, assignment_weights=[inf, inf, 0, inf, inf],</span>
<span class="sd">                input_diff=[0x0001, 0x0000, 0x0001, 0x0000], output_diff=[0x0000, 0x8000, 0x0001, 0x0001],</span>
<span class="sd">                assign_outdiff_list=[0x8000, 0x0000, 0x8000, 0x0001, 0x0001])</span>
<span class="sd">            &gt;&gt;&gt; print(pr1_ch_E2)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            Characteristic(ch_weight=0, assignment_weights=[0, 0, 0, 0, 0],</span>
<span class="sd">                input_diff=[0x0000, 0x8000, 0x0001, 0x0001], output_diff=[0x0001, 0x0001, 0x8000, 0x8002],</span>
<span class="sd">                assign_outdiff_list=[0x8000, 0x0001, 0x0001, 0x8000, 0x8002])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  0. Preliminary checks</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">check_universally_invalid_ch_found</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">ch_model_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">exclude_zero_input_prop_external_E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># no cipher ch model allowed (no need to use self._ch_model_*)</span>
        <span class="n">list_aux_ch_model</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">ch_model_E0</span><span class="p">,</span> <span class="n">ch_model_E2</span><span class="p">]</span>
        <span class="n">list_aux_prone_ch_model</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch_model_E0</span><span class="p">,</span> <span class="n">ch_model_E2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ch_model_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">list_aux_ch_model</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_model_E</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">list_aux_ch_model</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_model_external_E</span><span class="p">)</span>
            <span class="n">list_aux_prone_ch_model</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch_model_external_E</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">aux_ch_model</span> <span class="ow">in</span> <span class="n">list_aux_ch_model</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aux_ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">ChModel</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;found non-ChModel input&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">aux_prone_ch_model</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_aux_prone_ch_model</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">name_prone_ch_model</span> <span class="o">=</span> <span class="s2">&quot;ch_model_E0&quot;</span>
            <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">name_prone_ch_model</span> <span class="o">=</span> <span class="s2">&quot;ch_model_E2&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="n">name_prone_ch_model</span> <span class="o">=</span> <span class="s2">&quot;ch_model_external_E&quot;</span>
            <span class="k">if</span> <span class="n">aux_prone_ch_model</span><span class="o">.</span><span class="n">pr_one_assertions</span><span class="p">()</span> <span class="o">==</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name_prone_ch_model</span><span class="si">}</span><span class="s2">.pr_one_assertions() == False</span><span class="se">\n</span><span class="si">{</span><span class="n">aux_prone_ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aux_prone_ch_model</span><span class="o">.</span><span class="n">max_weight</span><span class="p">(</span><span class="n">truncate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name_prone_ch_model</span><span class="si">}</span><span class="s2"> might contain too many characteristics with probability 1 &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;since </span><span class="si">{</span><span class="n">name_prone_ch_model</span><span class="si">}</span><span class="s2">.max_weight() is 0 </span><span class="se">\n</span><span class="si">{</span><span class="n">aux_prone_ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ch_model_E0</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">output_widths</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">input_widths</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;outputs widths of ch_model_E0 </span><span class="si">{</span><span class="n">ch_model_E0</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">output_widths</span><span class="si">}</span><span class="s2">&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; != </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">input_widths</span><span class="si">}</span><span class="s2"> input widths of self.ch_model&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ch_model_E2</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">input_widths</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">output_widths</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input widths of ch_model_E2 </span><span class="si">{</span><span class="n">ch_model_E2</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">input_widths</span><span class="si">}</span><span class="s2">&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; != </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">output_widths</span><span class="si">}</span><span class="s2"> output widths of self.ch_model&quot;</span><span class="p">)</span>

        <span class="c1"># for all Pr.1 ch over E0, there must be a unique output property for each input property</span>
        <span class="c1"># for all Pr.1 ch over E2, there must be a unique input property for each output property</span>

        <span class="kn">from</span> <span class="nn">cascada.differential.difference</span> <span class="kn">import</span> <span class="n">Difference</span>
        <span class="kn">from</span> <span class="nn">cascada.linear.mask</span> <span class="kn">import</span> <span class="n">LinearMask</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">,</span> <span class="n">Difference</span><span class="p">):</span>
            <span class="c1"># for differentials with Pr. 1, an input property propagates to a unique output property</span>
            <span class="c1"># E0 automatically valid, E2 needs an inverse</span>
            <span class="n">sum_iw</span><span class="p">,</span> <span class="n">sum_ow</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ch_model_E2</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">input_widths</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ch_model_E2</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">output_widths</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sum_iw</span> <span class="o">!=</span> <span class="n">sum_ow</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;with the Difference property, E2 needs to be a permutation&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;but input size = </span><span class="si">{</span><span class="n">sum_iw</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">sum_ow</span><span class="si">}</span><span class="s2"> = output size&quot;</span><span class="p">)</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">,</span> <span class="n">LinearMask</span><span class="p">):</span>
            <span class="c1"># for hulls with Pr. 1, an output property propagates (backwards) to a unique input property</span>
            <span class="c1"># E2 automatically valid, E0 needs an inverse</span>
            <span class="n">sum_iw</span><span class="p">,</span> <span class="n">sum_ow</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ch_model_E0</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">input_widths</span><span class="p">),</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ch_model_E0</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">output_widths</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sum_iw</span> <span class="o">!=</span> <span class="n">sum_ow</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;with the LinearMask property, E0 needs to be a permutation&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;but input size = </span><span class="si">{</span><span class="n">sum_iw</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="n">sum_ow</span><span class="si">}</span><span class="s2"> = output size&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">external_props_E0</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ch_model_E0</span><span class="o">.</span><span class="n">prop_type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ch_model_E0</span><span class="o">.</span><span class="n">external_var2prop</span><span class="p">)</span>
            <span class="n">external_props_E1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="p">)</span>
            <span class="n">external_props_E2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ch_model_E2</span><span class="o">.</span><span class="n">prop_type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ch_model_E2</span><span class="o">.</span><span class="n">external_var2prop</span><span class="p">)</span>
            <span class="n">output_props_external_E</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">ch_model_external_E</span><span class="o">.</span><span class="n">output_prop</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ch_model_external_E contains a constant external property&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">ch_model_external_E: </span><span class="si">{</span><span class="n">ch_model_external_E</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">external_props_E1</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">output_props_external_E</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;E1 contains an external variable not included in ch_model_external_E outputs&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">ch. model of E1: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="se">\n</span><span class="s2">ch_model_external_E: </span><span class="si">{</span><span class="n">ch_model_external_E</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">external_props_E0_E1_E2</span> <span class="o">=</span> <span class="n">external_props_E0</span> <span class="o">|</span> <span class="n">external_props_E1</span> <span class="o">|</span> <span class="n">external_props_E2</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">output_props_external_E</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">external_props_E0_E1_E2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ch_model_external_E contains an output that is not an external property of E&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;ch_model_external_E: </span><span class="si">{</span><span class="n">ch_model_external_E</span><span class="si">}</span><span class="se">\n</span><span class="s2">external properties of E: </span><span class="si">{</span><span class="n">external_props_E0_E1_E2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1">#  1. Initialization of the ChFinder objects</span>

        <span class="c1"># zero input prop excluded by default in E0 since ch_model_E</span>
        <span class="c1"># with input/output = (0, non-zero) is always uni-inv for *Diff and LinearMask</span>
        <span class="c1"># zero input prop also excluded by default in E2 since (non-zero, 0)</span>
        <span class="c1"># is always uni-inv for permutations with either *Diff or LinearMask</span>

        <span class="n">chfinder_E0</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChFinder</span><span class="p">(</span>
            <span class="n">ch_model_E0</span><span class="p">,</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span>
            <span class="n">exclude_zero_input_prop</span><span class="o">=</span><span class="n">exclude_zero_input_prop_E0</span><span class="p">,</span>
            <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">printing_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">solver_seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span>
        <span class="p">)</span>
        <span class="c1"># don&#39;t delete chfinder_E2 to avoid destructing shared env</span>
        <span class="n">chfinder_E2</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChFinder</span><span class="p">(</span>
            <span class="n">ch_model_E2</span><span class="p">,</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span>
            <span class="n">exclude_zero_input_prop</span><span class="o">=</span><span class="n">exclude_zero_input_prop_E2</span><span class="p">,</span>
            <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">printing_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">solver_seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chfinder_external_E</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChFinder</span><span class="p">(</span>
                <span class="n">ch_model_external_E</span><span class="p">,</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">ProbabilityOne</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span>
                <span class="n">exclude_zero_input_prop</span><span class="o">=</span><span class="n">exclude_zero_input_prop_external_E</span><span class="p">,</span>
                <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">printing_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
                <span class="n">solver_seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span>
            <span class="p">)</span>

        <span class="c1">#  2. Initialization of the solver for the universally-invalid ch E1</span>

        <span class="n">bv2pysmt_E1</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">pysmttypes</span><span class="o">.</span><span class="n">bv2pysmt</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">,</span>
            <span class="n">parse_shifts_rotations</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">solver_E1_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span><span class="p">:</span>
                <span class="n">solver_E1_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;solver_options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;seed&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">}}</span>  <span class="c1"># btor seed uint32</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solver_E1_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;random_seed&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">}</span>
        <span class="n">solver_E1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span> <span class="n">logic</span><span class="o">=</span><span class="n">logics</span><span class="o">.</span><span class="n">QF_BV</span><span class="p">,</span> <span class="o">**</span><span class="n">solver_E1_kwargs</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">):</span>
            <span class="n">solver_E1</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt_E1</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1">#  3. Auxiliary functions</span>

        <span class="n">stored_prone_ch_assignment_E0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">stored_prone_ch_assignment_E2</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">get_next_prone_ch_assignment_E0</span><span class="p">(</span><span class="n">my_var2ct</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stored_prone_ch_assignment_E0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">my_prone_ch_assignment</span> <span class="ow">in</span> <span class="n">stored_prone_ch_assignment_E0</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">my_prone_ch_assignment</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">my_var2ct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">original_initial_constraints</span> <span class="o">=</span> <span class="n">chfinder_E0</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">[:]</span>
                    <span class="k">for</span> <span class="n">ext_v</span> <span class="ow">in</span> <span class="n">chfinder_E0</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="p">:</span>
                        <span class="n">chfinder_E0</span><span class="o">.</span><span class="n">initial_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">ext_v</span><span class="p">,</span> <span class="n">my_var2ct</span><span class="p">[</span><span class="n">ext_v</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">my_prone_ch_assignment</span> <span class="ow">in</span> <span class="n">chfinder_E0</span><span class="o">.</span><span class="n">find_next_ch</span><span class="p">(</span><span class="n">yield_assignment</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">my_var2ct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">stored_prone_ch_assignment_E0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">my_prone_ch_assignment</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">my_prone_ch_assignment</span>
                <span class="k">if</span> <span class="n">my_var2ct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">chfinder_E0</span><span class="o">.</span><span class="n">initial_constraints</span> <span class="o">=</span> <span class="n">original_initial_constraints</span>

        <span class="k">def</span> <span class="nf">get_next_prone_ch_assignment_E2</span><span class="p">(</span><span class="n">my_var2ct</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stored_prone_ch_assignment_E2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">my_prone_ch_assignment</span> <span class="ow">in</span> <span class="n">stored_prone_ch_assignment_E2</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">my_prone_ch_assignment</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">my_var2ct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">original_initial_constraints</span> <span class="o">=</span> <span class="n">chfinder_E2</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">[:]</span>
                    <span class="k">for</span> <span class="n">ext_v</span> <span class="ow">in</span> <span class="n">chfinder_E2</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="p">:</span>
                        <span class="n">chfinder_E2</span><span class="o">.</span><span class="n">initial_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">ext_v</span><span class="p">,</span> <span class="n">my_var2ct</span><span class="p">[</span><span class="n">ext_v</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">my_prone_ch_assignment</span> <span class="ow">in</span> <span class="n">chfinder_E2</span><span class="o">.</span><span class="n">find_next_ch</span><span class="p">(</span><span class="n">yield_assignment</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">my_var2ct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">stored_prone_ch_assignment_E2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">my_prone_ch_assignment</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">my_prone_ch_assignment</span>
                <span class="k">if</span> <span class="n">my_var2ct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">chfinder_E2</span><span class="o">.</span><span class="n">initial_constraints</span> <span class="o">=</span> <span class="n">original_initial_constraints</span>

        <span class="k">def</span> <span class="nf">get_next_prone_ch_assignment_external_E</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">yield</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">my_prone_ch_assignment</span> <span class="ow">in</span> <span class="n">chfinder_external_E</span><span class="o">.</span><span class="n">find_next_ch</span><span class="p">(</span><span class="n">yield_assignment</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">my_prone_ch_assignment</span>

        <span class="k">def</span> <span class="nf">check_concatenated_ch</span><span class="p">(</span><span class="n">my_prone_ch_E0</span><span class="p">,</span> <span class="n">my_uni_inv_ch_E1</span><span class="p">,</span> <span class="n">my_prone_ch_E2</span><span class="p">,</span> <span class="n">my_prone_ch_external_E</span><span class="p">):</span>
            <span class="n">my_var_prop2ct_prop_E</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">my_vp_E</span><span class="p">,</span> <span class="n">my_cp_E0</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ch_model_E</span><span class="o">.</span><span class="n">input_prop</span><span class="p">,</span> <span class="n">my_prone_ch_E0</span><span class="o">.</span><span class="n">input_prop</span><span class="p">):</span>
                <span class="n">my_var_prop2ct_prop_E</span><span class="p">[</span><span class="n">my_vp_E</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_cp_E0</span>
            <span class="k">for</span> <span class="n">my_vp_E</span><span class="p">,</span> <span class="n">my_cp_E2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ch_model_E</span><span class="o">.</span><span class="n">output_prop</span><span class="p">,</span> <span class="n">my_prone_ch_E2</span><span class="o">.</span><span class="n">output_prop</span><span class="p">):</span>
                <span class="n">my_var_prop2ct_prop_E</span><span class="p">[</span><span class="n">my_vp_E</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_cp_E2</span>
            <span class="n">my_chfinder_E</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChFinder</span><span class="p">(</span>
                <span class="n">ch_model_E</span><span class="p">,</span> <span class="n">assert_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span>
                <span class="n">var_prop2ct_prop</span><span class="o">=</span><span class="n">my_var_prop2ct_prop_E</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">printing_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">solver_seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">vp_external_E</span><span class="p">,</span> <span class="n">cp_external_E</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ch_model_external_E</span><span class="o">.</span><span class="n">output_prop</span><span class="p">,</span> <span class="n">my_prone_ch_external_E</span><span class="o">.</span><span class="n">output_prop</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">vp_external_E</span><span class="o">.</span><span class="n">val</span> <span class="ow">in</span> <span class="n">my_chfinder_E</span><span class="o">.</span><span class="n">_vars_in_constraints</span><span class="p">:</span>
                        <span class="n">my_chfinder_E</span><span class="o">.</span><span class="n">initial_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">vp_external_E</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">cp_external_E</span><span class="o">.</span><span class="n">val</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">valid_ch_found_E</span> <span class="ow">in</span> <span class="n">my_chfinder_E</span><span class="o">.</span><span class="n">find_next_ch</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">aux_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - prone_ch_external_E: </span><span class="si">{</span><span class="n">my_prone_ch_external_E</span><span class="si">}</span><span class="s2">, &quot;</span> \
                              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">my_prone_ch_external_E</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aux_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;the concatenation of the last characteristic tuple found,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - prone_ch_E0: </span><span class="si">{</span><span class="n">my_prone_ch_E0</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">my_prone_ch_E0</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - uni_inv_ch_E1: </span><span class="si">{</span><span class="n">my_uni_inv_ch_E1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">my_uni_inv_ch_E1</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - prone_ch_E2: </span><span class="si">{</span><span class="n">my_prone_ch_E2</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">my_prone_ch_E2</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}{</span><span class="n">aux_str</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - ch_model E: </span><span class="si">{</span><span class="n">ch_model_E</span><span class="si">}</span><span class="se">\n</span><span class="s2"> - var_prop2ct_prop: </span><span class="si">{</span><span class="n">my_var_prop2ct_prop_E</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - ch_finder E: </span><span class="si">{</span><span class="n">my_chfinder_E</span><span class="o">.</span><span class="n">initial_constraints</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">my_chfinder_E</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">)</span><span class="si">}</span><span class="s2">,&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> is not universally-invalid (found compatible valid characteristic over E </span><span class="si">{</span><span class="n">valid_ch_found_E</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">my_chfinder_E</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">==</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span>

        <span class="c1">#  4. Search for probability-one characteristics</span>

        <span class="n">smart_print</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">_get_smart_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">prone_ch_assignment_external_E</span> <span class="ow">in</span> <span class="n">get_next_prone_ch_assignment_external_E</span><span class="p">():</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">prone_ch_assignment_external_E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aux_str_E</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux_str_E</span> <span class="o">=</span> <span class="s2">&quot; (and external E)&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;, </span><span class="si">{</span><span class="n">prone_ch_assignment_external_E</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="n">output_var2ct_external_E</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">out_var_eE</span> <span class="ow">in</span> <span class="n">ch_model_external_E</span><span class="o">.</span><span class="n">ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">:</span>
                    <span class="n">ct_val_eE</span> <span class="o">=</span> <span class="n">ch_model_external_E</span><span class="o">.</span><span class="n">var2prop</span><span class="p">[</span><span class="n">out_var_eE</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">prone_ch_assignment_external_E</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct_val_eE</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                    <span class="n">output_var2ct_external_E</span><span class="p">[</span><span class="n">out_var_eE</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct_val_eE</span>

                <span class="n">constraint_for_E1_from_external_E</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">external_var2ct_E1</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">ext_var_E1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="p">:</span>
                    <span class="n">constraint_for_E1_from_external_E</span> <span class="o">&amp;=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">ext_var_E1</span><span class="p">,</span> <span class="n">output_var2ct_external_E</span><span class="p">[</span><span class="n">ext_var_E1</span><span class="p">])</span>
                    <span class="n">external_var2ct_E1</span><span class="p">[</span><span class="n">ext_var_E1</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_var2ct_external_E</span><span class="p">[</span><span class="n">ext_var_E1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">prone_ch_assignment_E0</span> <span class="ow">in</span> <span class="n">get_next_prone_ch_assignment_E0</span><span class="p">(</span>
                    <span class="kc">None</span> <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">output_var2ct_external_E</span><span class="p">):</span>
                <span class="n">ct_outputs_E0</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">out_var_E0</span> <span class="ow">in</span> <span class="n">ch_model_E0</span><span class="o">.</span><span class="n">ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">:</span>
                    <span class="n">ct_val_E0</span> <span class="o">=</span> <span class="n">ch_model_E0</span><span class="o">.</span><span class="n">var2prop</span><span class="p">[</span><span class="n">out_var_E0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">prone_ch_assignment_E0</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct_val_E0</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                    <span class="n">ct_outputs_E0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ct_val_E0</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">prone_ch_assignment_E2</span> <span class="ow">in</span> <span class="n">get_next_prone_ch_assignment_E2</span><span class="p">(</span>
                        <span class="kc">None</span> <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">output_var2ct_external_E</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found probability-one characteristics over E0 and E2</span><span class="si">{</span><span class="n">aux_str_E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">: &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prone_ch_assignment_E0</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">prone_ch_assignment_E2</span><span class="si">}{</span><span class="n">aux_str_E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="n">ct_inputs_E2</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">in_var_E2</span> <span class="ow">in</span> <span class="n">ch_model_E2</span><span class="o">.</span><span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">:</span>
                        <span class="n">ct_val_E2</span> <span class="o">=</span> <span class="n">ch_model_E2</span><span class="o">.</span><span class="n">var2prop</span><span class="p">[</span><span class="n">in_var_E2</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">prone_ch_assignment_E2</span><span class="p">)</span>
                        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct_val_E2</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>
                        <span class="n">ct_inputs_E2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ct_val_E2</span><span class="p">)</span>

                    <span class="n">constraint_for_E1</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">constraint_for_E1_from_external_E</span>
                    <span class="n">solution_var2ct_E1</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span> <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">external_var2ct_E1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">var_prop_E1</span><span class="p">,</span> <span class="n">ct_val_E0</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">input_prop</span><span class="p">,</span> <span class="n">ct_outputs_E0</span><span class="p">):</span>
                        <span class="n">constraint_for_E1</span> <span class="o">&amp;=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">var_prop_E1</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">ct_val_E0</span><span class="p">)</span>
                        <span class="n">solution_var2ct_E1</span><span class="p">[</span><span class="n">var_prop_E1</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct_val_E0</span>
                    <span class="k">for</span> <span class="n">var_prop_E1</span><span class="p">,</span> <span class="n">ct_val_E2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">output_prop</span><span class="p">,</span> <span class="n">ct_inputs_E2</span><span class="p">):</span>
                        <span class="n">constraint_for_E1</span> <span class="o">&amp;=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">var_prop_E1</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">ct_val_E2</span><span class="p">)</span>
                        <span class="n">solution_var2ct_E1</span><span class="p">[</span><span class="n">var_prop_E1</span><span class="o">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ct_val_E2</span>

                    <span class="c1"># # debugging</span>
                    <span class="c1"># print(&quot;\nfind_next_invalidprop_miss_in_the_middle&quot;)</span>
                    <span class="c1"># print(&quot;ch_model_E0&quot;, ch_model_E0)</span>
                    <span class="c1"># print(&quot;ch model E1&quot;, self.ch_model)</span>
                    <span class="c1"># if hasattr(self.ch_model, &quot;_unwrapped_ch_model&quot;):</span>
                    <span class="c1">#     print(&quot;unwrapped ch model E1&quot;, self.ch_model._unwrapped_ch_model)</span>
                    <span class="c1"># print(&quot;ch_model_E2&quot;, ch_model_E2)</span>
                    <span class="c1"># if ch_model_external_E:</span>
                    <span class="c1">#     print(&quot;ch_model_external_E&quot;, ch_model_external_E)</span>
                    <span class="c1"># if ch_model_E:</span>
                    <span class="c1">#     print(&quot;ch_model_E&quot;, ch_model_E)</span>
                    <span class="c1"># print(&quot;self.chmodel_asserts:&quot;, self.chmodel_asserts)</span>
                    <span class="c1"># print(&quot;output_var2ct_external_E:&quot;, output_var2ct_external_E)</span>
                    <span class="c1"># print(&quot;external_var2ct_E1:&quot;, external_var2ct_E1)</span>
                    <span class="c1"># print(&quot;constraint_for_E1:&quot;, constraint_for_E1, &quot;\n&quot;)</span>
                    <span class="c1">#</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">solver_E1</span><span class="o">.</span><span class="n">solve</span><span class="p">([</span><span class="n">bv2pysmt_E1</span><span class="p">(</span><span class="n">constraint_for_E1</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">)]):</span>
                        <span class="n">uni_inv_ch_E1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_uni_inv_ch</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="o">=</span><span class="n">solution_var2ct_E1</span><span class="p">)</span>

                        <span class="n">prone_ch_E0</span> <span class="o">=</span> <span class="n">chfinder_E0</span><span class="o">.</span><span class="n">_pysmt_model2ch</span><span class="p">(</span><span class="n">prone_ch_assignment_E0</span><span class="p">,</span> <span class="n">is_pysmt_model</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="n">prone_ch_E2</span> <span class="o">=</span> <span class="n">chfinder_E2</span><span class="o">.</span><span class="n">_pysmt_model2ch</span><span class="p">(</span><span class="n">prone_ch_assignment_E2</span><span class="p">,</span> <span class="n">is_pysmt_model</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                        <span class="k">assert</span> <span class="n">prone_ch_E0</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prone_ch_E0</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">assert</span> <span class="n">prone_ch_E2</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prone_ch_E2</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">prone_ch_external_E</span> <span class="o">=</span> <span class="n">chfinder_external_E</span><span class="o">.</span><span class="n">_pysmt_model2ch</span><span class="p">(</span><span class="n">prone_ch_assignment_external_E</span><span class="p">,</span> <span class="n">is_pysmt_model</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                            <span class="k">assert</span> <span class="n">prone_ch_external_E</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prone_ch_external_E</span><span class="si">}</span><span class="s2">&quot;</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_universally_invalid_ch_found</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">uni_inv_ch_E1</span><span class="p">,</span> <span class="n">external_var2ct</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">external_var2ct_E1</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">ch_model_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">check_concatenated_ch</span><span class="p">(</span><span class="n">prone_ch_E0</span><span class="p">,</span> <span class="n">uni_inv_ch_E1</span><span class="p">,</span> <span class="n">prone_ch_E2</span><span class="p">,</span>
                                                      <span class="kc">None</span> <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">prone_ch_external_E</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">ch_model_external_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">prone_ch_E0</span><span class="p">,</span> <span class="n">uni_inv_ch_E1</span><span class="p">,</span> <span class="n">prone_ch_E2</span><span class="p">,</span> <span class="n">prone_ch_external_E</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">prone_ch_E0</span><span class="p">,</span> <span class="n">uni_inv_ch_E1</span><span class="p">,</span> <span class="n">prone_ch_E2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># no pr-one ch. found for E2, no need to find another E0</span>
                    <span class="k">break</span>

        <span class="n">solver_E1</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span></div>

<div class="viewcode-block" id="InvalidPropFinder.find_next_invalidprop_quantified_logic"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.InvalidPropFinder.find_next_invalidprop_quantified_logic">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_invalidprop_quantified_logic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that yields the universally-invalid characteristics found in the quantified SMT-based search.</span>

<span class="sd">        This method searches for universally-invalid characteristic using SMT problems</span>
<span class="sd">        in the quantified bit-vector logic (with the *ForAll* quantifier).</span>

<span class="sd">        Let :math:`P(\\alpha, \gamma_1, \dots, \gamma_t, \\beta)` be the</span>
<span class="sd">        underlying bit-vector formula of the decision problem</span>
<span class="sd">        of whether there exists a characteristic following the</span>
<span class="sd">        characteristic model ``ch_model`` with non-zero probability,</span>
<span class="sd">        where :math:`(\\alpha, \\beta)` is the input and output properties</span>
<span class="sd">        and :math:`(\gamma_1, \dots, \gamma_t)` are the intermediate properties.</span>

<span class="sd">        First, this method creates the decision problem of whether there exists</span>
<span class="sd">        an assignment of the input and output properties :math:`(\\alpha, \\beta)`</span>
<span class="sd">        such that for all intermediate properties :math:`(\gamma_1, \dots, \gamma_t)`</span>
<span class="sd">        the negation of :math:`P` is True; in other words, the decision problem</span>
<span class="sd">        given by the underlying quantified formula</span>
<span class="sd">        :math:`\exists \\alpha, \\beta, \\forall \gamma_1, \dots, \gamma_t : \  \\neg</span>
<span class="sd">        P(\\alpha, \gamma_1, \dots, \gamma_t, \\beta)`</span>

<span class="sd">        If the SMT solver finds the first problem satisfiable,</span>
<span class="sd">        an assignment of the input and output properties :math:`(\\alpha, \\beta)`</span>
<span class="sd">        that makes :math:`\\neg P(\\alpha, \gamma_1, \dots, \gamma_t, \\beta) = True` is</span>
<span class="sd">        obtained, and a universally-invalid `abstractproperty.characteristic.Characteristic`</span>
<span class="sd">        object is created and *yielded*.</span>

<span class="sd">        Afterwards, an additional constraint is added to the SMT problem</span>
<span class="sd">        to exclude the characteristic yielded and this procedure is repeated</span>
<span class="sd">        until all characteristics are found.</span>

<span class="sd">        This method requires that the SMT solver given in ``solver_name``</span>
<span class="sd">        supports the bit-vector logic with quantifiers.</span>
<span class="sd">        Although the recent version of boolector supports the bit-vector logic</span>
<span class="sd">        with quantifiers, pySMT does not support yet this recent feature</span>
<span class="sd">        of boolector.</span>

<span class="sd">            &gt;&gt;&gt; # example of search for universally-invalid XorDiff-EncryptionCharacteristic of (wrapped) Speck32</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.chmodel import EncryptionChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.smt.invalidpropsearch import InvalidPropFinder</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">            &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; wrapped_ch_model = get_wrapped_chmodel(EncryptionChModel(Speck32, XorDiff))</span>
<span class="sd">            &gt;&gt;&gt; invalid_prop_finder = InvalidPropFinder(wrapped_ch_model, &quot;z3&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; for i, ch in enumerate(invalid_prop_finder.find_next_invalidprop_quantified_logic()):</span>
<span class="sd">            ...     print(ch.srepr())</span>
<span class="sd">            ...     if i == 2: break  # doctest: +ELLIPSIS</span>
<span class="sd">            Ch(w=Infinity, id=..., od=...)</span>
<span class="sd">            Ch(w=Infinity, id=..., od=...)</span>
<span class="sd">            Ch(w=Infinity, id=..., od=...)</span>
<span class="sd">            &gt;&gt;&gt; # example of SMT problem of universally-invalid RXDiff-Characteristic of Speck32-KeySchedule</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.chmodel import ChModel</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS.set_num_rounds(1)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, RXDiff, [&quot;mk0&quot;, &quot;mk1&quot;])</span>
<span class="sd">            &gt;&gt;&gt; invalid_prop_finder = InvalidPropFinder(ch_model, &quot;z3&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; for i, ch in enumerate(invalid_prop_finder.find_next_invalidprop_quantified_logic()):</span>
<span class="sd">            ...     print(ch.srepr())</span>
<span class="sd">            ...     if i == 2: break  # doctest: +ELLIPSIS</span>
<span class="sd">            Ch(w=Infinity, id=..., od=...)</span>
<span class="sd">            Ch(w=Infinity, id=..., od=...)</span>
<span class="sd">            Ch(w=Infinity, id=..., od=...)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">smart_print</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">_get_smart_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

        <span class="c1"># InputOutput contains _input_vars_not_used</span>
        <span class="n">in_out_sig_type</span> <span class="o">=</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">ChModelSigType</span><span class="o">.</span><span class="n">InputOutput</span>
        <span class="n">symbolic_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">in_out_sig_type</span><span class="p">)</span>

        <span class="c1"># initializing the solver</span>

        <span class="n">parse_shifts_rotations</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">bv2pysmt</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">pysmttypes</span><span class="o">.</span><span class="n">bv2pysmt</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">,</span> <span class="n">parse_shifts_rotations</span><span class="o">=</span><span class="n">parse_shifts_rotations</span><span class="p">)</span>

        <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">==</span> <span class="s2">&quot;btor&quot;</span><span class="p">:</span>
                <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;solver_options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;seed&quot;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span><span class="p">}}</span>  <span class="c1"># btor seed uint32</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;random_seed&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span><span class="p">}</span>
        <span class="n">solver</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">factory</span><span class="o">.</span><span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span> <span class="n">logic</span><span class="o">=</span><span class="n">logics</span><span class="o">.</span><span class="n">BV</span><span class="p">,</span> <span class="o">**</span><span class="n">solver_kwargs</span><span class="p">)</span>

        <span class="c1">#</span>

        <span class="n">compact_constraint</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">):</span>
            <span class="n">compact_constraint</span> <span class="o">&amp;=</span> <span class="n">c</span>

        <span class="n">in_out_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_input_prop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_output_prop</span><span class="p">)]</span>
        <span class="n">forall_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vars_in_constraints</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_out_vars</span><span class="p">]</span>

        <span class="n">pysmt_formula</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="o">.</span><span class="n">formula_manager</span><span class="o">.</span><span class="n">ForAll</span><span class="p">(</span>
            <span class="p">[</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">forall_vars</span><span class="p">],</span>
            <span class="n">bv2pysmt</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvNot</span><span class="p">(</span><span class="n">compact_constraint</span><span class="p">),</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># # debugging</span>
        <span class="c1"># print(&quot;\nfind_next_invalidprop_quantified_logic&quot;)</span>
        <span class="c1"># print(&quot;ch model:&quot;, self.ch_model)</span>
        <span class="c1"># print(&quot;compact_constraint:&quot;, compact_constraint)</span>
        <span class="c1"># print(&quot;in_out_vars:&quot;, in_out_vars)</span>
        <span class="c1"># print(&quot;forall_vars:&quot;, forall_vars)</span>
        <span class="c1"># print(&quot;pysmt_formula:&quot;, pysmt_formula.serialize(), &quot;\n&quot;)</span>
        <span class="c1">#</span>

        <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">pysmt_formula</span><span class="p">)</span>

        <span class="n">last_ch_found</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">last_ch_found</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbolic_sig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;empty signature of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="n">last_ch_sig</span> <span class="o">=</span> <span class="n">last_ch_found</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">in_out_sig_type</span><span class="p">)</span>
                <span class="c1"># disable simplification due to recursion error</span>
                <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
                    <span class="n">exclude_last_ch</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span>
                        <span class="n">operation</span><span class="o">.</span><span class="n">BvOr</span><span class="p">,</span>
                        <span class="p">[</span><span class="o">~</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">ls</span><span class="p">)</span> <span class="k">for</span> <span class="n">ss</span><span class="p">,</span> <span class="n">ls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">symbolic_sig</span><span class="p">,</span> <span class="n">last_ch_sig</span><span class="p">)]</span>
                    <span class="p">)</span>
                <span class="n">solver</span><span class="o">.</span><span class="n">add_assertion</span><span class="p">(</span><span class="n">bv2pysmt</span><span class="p">(</span><span class="n">exclude_last_ch</span><span class="p">,</span> <span class="n">boolean</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;exclude_last_ch: </span><span class="si">{</span><span class="n">exclude_last_ch</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">satisfiable</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">satisfiable</span><span class="p">:</span>
                <span class="n">solution_var2ct</span> <span class="o">=</span> <span class="n">pysmttypes</span><span class="o">.</span><span class="n">pysmt_model2bv_model</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">get_model</span><span class="p">())</span>

                <span class="c1"># add missing input-output vars</span>
                <span class="n">in_out_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_input_prop</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_output_prop</span><span class="p">]</span>
                <span class="n">missing_in_out_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">in_out_vars</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solution_var2ct</span><span class="p">:</span>
                        <span class="n">missing_in_out_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">solution_var2ct</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">missing_in_out_vars</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">):</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found solution of quantified SMT problem for all values of </span><span class="si">{</span><span class="n">missing_in_out_vars</span><span class="si">}</span><span class="s2">; &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;setting </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">missing_in_out_vars</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;to 0 in yielded universally-invalid characteristic&quot;</span><span class="p">)</span>

                <span class="n">last_ch_found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_uni_inv_ch</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="o">=</span><span class="n">solution_var2ct</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_universally_invalid_ch_found</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">last_ch_found</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">last_ch_found</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">solver</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span></div>

<div class="viewcode-block" id="InvalidPropFinder.hrepr"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.InvalidPropFinder.hrepr">[docs]</a>    <span class="k">def</span> <span class="nf">hrepr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_repr</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a human-readable representation of the base SMT problem.</span>

<span class="sd">        The base SMT problem is the decision problem of whether there exists</span>
<span class="sd">        a valid characteristic for an input-output property pair.</span>
<span class="sd">        In other words, it contains the validity assertions</span>
<span class="sd">        of the underlying characteristic model.</span>

<span class="sd">        The methods `InvalidPropFinder.find_next_invalidprop_activebitmode` and</span>
<span class="sd">        `InvalidPropFinder.find_next_invalidprop_miss_in_the_middle` check</span>
<span class="sd">        for the unsatisfiability of this base SMT problem</span>
<span class="sd">        (with some additional constraints),</span>
<span class="sd">        while `InvalidPropFinder.find_next_invalidprop_quantified_logic`</span>
<span class="sd">        uses this base SMT problem to create a quantified</span>
<span class="sd">        bit-vector formula.</span>

<span class="sd">        If ``full_repr`` is False, the short string representation srepr is used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">hrepr</span><span class="p">(</span><span class="n">full_repr</span><span class="o">=</span><span class="n">full_repr</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="InvalidCipherPropFinder"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.InvalidCipherPropFinder">[docs]</a><span class="k">class</span> <span class="nc">InvalidCipherPropFinder</span><span class="p">(</span><span class="n">InvalidPropFinder</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search for invalid properties of ciphers by modeling the search as a sequence of SMT problems.</span>

<span class="sd">    Given a characteristic model of a `Cipher`</span>
<span class="sd">    (`abstractproperty.chmodel.CipherChModel`)</span>
<span class="sd">    defined for a particular `Property` (e.g., `XorDiff` or `RXDiff`),</span>
<span class="sd">    this class finds *universally-invalid* cipher characteristics</span>
<span class="sd">    (`abstractproperty.characteristic.CipherCharacteristic`)</span>
<span class="sd">    following the characteristic model by modelling the search</span>
<span class="sd">    as a sequence of SMT problems in the bit-vector theory.</span>

<span class="sd">    Given a cipher characteristic, let :math:`\\alpha_{KS}` be the input</span>
<span class="sd">    property of the underlying key-schedule characteristic</span>
<span class="sd">    and :math:`(\\alpha_{ENC}, \\beta_{ENC})` be the input and output</span>
<span class="sd">    properties of the underlying encryption characteristic.</span>
<span class="sd">    A universally-invalid characteristic</span>
<span class="sd">    over a cipher is a characteristic where</span>
<span class="sd">    :math:`(\\alpha_{KS}, \\alpha_{ENC})` propagates to :math:`\\beta_{ENC}`</span>
<span class="sd">    with probability zero regardless of the intermediate properties.</span>
<span class="sd">    In other words, the input-output property pair</span>
<span class="sd">    :math:`((\\alpha_{KS}, \\alpha_{ENC}), \\beta_{ENC})`</span>
<span class="sd">    has zero propagation probability.</span>

<span class="sd">    .. note::</span>
<span class="sd">        For the `Difference` property,</span>
<span class="sd">        a universally-invalid characteristic over a cipher is actually a</span>
<span class="sd">        related-key impossible differential.</span>

<span class="sd">    To initialize an `InvalidCipherPropFinder` object, first two auxiliary</span>
<span class="sd">    instances of `InvalidPropFinder` are created:</span>

<span class="sd">    - ``ks_finder`` an `InvalidPropFinder` with characteristic model</span>
<span class="sd">      ``ch_model.ks_ch_model``</span>
<span class="sd">    - ``enc_finder`` an `InvalidPropFinder` with characteristic model</span>
<span class="sd">      ``ch_model.enc_ch_model``</span>

<span class="sd">    Both ``ks_finder`` and ``enc_finder`` (together with the</span>
<span class="sd">    `InvalidCipherPropFinder` object) share the arguments `solver_name`,</span>
<span class="sd">    `printing_mode`, `filename`,  `solver_seed` and `env`.</span>

<span class="sd">    Then, these two auxiliary `InvalidPropFinder` objects are merged into an</span>
<span class="sd">    `InvalidCipherPropFinder` (which is also an instance of `InvalidPropFinder`)</span>
<span class="sd">    as follows:</span>

<span class="sd">    - ``solver_name``, ``printing_mode``, ``filename``,  ``solver_seed``</span>
<span class="sd">      ``env`` are the same as the ones from ``ks_finder`` and ``enc_finder``</span>
<span class="sd">    - ``ch_model`` is set to the characteristic model of the cipher</span>
<span class="sd">      (a subclass of `abstractproperty.chmodel.CipherChModel`)</span>
<span class="sd">    - ``chmodel_asserts`` is the union of `chmodel_asserts` of</span>
<span class="sd">      ``ks_finder`` and ``enc_finder``</span>

<span class="sd">    See also `ChFinder`.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.chmodel import CipherChModel</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.invalidpropsearch import InvalidCipherPropFinder, get_wrapped_cipher_chmodel</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">        &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">        &gt;&gt;&gt; ch_model = get_wrapped_cipher_chmodel(CipherChModel(Speck32, XorDiff))</span>
<span class="sd">        &gt;&gt;&gt; invalid_prop_finder = InvalidCipherPropFinder(ch_model, &quot;btor&quot;, solver_seed=0)</span>
<span class="sd">        &gt;&gt;&gt; invalid_prop_finder.formula_size()</span>
<span class="sd">        177</span>
<span class="sd">        &gt;&gt;&gt; print(invalid_prop_finder.hrepr(full_repr=False))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        ; characteristic model assertions</span>
<span class="sd">        assert (_dk0 == (dk3_out :: dmk1_out)) &amp; ((... &amp; ... &amp; (... ^ ...)) == 0x0000) &amp;</span>
<span class="sd">            (_dmk1 == dmk1_out) &amp; (((_dmk1 &lt;&lt;&lt; 2) ^ dk1) == dk3_out)</span>
<span class="sd">        assert PropExtract_{·, 15, 0}(_dk0) == _dk1_out</span>
<span class="sd">        assert PropExtract_{·, 31, 16}(_dk0) == _dk2_out</span>
<span class="sd">        assert (_dx0 == (dx9_out :: dx7_out)) &amp; ((... &amp; ...) == 0x0000) &amp; ((... &amp; ...) == 0x0000) &amp;</span>
<span class="sd">            ((dx6 ^ _dk2_out) == dx7_out) &amp; ((((... ^ ...) &lt;&lt;&lt; 2) ^ dx6 ^ _dk2_out) == dx9_out)</span>
<span class="sd">        assert PropExtract_{·, 15, 0}(_dx0) == _dx1_out</span>
<span class="sd">        assert PropExtract_{·, 31, 16}(_dx0) == _dx2_out</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ch_model</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span> <span class="n">check_universally_invalid_ch_found</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">printing_mode</span><span class="o">=</span><span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">solver_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">CipherChModel</span><span class="p">)</span>

        <span class="n">ks_finder</span> <span class="o">=</span> <span class="n">InvalidPropFinder</span><span class="p">(</span>
            <span class="n">ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="n">solver_name</span><span class="p">,</span>
            <span class="n">check_universally_invalid_ch_found</span><span class="o">=</span><span class="n">check_universally_invalid_ch_found</span><span class="p">,</span>
            <span class="n">printing_mode</span><span class="o">=</span><span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">env</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">enc_finder</span> <span class="o">=</span> <span class="n">InvalidPropFinder</span><span class="p">(</span>
            <span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="n">solver_name</span><span class="p">,</span>
            <span class="n">check_universally_invalid_ch_found</span><span class="o">=</span><span class="n">check_universally_invalid_ch_found</span><span class="p">,</span>
            <span class="n">printing_mode</span><span class="o">=</span><span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">env</span><span class="o">=</span><span class="n">ks_finder</span><span class="o">.</span><span class="n">env</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">assert</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">env</span> <span class="o">==</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">env</span>
        <span class="k">assert</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">Validity</span>
        <span class="k">assert</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">==</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">Validity</span>
        <span class="k">assert</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_ch_weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_error</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_ch_weight</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_error</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_exclude_zero_input_prop</span> <span class="ow">is</span> <span class="kc">False</span>
        <span class="k">assert</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_exclude_zero_input_prop</span> <span class="ow">is</span> <span class="kc">False</span>

        <span class="n">ch_weight</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">assert_type</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">Validity</span>
        <span class="n">exclude_zero_input_prop</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">chmodel_asserts</span> <span class="o">+</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">chmodel_asserts</span>
        <span class="n">vars_in_constraints</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">_vars_in_constraints</span> <span class="o">|</span> <span class="n">enc_finder</span><span class="o">.</span><span class="n">_vars_in_constraints</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ks_finder</span> <span class="o">=</span> <span class="n">ks_finder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enc_finder</span> <span class="o">=</span> <span class="n">enc_finder</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span> <span class="o">=</span> <span class="n">ch_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span> <span class="o">=</span> <span class="n">assert_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span> <span class="o">=</span> <span class="n">solver_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">=</span> <span class="n">printing_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_prefix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span> <span class="o">=</span> <span class="n">solver_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">=</span> <span class="n">ks_finder</span><span class="o">.</span><span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chmodel_asserts</span> <span class="o">=</span> <span class="n">chmodel_asserts</span>

        <span class="c1"># variables not added in docstring (private variables)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exclude_zero_input_prop</span> <span class="o">=</span> <span class="n">exclude_zero_input_prop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_prop2ct_prop</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ch_weight</span> <span class="o">=</span> <span class="n">ch_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_error</span> <span class="o">=</span> <span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vars_in_constraints</span> <span class="o">=</span> <span class="n">vars_in_constraints</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">check_universally_invalid_ch_found</span> <span class="o">=</span> <span class="n">check_universally_invalid_ch_found</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ch_model_input_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">input_prop</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">input_prop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ch_model_output_prop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">output_prop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ch_model_assign_outprop2op_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">assign_outprop2op_model</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">assign_outprop2op_model</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_ch_model_prop_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">_prop_label</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">_prop_label</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">_prop_label</span>

    <span class="k">def</span> <span class="nf">_pysmt_model2ch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_var2ct</span><span class="p">,</span> <span class="n">target_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_pysmt_model</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">is_sat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">target_weight</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">is_sat</span> <span class="ow">is</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">is_pysmt_model</span><span class="p">:</span>
            <span class="n">solution_var2ct</span> <span class="o">=</span> <span class="n">pysmttypes</span><span class="o">.</span><span class="n">pysmt_model2bv_model</span><span class="p">(</span><span class="n">solution_var2ct</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">solution_var2ct</span> <span class="o">=</span> <span class="n">solution_var2ct</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_get_needed_vars</span><span class="p">(</span><span class="n">my_ch_model</span><span class="p">):</span>
            <span class="n">var_needed</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">input_prop</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">ssa</span><span class="o">.</span><span class="n">_input_vars_not_used</span><span class="p">]</span>
            <span class="c1"># # ks_ch_model has no external vars and enc_ch_model gets those from ks_ch_model.output</span>
            <span class="c1"># for ext_var, prop in my_ch_model.external_var2prop.items():</span>
            <span class="c1">#     if not isinstance(prop.val, core.Constant):</span>
            <span class="c1">#         var_needed.append(ext_var)</span>
            <span class="k">for</span> <span class="n">outprop</span><span class="p">,</span> <span class="n">op_model</span> <span class="ow">in</span> <span class="n">my_ch_model</span><span class="o">.</span><span class="n">assign_outprop2op_model</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># if op_model.max_weight() != 0:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">ModelIdentity</span><span class="p">):</span>
                    <span class="n">var_needed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outprop</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">var_needed</span>

        <span class="k">def</span> <span class="nf">get_needed_vars</span><span class="p">(</span><span class="n">my_cipher_ch_model</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_get_needed_vars</span><span class="p">(</span><span class="n">my_cipher_ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="p">)</span> <span class="o">+</span> <span class="n">_get_needed_vars</span><span class="p">(</span><span class="n">my_cipher_ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="p">)</span>

        <span class="n">missing_signature_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">get_needed_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">solution_var2ct</span><span class="p">:</span>
                <span class="n">missing_signature_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="n">solution_var2ct</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="c1"># universally-invalid characteristics are invalid regardless of non-input non-output properties</span>
        <span class="n">in_out_vars</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_input_prop</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ch_model_output_prop</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_signature_vars</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span> <span class="ow">or</span>
                <span class="nb">any</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">in_out_vars</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">missing_signature_vars</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">smart_print</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">_get_smart_print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="s1">&#39;satisfiable&#39;</span> <span class="k">if</span> <span class="n">is_sat</span> <span class="k">else</span> <span class="s1">&#39;unsatisfiable&#39;</span><span class="si">}</span><span class="s2"> assignment &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;of SMT problem for all values of </span><span class="si">{</span><span class="n">missing_signature_vars</span><span class="si">}</span><span class="s2">; &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;setting </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">prop_type</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> of </span><span class="si">{</span><span class="n">missing_signature_vars</span><span class="si">}</span><span class="s2"> &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;to 0 in yielded characteristic&quot;</span><span class="p">)</span>

        <span class="c1"># if target_weight is not None and \</span>
        <span class="c1">#    [...]</span>

        <span class="n">CipherCharacteristic_cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_get_CipherCharacteristic_cls</span><span class="p">()</span>

        <span class="n">init_props</span> <span class="o">=</span> <span class="n">CipherCharacteristic_cls</span><span class="o">.</span><span class="n">get_properties_for_initialization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">solution_var2ct</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_props</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span>
        <span class="n">ks_input_prop</span><span class="p">,</span> <span class="n">ks_output_prop</span><span class="p">,</span> <span class="n">ks_assign_outprop_list</span> <span class="o">=</span> <span class="n">init_props</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">enc_input_prop</span><span class="p">,</span> <span class="n">enc_output_prop</span><span class="p">,</span> <span class="n">enc_assign_outprop_list</span> <span class="o">=</span> <span class="n">init_props</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>

        <span class="c1"># # debugging</span>
        <span class="c1"># print(&quot;InvalidCipherProp._pysmt_model2ch&quot;)</span>
        <span class="c1"># print(&quot;ch model:&quot;, self.ch_model)</span>
        <span class="c1"># print(&quot;ks ssa:&quot;, self.ch_model.ks_ch_model.ssa)</span>
        <span class="c1"># print(&quot;enc ssa:&quot;, self.ch_model.enc_ch_model.ssa)</span>
        <span class="c1"># print(&quot;solution_var2ct:&quot;, solution_var2ct)</span>
        <span class="c1"># print(&quot;needed vars:&quot;, get_needed_vars(self.ch_model))</span>
        <span class="c1"># print(&quot;get_properties_for_initialization():&quot;, init_props, &quot;\n&quot;)</span>
        <span class="c1">#</span>

        <span class="c1"># avoid *_props=*_props (super might not abstract)</span>
        <span class="n">last_ch_found</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">ks_is_sat</span><span class="p">,</span> <span class="n">enc_is_sat</span> <span class="ow">in</span> <span class="p">[[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">last_ch_found</span> <span class="o">=</span> <span class="n">CipherCharacteristic_cls</span><span class="p">(</span>
                    <span class="n">ks_input_prop</span><span class="p">,</span>
                    <span class="n">ks_output_prop</span><span class="p">,</span>
                    <span class="n">ks_assign_outprop_list</span><span class="p">,</span>
                    <span class="n">enc_input_prop</span><span class="p">,</span>
                    <span class="n">enc_output_prop</span><span class="p">,</span>
                    <span class="n">enc_assign_outprop_list</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span>
                    <span class="c1"># ks_free_props,</span>
                    <span class="c1"># enc_free_props,</span>
                    <span class="n">ks_empirical_ch_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">ks_empirical_data_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">enc_empirical_ch_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">enc_empirical_data_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">ks_is_valid</span><span class="o">=</span><span class="n">ks_is_sat</span><span class="p">,</span>
                    <span class="n">enc_is_valid</span><span class="o">=</span><span class="n">enc_is_sat</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span>  <span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">InvalidOpModelError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;is_valid&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">last_ch_found</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">[</span><span class="n">ks_is_sat</span><span class="p">,</span> <span class="n">enc_is_sat</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SMT solution </span><span class="si">{</span><span class="n">solution_var2ct</span><span class="si">}</span><span class="s2"> leads to a valid characteristic&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">last_ch_found</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no characteristic can be built from SMT solution </span><span class="si">{</span><span class="n">solution_var2ct</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">last_ch_found</span><span class="p">,</span> <span class="n">CipherCharacteristic_cls</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">last_ch_found</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># assert not (self.ks_finder.assert_type == chsearch.ChModelAssertType.ProbabilityOne</span>
        <span class="c1">#     [...]</span>

        <span class="c1"># for i, aux_finder in enumerate([self.ks_finder, self.enc_finder]):</span>
        <span class="c1">#     [...]  # _exclude_zero_input_prop</span>

        <span class="c1"># for var_prop, ct_prop in itertools.chain(</span>
        <span class="c1">#     [...]</span>

        <span class="c1"># if self._var_prop2ct_prop:</span>
        <span class="c1">#     [...]</span>

        <span class="c1"># # ignored due to new solution_var2ct</span>
        <span class="c1"># with context.Simplification(False):</span>
        <span class="c1">#     chmodel_asserts = [a.xreplace(solution_var2ct) for a in self.chmodel_asserts]</span>

        <span class="c1"># if target_weight is not None:</span>
        <span class="c1">#     [...]</span>

        <span class="k">return</span> <span class="n">last_ch_found</span>

    <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invalid_cipher_ch_found</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span> <span class="o">==</span> <span class="n">invalid_cipher_ch_found</span><span class="o">.</span><span class="n">cipher_ch_model</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="s2">&quot;_unwrapped_cipher_ch_model&quot;</span><span class="p">):</span>
            <span class="n">list_cipher_ch_model</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">_unwrapped_cipher_ch_model</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">_unwrapped_cipher_ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">external_var2prop</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">list_cipher_ch_model</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">]</span>

        <span class="c1"># avoid self._ch_model_input_prop since we also have self.ch_model._unwrapped_cipher_ch_model</span>

        <span class="k">def</span> <span class="nf">get_input_prop</span><span class="p">(</span><span class="n">ch_or_ch_model</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_or_ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">characteristic</span><span class="o">.</span><span class="n">CipherCharacteristic</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ch_or_ch_model</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">input_prop</span> <span class="o">+</span> \
                       <span class="n">ch_or_ch_model</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">input_prop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_or_ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">CipherChModel</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ch_or_ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">input_prop</span> <span class="o">+</span> \
                       <span class="n">ch_or_ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">input_prop</span>

        <span class="k">def</span> <span class="nf">get_output_prop</span><span class="p">(</span><span class="n">ch_or_ch_model</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_or_ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">characteristic</span><span class="o">.</span><span class="n">CipherCharacteristic</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ch_or_ch_model</span><span class="o">.</span><span class="n">ks_characteristic</span><span class="o">.</span><span class="n">output_prop</span> <span class="o">+</span> \
                       <span class="n">ch_or_ch_model</span><span class="o">.</span><span class="n">enc_characteristic</span><span class="o">.</span><span class="n">output_prop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_or_ch_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">chmodel</span><span class="o">.</span><span class="n">CipherChModel</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ch_or_ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">output_prop</span> <span class="o">+</span> \
                       <span class="n">ch_or_ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">output_prop</span>

        <span class="k">for</span> <span class="n">cipher_ch_model</span> <span class="ow">in</span> <span class="n">list_cipher_ch_model</span><span class="p">:</span>
            <span class="n">var_prop2ct_prop</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">vp</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">get_input_prop</span><span class="p">(</span><span class="n">cipher_ch_model</span><span class="p">),</span> <span class="n">get_input_prop</span><span class="p">(</span><span class="n">invalid_cipher_ch_found</span><span class="p">)):</span>
                <span class="n">var_prop2ct_prop</span><span class="p">[</span><span class="n">vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span>
            <span class="k">for</span> <span class="n">vp</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">get_output_prop</span><span class="p">(</span><span class="n">cipher_ch_model</span><span class="p">),</span> <span class="n">get_output_prop</span><span class="p">(</span><span class="n">invalid_cipher_ch_found</span><span class="p">)):</span>
                <span class="n">var_prop2ct_prop</span><span class="p">[</span><span class="n">vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span>
            <span class="n">cipher_ch_finder</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">CipherChFinder</span><span class="p">(</span>
                <span class="n">cipher_ch_model</span><span class="p">,</span> <span class="n">ks_assert_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span><span class="p">,</span> <span class="n">enc_assert_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">assert_type</span><span class="p">,</span>
                <span class="n">solver_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_name</span><span class="p">,</span> <span class="n">var_prop2ct_prop</span><span class="o">=</span><span class="n">var_prop2ct_prop</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">printing_mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">printing_mode</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">solver_seed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver_seed</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">valid_cipher_ch_found</span> <span class="ow">in</span> <span class="n">cipher_ch_finder</span><span class="o">.</span><span class="n">find_next_ch</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;last characteristic found </span><span class="si">{</span><span class="n">invalid_cipher_ch_found</span><span class="si">}</span><span class="s2"> in the search is not &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;universally-invalid (found compatible valid characteristic </span><span class="si">{</span><span class="n">valid_cipher_ch_found</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">cipher_ch_finder</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_env</span> <span class="o">==</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">environment</span><span class="o">.</span><span class="n">get_env</span><span class="p">()</span>

<div class="viewcode-block" id="InvalidCipherPropFinder.find_next_invalidprop_activebitmode"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.InvalidCipherPropFinder.find_next_invalidprop_activebitmode">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_invalidprop_activebitmode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_num_active_bits</span><span class="p">,</span> <span class="n">input_prop_activebitmode</span><span class="p">,</span> <span class="n">output_prop_activebitmode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that yields the universally-invalid characteristics found in the SMT-based search</span>
<span class="sd">        with given `ActiveBitMode`.</span>

<span class="sd">        This method is similar to `InvalidPropFinder.find_next_invalidprop_activebitmode`;</span>
<span class="sd">        the only difference is that the input property considered by this method</span>
<span class="sd">        is the concatenation of the input property of the underlying key-schedule</span>
<span class="sd">        characteristic and the input property of the underlying encryption</span>
<span class="sd">        characteristic, and the output property considered by this method</span>
<span class="sd">        is the output property of the encryption characteristic.</span>
<span class="sd">        In other words, ``output_prop_activebitmode`` only affects</span>
<span class="sd">        to the output property of the encryption characteristic</span>
<span class="sd">        and not to the output property of the key-schedule characteristic.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.chmodel import CipherChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.smt.invalidpropsearch import InvalidCipherPropFinder, ActiveBitMode, get_wrapped_cipher_chmodel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">            &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = get_wrapped_cipher_chmodel(CipherChModel(Speck32, XorDiff))</span>
<span class="sd">            &gt;&gt;&gt; invalid_prop_finder = InvalidCipherPropFinder(ch_model, &quot;btor&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; inab, ipabm, opabm = 1, ActiveBitMode.MSBit, ActiveBitMode.Zero</span>
<span class="sd">            &gt;&gt;&gt; for ch in invalid_prop_finder.find_next_invalidprop_activebitmode(inab, ipabm, opabm):</span>
<span class="sd">            ...     print(ch.srepr())</span>
<span class="sd">            Ch(ks_ch=Ch(w=Infinity, id=8000 0000, od=0000 0000), enc_ch=Ch(w=0, id=0000 0000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=Infinity, id=0000 8000, od=0000 0000), enc_ch=Ch(w=0, id=0000 0000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=0, id=0000 0000, od=0000 0000), enc_ch=Ch(w=Infinity, id=8000 0000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=0, id=0000 0000, od=0000 0000), enc_ch=Ch(w=Infinity, id=0000 8000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=Infinity, id=8000 8000, od=0000 0000), enc_ch=Ch(w=0, id=0000 0000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=Infinity, id=8000 0000, od=0000 0000), enc_ch=Ch(w=Infinity, id=8000 0000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=Infinity, id=8000 0000, od=0000 0000), enc_ch=Ch(w=Infinity, id=0000 8000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=0, id=0000 8000, od=8000 8002), enc_ch=Ch(w=Infinity, id=8000 0000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=0, id=0000 8000, od=8000 8002), enc_ch=Ch(w=Infinity, id=0000 8000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=0, id=0000 0000, od=0000 0000), enc_ch=Ch(w=Infinity, id=8000 8000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=Infinity, id=8000 8000, od=0000 0000), enc_ch=Ch(w=Infinity, id=8000 0000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=Infinity, id=8000 8000, od=0000 0000), enc_ch=Ch(w=Infinity, id=0000 8000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=Infinity, id=8000 0000, od=0000 0000), enc_ch=Ch(w=Infinity, id=8000 8000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=0, id=0000 8000, od=8000 8002), enc_ch=Ch(w=Infinity, id=8000 8000, od=0000 0000))</span>
<span class="sd">            Ch(ks_ch=Ch(w=Infinity, id=8000 8000, od=0000 0000), enc_ch=Ch(w=Infinity, id=8000 8000, od=0000 0000))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">find_next_invalidprop_activebitmode</span><span class="p">(</span>
            <span class="n">initial_num_active_bits</span><span class="p">,</span> <span class="n">input_prop_activebitmode</span><span class="p">,</span> <span class="n">output_prop_activebitmode</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="InvalidCipherPropFinder.find_next_invalidprop_miss_in_the_middle"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.InvalidCipherPropFinder.find_next_invalidprop_miss_in_the_middle">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_invalidprop_miss_in_the_middle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method is disabled, see `round_based_invalidcipherprop_search` for an alternative.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;find_next_invalidprop_miss_in_the_middle is disabled in InvalidCipherPropFinder,&quot;</span>
                                  <span class="s2">&quot;see round_based_invalidcipherprop_search&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="InvalidCipherPropFinder.find_next_invalidprop_quantified_logic"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.InvalidCipherPropFinder.find_next_invalidprop_quantified_logic">[docs]</a>    <span class="k">def</span> <span class="nf">find_next_invalidprop_quantified_logic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator that yields the universally-invalid characteristics found in the quantified SMT-based search.</span>

<span class="sd">        See also `InvalidPropFinder.find_next_invalidprop_quantified_logic`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.chmodel import CipherChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.smt.invalidpropsearch import InvalidCipherPropFinder, get_wrapped_cipher_chmodel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">            &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = get_wrapped_cipher_chmodel(CipherChModel(Speck32, RXDiff))</span>
<span class="sd">            &gt;&gt;&gt; invalid_prop_finder = InvalidCipherPropFinder(ch_model, &quot;z3&quot;, solver_seed=0)</span>
<span class="sd">            &gt;&gt;&gt; uni_inv_ch = next(invalid_prop_finder.find_next_invalidprop_quantified_logic())</span>
<span class="sd">            &gt;&gt;&gt; print(uni_inv_ch)  # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS</span>
<span class="sd">            CipherCharacteristic(ks_characteristic=Characteristic(ch_weight=...,</span>
<span class="sd">                assignment_weights=[..., ..., ...],</span>
<span class="sd">                input_diff=[..., ...], output_diff=[..., ...],</span>
<span class="sd">                assign_outdiff_list=[..., ..., ...]),</span>
<span class="sd">            enc_characteristic=Characteristic(ch_weight=...,</span>
<span class="sd">                assignment_weights=[..., ..., ...],</span>
<span class="sd">                input_diff=[..., ...], output_diff=[..., ...], external_diffs=[..., ...],</span>
<span class="sd">                assign_outdiff_list=[..., ..., ...]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">find_next_invalidprop_quantified_logic</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="round_based_invalidprop_search"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.round_based_invalidprop_search">[docs]</a><span class="k">def</span> <span class="nf">round_based_invalidprop_search</span><span class="p">(</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">initial_num_rounds</span><span class="p">,</span> <span class="n">final_num_rounds</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span>
        <span class="n">max_num_skipped_rounds</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_num_E0_rounds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_num_E2_rounds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">extra_chmodel_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># op_model_class2options,</span>
        <span class="n">extra_invalidpropfinder_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># pm, fn, env, solver_seed</span>
        <span class="n">exclude_zero_input_prop_E0</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">exclude_zero_input_prop_E2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>  <span class="c1"># exclude_zero_input_prop_external_E, find_cipher_invalid_prop</span>
        <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search for zero-probability (invalid) property pairs of round-based functions over multiple number of rounds.</span>

<span class="sd">    This function searches for universally-invalid characteristics</span>
<span class="sd">    (leading to invalid properties, see `InvalidPropFinder`)</span>
<span class="sd">    of a `RoundBasedFunction` ``func``</span>
<span class="sd">    by modelling the search as a sequence of SMT problems</span>
<span class="sd">    (using `InvalidPropFinder.find_next_invalidprop_miss_in_the_middle`),</span>
<span class="sd">    but the search is perfomed iteratively over the number of rounds of ``func``.</span>
<span class="sd">    That is, first universally-invalid characteristics covering ``initial_num_rounds`` rounds</span>
<span class="sd">    are searched, then ``initial_num_rounds + 1``, until ``final_num_rounds``.</span>
<span class="sd">    See also `round_based_ch_search`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The `RoundBasedFunction` ``func`` must include `add_round_outputs`</span>
<span class="sd">        calls in its ``eval``.</span>

<span class="sd">        While `InvalidPropFinder` requires wrapping the characteristic model</span>
<span class="sd">        if it has more than one non-trivial transition, this method does</span>
<span class="sd">        require the function ``func`` to be not wrapped.</span>

<span class="sd">        This method also requires that for all the round functions :math:`f_i`</span>
<span class="sd">        of ``func`` (generated through `SSA.split` with</span>
<span class="sd">        `SSA.get_round_separators`), given any probability-one</span>
<span class="sd">        characteristic over :math:`f` with input-output property</span>
<span class="sd">        :math:`(\\alpha, \\beta)`,  then there is no other probability-one</span>
<span class="sd">        characteristic with input property  :math:`\\alpha`</span>
<span class="sd">        (resp. output property :math:`\\beta`) but output property</span>
<span class="sd">        :math:`\\neq \\beta` (resp. input property :math:`\\neq \\alpha`).</span>
<span class="sd">        If all the round functions are permutations, then this is satisfied</span>
<span class="sd">        for `Difference` and `LinearMask` properties.</span>
<span class="sd">        See also `InvalidPropFinder.find_next_invalidprop_miss_in_the_middle`.</span>

<span class="sd">    This function proceed as follows:</span>

<span class="sd">    1. Set the current number of rounds of the universally-invalid characteristics to search</span>
<span class="sd">       for to ``initial_num_rounds``.</span>
<span class="sd">    2. Set the current number of initial rounds to skip  to ``0``.</span>
<span class="sd">    3. Set the number of rounds of ``func`` to the sum of the number of rounds</span>
<span class="sd">       of step 1 and step 2, and split ``func`` into :math:`E \circ S`</span>
<span class="sd">       (:math:`S` denotes the skipped rounds and :math:`E` the target function</span>
<span class="sd">       of the universally-invalid characteristics to search for).</span>
<span class="sd">    4. Create a `abstractproperty.chmodel.ChModel`</span>
<span class="sd">       (resp. `abstractproperty.chmodel.EncryptionChModel`) object</span>
<span class="sd">       of :math:`E` using as arguments ``prop_type`` and ``extra_chmodel_args``.</span>
<span class="sd">    5. Split :math:`E` into :math:`E = E_2 \circ E_1 \circ E_0`</span>
<span class="sd">       taking into account ``min_num_E0_rounds, min_num_E2_rounds``</span>
<span class="sd">       and generate the  characteristic models of :math:`(E_0, E_1, E_2)`</span>
<span class="sd">       using `abstractproperty.chmodel.ChModel.get_round_separators`</span>
<span class="sd">       and `abstractproperty.chmodel.ChModel.split`.</span>
<span class="sd">       See `InvalidPropFinder.find_next_invalidprop_miss_in_the_middle`</span>
<span class="sd">       for more details about :math:`(E_0, E_1, E_2)`.</span>
<span class="sd">    6. Create an `InvalidPropFinder` object with arguments</span>
<span class="sd">       the characteristic model over :math:`E_1`,</span>
<span class="sd">       ``solver_name`` and ``extra_invalidpropfinder_args``.</span>
<span class="sd">    7. Loop over the generator `InvalidPropFinder.find_next_invalidprop_miss_in_the_middle`</span>
<span class="sd">       (with arguments ``exclude_zero_input_prop_E0``</span>
<span class="sd">       and ``exclude_zero_input_prop_E2``)</span>
<span class="sd">       and yield all the 3-length tuples of characteristics from the</span>
<span class="sd">       generator (together with the current number of rounds).</span>
<span class="sd">    8. After the generator is exhausted, go to step 5 but splitting :math:`E`</span>
<span class="sd">       into antoher another partition :math:`(E_0, E_1, E_2)`.</span>

<span class="sd">       a. If all partitions has been exhausted,</span>
<span class="sd">          instead increase the current number of initial rounds to skip</span>
<span class="sd">          (up to ``max_num_skipped_rounds``) and go to step 3.</span>
<span class="sd">       b. If the current number of skipped rounds was ``max_num_skipped_rounds``,</span>
<span class="sd">          instead increase the current number of rounds of</span>
<span class="sd">          the universally-invalid characteristics to search for and go to step 2.</span>
<span class="sd">       c. If this number was ``final_num_rounds``, instead the search is finished.</span>

<span class="sd">    This function is a Python `generator` function</span>
<span class="sd">    (see `InvalidPropFinder`), returning an `iterator` that yields</span>
<span class="sd">    2-length tuples:</span>

<span class="sd">    * The first element in the tuple is a 4-length tuple containing</span>
<span class="sd">      the number of initial skipped rounds, the number of rounds</span>
<span class="sd">      of :math:`E_0`, the number of rounds of :math:`E_1`</span>
<span class="sd">      and the number of rounds of :math:`E_2`.</span>
<span class="sd">    * The second element in the tuple is a 3-length tuple containing</span>
<span class="sd">      the characteristics over :math:`E_0`, :math:`E_1` and :math:`E_2`</span>
<span class="sd">      respectively (i.e., the outputs of</span>
<span class="sd">      `InvalidPropFinder.find_next_invalidprop_miss_in_the_middle`).</span>
<span class="sd">      Note that these characteristics are</span>
<span class="sd">      `abstractproperty.characteristic.Characteristic` objects</span>
<span class="sd">      if ``func`` is a `RoundBasedFunction` object, or</span>
<span class="sd">      `abstractproperty.characteristic.EncryptionCharacteristic` objects</span>
<span class="sd">      if ``func`` is a `RoundBasedFunction`-encryption function of a `Cipher`.</span>

<span class="sd">    The argument ``prop_type`` is a particular `Property` such as `XorDiff`</span>
<span class="sd">    or `LinearMask`. For ``solver_name``, see `InvalidPropFinder`.</span>
<span class="sd">    The optional arguments ``extra_chmodel_args`` and ``extra_invalidpropfinder_args``</span>
<span class="sd">    can be given as dictionaries (in the form of ``**kwargs``) containing</span>
<span class="sd">    additional arguments for ``ChModel/EncryptionChModel`` and `InvalidPropFinder`</span>
<span class="sd">    respectively.</span>

<span class="sd">    It is possible to abort the current search for the current number of rounds</span>
<span class="sd">    and start the search with one more round by passing the</span>
<span class="sd">    value `INCREMENT_NUM_ROUNDS`</span>
<span class="sd">    to the generator iterator with `generator.send`</span>
<span class="sd">    (see `round_based_ch_search`).</span>

<span class="sd">    This function reuses information from previous partitions :math:`(E_0&#39;, E_1&#39;, E_2&#39;)`</span>
<span class="sd">    to directly avoid some new partitions :math:`(E_0, E_1, E_2)` that don&#39;t contain</span>
<span class="sd">    universally-invalid characteristics.</span>
<span class="sd">    Assume that no universally-invalid characteristic was found for the partition</span>
<span class="sd">    :math:`(E_0&#39;, E_1&#39;, E_2&#39;)`,</span>
<span class="sd">    where :math:`E_0&#39;` covers from the :math:`a&#39;`-th round to the :math:`b&#39;`-th</span>
<span class="sd">    round (i.e., ``a&#39;-›b&#39;``) and :math:`E_2&#39;` covers ``c&#39;-›d&#39;``.</span>
<span class="sd">    Then it holds that no universally-invalid characteristic can be found</span>
<span class="sd">    using `InvalidPropFinder.find_next_invalidprop_miss_in_the_middle` from any partition</span>
<span class="sd">    :math:`(E_0, E_1, E_2)` where :math:`E_0` covers ``a-›a&#39;-›b&#39;-›b`` and</span>
<span class="sd">    :math:`E_2` covers ``c-›c&#39;-›d&#39;-›d``, that is,</span>
<span class="sd">    from any partition :math:`(E_0, E_1, E_2)`</span>
<span class="sd">    where :math:`E_0` covers ``a-›b`` and :math:`E_2` covers ``c-›d``</span>
<span class="sd">    such that :math:`a \le a&#39;, b&#39; \le b, c \le c` and :math:`d&#39; \le d`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Note that `InvalidPropFinder` contains other methods to search</span>
<span class="sd">        for universally-invalid characteristics (e.g.,</span>
<span class="sd">        `InvalidPropFinder.find_next_invalidprop_activebitmode` or</span>
<span class="sd">        `InvalidPropFinder.find_next_invalidprop_quantified_logic`)</span>
<span class="sd">        which might find universally-invalid characteristics faster.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; # example of searching for XorDiff universally-invalid Characteristic over a BvFunction</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.invalidpropsearch import round_based_invalidprop_search, INCREMENT_NUM_ROUNDS</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32_ks = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">        &gt;&gt;&gt; iterator = round_based_invalidprop_search(Speck32_ks, 3, 3, XorDiff, &quot;btor&quot;,</span>
<span class="sd">        ...     extra_invalidpropfinder_args={&quot;solver_seed&quot;:0})</span>
<span class="sd">        &gt;&gt;&gt; for i, (tuple_rounds, tuple_chs) in enumerate(iterator):</span>
<span class="sd">        ...     print(tuple_rounds, &quot;:&quot;, &#39;, &#39;.join([ch.srepr() for ch in tuple_chs]))</span>
<span class="sd">        ...     if i == 2: break  # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS</span>
<span class="sd">        (0, 1, 1, 1) : Ch(w=0, id=..., od=...), Ch(w=Infinity, id=..., od=...), Ch(w=0, id=..., od=...)</span>
<span class="sd">        (0, 1, 1, 1) : Ch(w=0, id=..., od=...), Ch(w=Infinity, id=..., od=...), Ch(w=0, id=..., od=...)</span>
<span class="sd">        (0, 1, 1, 1) : Ch(w=0, id=..., od=...), Ch(w=Infinity, id=..., od=...), Ch(w=0, id=..., od=...)</span>
<span class="sd">        &gt;&gt;&gt; # example of searching for LinearMask universally-invalid EncryptionCharacteristic over a Cipher</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">        &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">        &gt;&gt;&gt; iterator = round_based_invalidprop_search(Speck32, 4, 5, LinearMask, &quot;btor&quot;,</span>
<span class="sd">        ...     min_num_E0_rounds=2, extra_invalidpropfinder_args={&quot;solver_seed&quot;:0})</span>
<span class="sd">        &gt;&gt;&gt; tuple_rounds, tuple_chs = next(iterator)</span>
<span class="sd">        &gt;&gt;&gt; print(tuple_rounds, &quot;:&quot;, &#39;, &#39;.join([ch.srepr() for ch in tuple_chs]))</span>
<span class="sd">        (0, 2, 1, 1) : Ch(w=0, id=0080 4021, od=0201 0200), Ch(w=Infinity, id=0201 0200, od=0000 0001), Ch(w=0, id=0000 0001, od=0004 0004)</span>
<span class="sd">        &gt;&gt;&gt; tuple_rounds, tuple_chs = next(iterator)</span>
<span class="sd">        &gt;&gt;&gt; print(tuple_rounds, &quot;:&quot;, &#39;, &#39;.join([ch.srepr() for ch in tuple_chs]))</span>
<span class="sd">        (0, 2, 1, 1) : Ch(w=0, id=0080 4021, od=0201 0200), Ch(w=Infinity, id=0201 0200, od=0080 e001), Ch(w=0, id=0080 e001, od=8002 8003)</span>
<span class="sd">        &gt;&gt;&gt; iterator.send(INCREMENT_NUM_ROUNDS)  # stop current num_rounds and increment by 1</span>
<span class="sd">        &gt;&gt;&gt; tuple_rounds, tuple_chs = next(iterator)</span>
<span class="sd">        &gt;&gt;&gt; print(tuple_rounds, &quot;:&quot;, &#39;, &#39;.join([ch.srepr() for ch in tuple_chs]))</span>
<span class="sd">        (0, 2, 1, 2) : Ch(w=0, id=0080 4021, od=0201 0200), Ch(w=Infinity, id=0201 0200, od=0080 4021), Ch(w=0, id=0080 4021, od=0201 0200)</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        Example 1.</span>
<span class="sd">        If there is no           2-›7 ID over E with E0 covering [2-›3] and E2  [6-›7]</span>
<span class="sd">        then there are no bigger *-›* ID over E with E0       [*-›2-›3] and E2  [6-›7-›*] for any *</span>
<span class="sd">        This is because in the 2nd case the Pr1-E0 outputs and the Pr-E2 inputs</span>
<span class="sd">        are a subset of the 1st case.</span>

<span class="sd">        Example 2.</span>
<span class="sd">        If there is no ID over E with E0 covering   [2-›3] and E2       [6-›7]</span>
<span class="sd">        then there is no ID over E with E0 covering [2-›3-›4] and E2 [5-›6-›7]</span>
<span class="sd">        This is because in the 2nd case E0 and E2 fully contains</span>
<span class="sd">        the E0 and E2 of the 1st case, (1st case contains more Pr.1 than 2nd).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">cascada_ssa</span><span class="o">.</span><span class="n">RoundBasedFunction</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">blockcipher</span><span class="o">.</span><span class="n">Cipher</span><span class="p">)</span> <span class="ow">and</span>
             <span class="nb">issubclass</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">encryption</span><span class="p">,</span> <span class="n">cascada_ssa</span><span class="o">.</span><span class="n">RoundBasedFunction</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2"> is not a RoundBasedFunction or a Cipher&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">initial_num_rounds</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;initial_num_rounds (</span><span class="si">{</span><span class="n">initial_num_rounds</span><span class="si">}</span><span class="s2">) must be at least 3&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">aux_nr</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">aux_nr</span> <span class="ow">in</span>
               <span class="p">[</span><span class="n">initial_num_rounds</span><span class="p">,</span> <span class="n">final_num_rounds</span><span class="p">,</span> <span class="n">max_num_skipped_rounds</span><span class="p">,</span>
                <span class="n">min_num_E0_rounds</span><span class="p">,</span> <span class="n">min_num_E2_rounds</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">initial_num_rounds</span> <span class="o">&lt;=</span> <span class="n">final_num_rounds</span>

    <span class="k">if</span> <span class="n">extra_chmodel_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extra_chmodel_args</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extra_chmodel_args</span> <span class="o">=</span> <span class="n">extra_chmodel_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">extra_invalidpropfinder_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">extra_invalidpropfinder_args</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extra_invalidpropfinder_args</span> <span class="o">=</span> <span class="n">extra_invalidpropfinder_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">printing_mode</span> <span class="o">=</span> <span class="n">extra_invalidpropfinder_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;printing_mode&quot;</span><span class="p">,</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="n">extra_invalidpropfinder_args</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;filename&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">smart_print</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">_get_smart_print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">find_cipher_invalid_prop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;find_cipher_invalid_prop&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">exclude_zero_input_prop_external_E</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;exclude_zero_input_prop_external_E&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1"># ignore_trivial_E1 = kwargs.pop(&quot;ignore_trivial_E1&quot;, False)</span>

    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">exclude_zero_input_prop_external_E</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">find_cipher_invalid_prop</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid arguments: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">cascada.differential.difference</span> <span class="kn">import</span> <span class="n">XorDiff</span><span class="p">,</span> <span class="n">RXDiff</span>
    <span class="kn">from</span> <span class="nn">cascada.linear.mask</span> <span class="kn">import</span> <span class="n">LinearMask</span>
    <span class="c1"># from cascada.algebraic.value import BitValue, WordValue</span>

    <span class="k">if</span> <span class="n">prop_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">XorDiff</span><span class="p">,</span> <span class="n">RXDiff</span><span class="p">]:</span>
        <span class="kn">from</span> <span class="nn">cascada.differential.chmodel</span> <span class="kn">import</span> <span class="n">ChModel</span><span class="p">,</span> <span class="n">EncryptionChModel</span><span class="p">,</span> <span class="n">CipherChModel</span>
    <span class="k">elif</span> <span class="n">prop_type</span> <span class="o">==</span> <span class="n">LinearMask</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">find_cipher_invalid_prop</span> <span class="ow">is</span> <span class="kc">False</span>
        <span class="kn">from</span> <span class="nn">cascada.linear.chmodel</span> <span class="kn">import</span> <span class="n">ChModel</span><span class="p">,</span> <span class="n">EncryptionChModel</span>
    <span class="c1"># elif prop_type in [BitValue, WordValue]:</span>
    <span class="c1">#     from cascada.algebraic.chmodel import ChModel, EncryptionChModel, CipherChModel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;prop_type not in </span><span class="si">{</span><span class="p">[</span><span class="n">XorDiff</span><span class="p">,</span> <span class="n">RXDiff</span><span class="p">,</span> <span class="n">LinearMask</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1">#</span>

    <span class="n">bad_partitions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">get_a_b_c_d_partition</span><span class="p">(</span><span class="n">my_num_S_rounds</span><span class="p">,</span> <span class="n">my_num_E0_rounds</span><span class="p">,</span> <span class="n">my_num_E1_rounds</span><span class="p">,</span> <span class="n">my_num_E2_rounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the tuple (a, b, c, d) where a/b is the start/end rounds of E0 and similar for c/d and E2.&quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">my_num_S_rounds</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">my_num_S_rounds</span> <span class="o">+</span> <span class="n">my_num_E0_rounds</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">my_num_S_rounds</span> <span class="o">+</span> <span class="n">my_num_E0_rounds</span> <span class="o">+</span> <span class="n">my_num_E1_rounds</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">my_num_S_rounds</span> <span class="o">+</span> <span class="n">my_num_E0_rounds</span> <span class="o">+</span> <span class="n">my_num_E1_rounds</span> <span class="o">+</span> <span class="n">my_num_E2_rounds</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="p">[</span><span class="n">my_num_S_rounds</span><span class="p">,</span> <span class="n">my_num_E0_rounds</span><span class="p">,</span> <span class="n">my_num_E1_rounds</span><span class="p">,</span> <span class="n">my_num_E2_rounds</span><span class="p">]</span>

    <span class="c1">#</span>

    <span class="n">num_E_rounds</span> <span class="o">=</span> <span class="n">initial_num_rounds</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># loop over num_E_rounds (not a for loop due to INCREMENT_NUM_ROUNDS)</span>
        <span class="n">found_invalidprop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">found_INCREMENT_NUM_ROUNDS</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">num_S_rounds</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_num_skipped_rounds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">func</span><span class="o">.</span><span class="n">set_num_rounds</span><span class="p">(</span><span class="n">num_S_rounds</span> <span class="o">+</span> <span class="n">num_E_rounds</span><span class="p">)</span>

            <span class="n">external_chmodel</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">blockcipher</span><span class="o">.</span><span class="n">Cipher</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">find_cipher_invalid_prop</span><span class="p">:</span>
                    <span class="n">aux_SE_ch_model</span> <span class="o">=</span> <span class="n">CipherChModel</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_chmodel_args</span><span class="p">)</span>
                    <span class="n">external_chmodel</span><span class="p">,</span> <span class="n">SE_ch_model</span> <span class="o">=</span> <span class="n">aux_SE_ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="p">,</span> <span class="n">aux_SE_ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">SE_ch_model</span> <span class="o">=</span> <span class="n">EncryptionChModel</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_chmodel_args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="n">EncryptionChModel</span><span class="o">.</span><span class="n">_prefix</span>
                <span class="n">input_prop_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">p</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">input_widths</span><span class="p">))]</span>
                <span class="n">SE_ch_model</span> <span class="o">=</span> <span class="n">ChModel</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="n">input_prop_names</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_chmodel_args</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">num_S_rounds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">S_ch_model</span><span class="p">,</span> <span class="n">E_ch_model</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">SE_ch_model</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">SE_all_rs</span> <span class="o">=</span> <span class="n">SE_ch_model</span><span class="o">.</span><span class="n">get_round_separators</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">SE_all_rs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">SE_all_rs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">SE_all_rs</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2"> cannot be decomposed in 3 or more rounds&quot;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">SE_all_rs</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_S_rounds</span> <span class="o">+</span> <span class="n">num_E_rounds</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="c1"># the end of the i-th round (i=1,2,...) is round_separators[i-1]</span>
                <span class="n">S_ch_model</span><span class="p">,</span> <span class="n">E_ch_model</span> <span class="o">=</span> <span class="n">SE_ch_model</span><span class="o">.</span><span class="n">split</span><span class="p">([</span><span class="n">SE_all_rs</span><span class="p">[</span><span class="n">num_S_rounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span>
                <span class="c1"># S/E_ch_model.func is not a RoundBasedFunction (no num_rounds, no get_round_separators)</span>

            <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_E_rounds</span> <span class="o">!=</span> <span class="n">initial_num_rounds</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current number of rounds of (S, E): &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">num_S_rounds</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_E_rounds</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">num_S_rounds</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Characteristic model over E \circ S: </span><span class="si">{</span><span class="n">SE_ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output of S: </span><span class="si">{</span><span class="n">SE_all_rs</span><span class="p">[</span><span class="n">num_S_rounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Characteristic model over S: </span><span class="si">{</span><span class="n">S_ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Characteristic model over E: </span><span class="si">{</span><span class="n">E_ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">external_chmodel</span><span class="p">:</span>
                    <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;External characteristic model (over the key schedule): </span><span class="si">{</span><span class="n">external_chmodel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">num_E1_rounds</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_E_rounds</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># - 2 to reserve 1 round for E0 and 1 for E2</span>
                <span class="n">aux_num_E0_rounds_num_E2_rounds</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">num_E0_rounds</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_E_rounds</span> <span class="o">-</span> <span class="n">num_E1_rounds</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># - 1 to reserve 1 for E2</span>
                    <span class="n">num_E2_rounds</span> <span class="o">=</span> <span class="n">num_E_rounds</span> <span class="o">-</span> <span class="n">num_E0_rounds</span> <span class="o">-</span> <span class="n">num_E1_rounds</span>
                    <span class="k">assert</span> <span class="n">num_E2_rounds</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">num_E0_rounds</span> <span class="o">+</span> <span class="n">num_E1_rounds</span> <span class="o">+</span> <span class="n">num_E2_rounds</span> <span class="o">==</span> <span class="n">num_E_rounds</span>
                    <span class="k">if</span> <span class="n">num_E0_rounds</span> <span class="o">&lt;</span> <span class="n">min_num_E0_rounds</span> <span class="ow">or</span> <span class="n">num_E2_rounds</span> <span class="o">&lt;</span> <span class="n">min_num_E2_rounds</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">aux_num_E0_rounds_num_E2_rounds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">num_E0_rounds</span><span class="p">,</span> <span class="n">num_E2_rounds</span><span class="p">])</span>
                <span class="c1"># sorting ensure first (E0,E2) pair where each Ei has roughly half the rounds of E0+E2</span>
                <span class="n">aux_num_E0_rounds_num_E2_rounds</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

                <span class="k">for</span> <span class="n">num_E0_rounds</span><span class="p">,</span> <span class="n">num_E2_rounds</span> <span class="ow">in</span> <span class="n">aux_num_E0_rounds_num_E2_rounds</span><span class="p">:</span>
                    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">get_a_b_c_d_partition</span><span class="p">(</span><span class="n">num_S_rounds</span><span class="p">,</span> <span class="n">num_E0_rounds</span><span class="p">,</span> <span class="n">num_E1_rounds</span><span class="p">,</span> <span class="n">num_E2_rounds</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">a_prime</span><span class="p">,</span> <span class="n">b_prime</span><span class="p">,</span> <span class="n">c_prime</span><span class="p">,</span> <span class="n">d_prime</span><span class="p">,</span> <span class="n">bad_partition</span> <span class="ow">in</span> <span class="n">bad_partitions</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">a_prime</span> <span class="ow">and</span> <span class="n">b_prime</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">c_prime</span> <span class="ow">and</span> <span class="n">d_prime</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                                    <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                                <span class="c1"># EX_ch_model.func.get_name() doesn&#39;t give useful information</span>
                                <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ignoring current number of rounds &quot;</span>
                                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">num_S_rounds</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_E0_rounds</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_E1_rounds</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_E2_rounds</span><span class="si">}</span><span class="s2">) &quot;</span><span class="p">,</span>
                                            <span class="sa">f</span><span class="s2">&quot;of (S, E0, E1, E2) due to previous (S&#39;, E0&#39;, E1&#39;, E2&#39;) &quot;</span>
                                            <span class="sa">f</span><span class="s2">&quot;with number of rounds </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bad_partition</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                                            <span class="sa">f</span><span class="s2">&quot;that did not contain any universally-invalid characteristics&quot;</span><span class="p">,</span>  <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                            <span class="k">continue</span>

                    <span class="n">E_all_rs</span> <span class="o">=</span> <span class="n">E_ch_model</span><span class="o">.</span><span class="n">get_round_separators</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">E_all_rs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">E_all_rs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">E_ch_model</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2"> cannot be decomposed in 3 or more rounds&quot;</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">E_all_rs</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_E_rounds</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">E0_rs</span> <span class="o">=</span> <span class="n">E_all_rs</span><span class="p">[</span><span class="n">num_E0_rounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">E1_rs</span> <span class="o">=</span> <span class="n">E_all_rs</span><span class="p">[</span><span class="n">num_E0_rounds</span> <span class="o">+</span> <span class="n">num_E1_rounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">E0_ch_model</span><span class="p">,</span> <span class="n">E1_ch_model</span><span class="p">,</span> <span class="n">E2_ch_model</span> <span class="o">=</span> <span class="n">E_ch_model</span><span class="o">.</span><span class="n">split</span><span class="p">([</span><span class="n">E0_rs</span><span class="p">,</span> <span class="n">E1_rs</span><span class="p">])</span>

                    <span class="n">E1_non_id_opmodels</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">op_model</span> <span class="ow">in</span> <span class="n">E1_ch_model</span><span class="o">.</span><span class="n">assign_outprop2op_model</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op_model</span><span class="p">,</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">ModelIdentity</span><span class="p">):</span>
                            <span class="n">E1_non_id_opmodels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_model</span><span class="p">)</span>
                    <span class="c1"># if ignore_trivial_E1 and len(E1_non_id_opmodels) == 0:</span>
                    <span class="c1">#     continue</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">E1_non_id_opmodels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">E1_ch_model</span> <span class="o">=</span> <span class="n">get_wrapped_chmodel</span><span class="p">(</span><span class="n">E1_ch_model</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">!=</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Silent</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Characteristic model over E0: </span><span class="si">{</span><span class="n">E0_ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Characteristic model over E1: </span><span class="si">{</span><span class="n">E1_ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Characteristic model over E2: </span><span class="si">{</span><span class="n">E2_ch_model</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="c1"># EX_ch_model.func.get_name() doesn&#39;t give useful information</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current number of rounds of (E0, E1, E2): &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">num_E0_rounds</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_E1_rounds</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_E2_rounds</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">,</span> <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                    <span class="n">invalid_prop_finder</span> <span class="o">=</span> <span class="n">InvalidPropFinder</span><span class="p">(</span><span class="n">E1_ch_model</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span> <span class="o">**</span><span class="n">extra_invalidpropfinder_args</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;Size of the base SMT problem:&quot;</span><span class="p">,</span> <span class="n">invalid_prop_finder</span><span class="o">.</span><span class="n">formula_size</span><span class="p">())</span>
                        <span class="n">smart_print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Base SMT problem:</span><span class="se">\n</span><span class="si">{</span><span class="n">invalid_prop_finder</span><span class="o">.</span><span class="n">hrepr</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="n">iterator</span> <span class="o">=</span> <span class="n">invalid_prop_finder</span><span class="o">.</span><span class="n">find_next_invalidprop_miss_in_the_middle</span>
                    <span class="k">for</span> <span class="n">tuple_chs</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">(</span><span class="n">E0_ch_model</span><span class="p">,</span> <span class="n">E2_ch_model</span><span class="p">,</span> <span class="n">ch_model_E</span><span class="o">=</span><span class="n">E_ch_model</span><span class="p">,</span> <span class="n">ch_model_external_E</span><span class="o">=</span><span class="n">external_chmodel</span><span class="p">,</span>
                                              <span class="n">exclude_zero_input_prop_E0</span><span class="o">=</span><span class="n">exclude_zero_input_prop_E0</span><span class="p">,</span>
                                              <span class="n">exclude_zero_input_prop_E2</span><span class="o">=</span><span class="n">exclude_zero_input_prop_E2</span><span class="p">,</span>
                                              <span class="n">exclude_zero_input_prop_external_E</span><span class="o">=</span><span class="n">exclude_zero_input_prop_external_E</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">num_S_rounds</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">find_cipher_invalid_prop</span><span class="p">:</span>
                            <span class="n">prone_ch_E0</span><span class="p">,</span> <span class="n">uni_inv_ch_E1</span><span class="p">,</span> <span class="n">prone_ch_E2</span><span class="p">,</span> <span class="n">external_prone_ch_E</span> <span class="o">=</span> <span class="n">tuple_chs</span>
                            <span class="n">var_prop2ct_prop</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
                            <span class="k">for</span> <span class="n">vp</span><span class="p">,</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                                    <span class="nb">zip</span><span class="p">(</span><span class="n">aux_SE_ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">input_prop</span><span class="p">,</span> <span class="n">prone_ch_E0</span><span class="o">.</span><span class="n">input_prop</span><span class="p">),</span>
                                    <span class="nb">zip</span><span class="p">(</span><span class="n">aux_SE_ch_model</span><span class="o">.</span><span class="n">enc_ch_model</span><span class="o">.</span><span class="n">output_prop</span><span class="p">,</span> <span class="n">prone_ch_E2</span><span class="o">.</span><span class="n">output_prop</span><span class="p">),</span>
                                    <span class="nb">zip</span><span class="p">(</span><span class="n">aux_SE_ch_model</span><span class="o">.</span><span class="n">ks_ch_model</span><span class="o">.</span><span class="n">input_prop</span><span class="p">,</span> <span class="n">external_prone_ch_E</span><span class="o">.</span><span class="n">input_prop</span><span class="p">)</span>
                            <span class="p">):</span>
                                <span class="n">var_prop2ct_prop</span><span class="p">[</span><span class="n">vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span>
                            <span class="n">cipher_ch_finder</span> <span class="o">=</span> <span class="n">chsearch</span><span class="o">.</span><span class="n">CipherChFinder</span><span class="p">(</span>
                                <span class="n">aux_SE_ch_model</span><span class="p">,</span> <span class="n">ks_assert_type</span><span class="o">=</span><span class="n">chsearch</span><span class="o">.</span><span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">Validity</span><span class="p">,</span>
                                <span class="n">enc_assert_type</span><span class="o">=</span><span class="n">chsearch</span><span class="o">.</span><span class="n">ChModelAssertType</span><span class="o">.</span><span class="n">Validity</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="n">solver_name</span><span class="p">,</span>
                                <span class="n">var_prop2ct_prop</span><span class="o">=</span><span class="n">var_prop2ct_prop</span><span class="p">,</span> <span class="n">raise_exception_missing_var</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">printing_mode</span><span class="o">=</span><span class="n">printing_mode</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span>
                            <span class="p">)</span>
                            <span class="k">for</span> <span class="n">valid_cipher_ch_found</span> <span class="ow">in</span> <span class="n">cipher_ch_finder</span><span class="o">.</span><span class="n">find_next_ch</span><span class="p">():</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                    <span class="s2">&quot;the concatenation of the last characteristic tuple found,&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - prone_ch_E0: </span><span class="si">{</span><span class="n">prone_ch_E0</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">prone_ch_E0</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - uni_inv_ch_E1: </span><span class="si">{</span><span class="n">uni_inv_ch_E1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">uni_inv_ch_E1</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - prone_ch_E2: </span><span class="si">{</span><span class="n">prone_ch_E2</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">prone_ch_E2</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - external_prone_ch_E: </span><span class="si">{</span><span class="n">external_prone_ch_E</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">external_prone_ch_E</span><span class="o">.</span><span class="n">ch_model</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - cipher ch model: </span><span class="si">{</span><span class="n">aux_SE_ch_model</span><span class="si">}</span><span class="se">\n</span><span class="s2"> - var_prop2ct_prop: </span><span class="si">{</span><span class="n">var_prop2ct_prop</span><span class="si">}</span><span class="s2">&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - cipher_ch_finder: </span><span class="si">{</span><span class="n">cipher_ch_finder</span><span class="o">.</span><span class="n">initial_constraints</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">cipher_ch_finder</span><span class="o">.</span><span class="n">chmodel_asserts</span><span class="p">)</span><span class="si">}</span><span class="s2">,&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> is not universally-invalid (found compatible valid cipher characteristic </span><span class="si">{</span><span class="n">valid_cipher_ch_found</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
                            <span class="k">del</span> <span class="n">cipher_ch_finder</span>

                        <span class="n">found_invalidprop</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">tuple_rounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_S_rounds</span><span class="p">,</span> <span class="n">num_E0_rounds</span><span class="p">,</span> <span class="n">num_E1_rounds</span><span class="p">,</span> <span class="n">num_E2_rounds</span><span class="p">)</span>
                        <span class="n">sent_value</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span> <span class="p">(</span><span class="n">tuple_rounds</span><span class="p">,</span> <span class="n">tuple_chs</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">sent_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">sent_value</span> <span class="o">==</span> <span class="n">INCREMENT_NUM_ROUNDS</span><span class="p">:</span>
                                <span class="n">found_INCREMENT_NUM_ROUNDS</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">yield</span> <span class="kc">None</span>
                                <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;value </span><span class="si">{</span><span class="n">sent_value</span><span class="si">}</span><span class="s2"> is sent to the generator &quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot;but only sending INCREMENT_NUM_ROUNDS&quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot; affects the generator&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">found_INCREMENT_NUM_ROUNDS</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">found_invalidprop</span>
                        <span class="k">break</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_invalidprop</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">found_INCREMENT_NUM_ROUNDS</span> <span class="ow">is</span> <span class="kc">False</span>
                        <span class="n">bad_partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_a_b_c_d_partition</span><span class="p">(</span><span class="n">num_S_rounds</span><span class="p">,</span> <span class="n">num_E0_rounds</span><span class="p">,</span> <span class="n">num_E1_rounds</span><span class="p">,</span> <span class="n">num_E2_rounds</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">printing_mode</span> <span class="o">==</span> <span class="n">PrintingMode</span><span class="o">.</span><span class="n">Debug</span><span class="p">:</span>
                            <span class="n">smart_print</span><span class="p">(</span><span class="s2">&quot;No universally-invalid characteristic found for number of rounds &quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">num_E0_rounds</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_E1_rounds</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_E2_rounds</span><span class="si">}</span><span class="s2">) of (E0, E1, E2)&quot;</span><span class="p">,</span>
                                        <span class="n">prepend_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">found_INCREMENT_NUM_ROUNDS</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">found_invalidprop</span> <span class="ow">is</span> <span class="kc">True</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">found_INCREMENT_NUM_ROUNDS</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">found_invalidprop</span> <span class="ow">is</span> <span class="kc">True</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_invalidprop</span> <span class="ow">or</span> <span class="n">num_E_rounds</span> <span class="o">==</span> <span class="n">final_num_rounds</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_E_rounds</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">num_E_rounds</span> <span class="o">&lt;=</span> <span class="n">final_num_rounds</span></div>


<div class="viewcode-block" id="round_based_invalidcipherprop_search"><a class="viewcode-back" href="../../../cascada.smt.invalidpropsearch.html#cascada.smt.invalidpropsearch.round_based_invalidcipherprop_search">[docs]</a><span class="k">def</span> <span class="nf">round_based_invalidcipherprop_search</span><span class="p">(</span>
        <span class="n">cipher</span><span class="p">,</span> <span class="n">initial_num_rounds</span><span class="p">,</span> <span class="n">final_num_rounds</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span>
        <span class="n">max_num_skipped_rounds</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">min_num_E0_rounds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_num_E2_rounds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">extra_cipherchmodel_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">extra_invalidcipherpropfinder_args</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude_zero_input_prop_E0</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">exclude_zero_input_prop_E2</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">exclude_zero_input_prop_external_E</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># **kwargs</span>
    <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search for zero-probability (invalid) properties of iterated ciphers over multiple number of rounds.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The `Cipher.encryption` of ``cipher`` must be a</span>
<span class="sd">        `RoundBasedFunction` including `add_round_outputs`</span>
<span class="sd">        calls in its ``eval``.</span>

<span class="sd">    This function is similar to `round_based_invalidprop_search`.</span>
<span class="sd">    The only differences are:</span>

<span class="sd">    - The function ``func`` (i.e., :math:`E \circ S`) is the</span>
<span class="sd">      `Cipher.encryption` of the given ``cipher``.</span>
<span class="sd">      Thus, :math:`S` denote the skipped rounds of the encryption function.</span>
<span class="sd">    - Let :math:`K` denote the `Cipher.key_schedule` of ``cipher``, that is,</span>
<span class="sd">      the function whose outputs are the round keys used in :math:`E \circ S`.</span>
<span class="sd">      The generator `InvalidPropFinder.find_next_invalidprop_miss_in_the_middle`</span>
<span class="sd">      is called with the argument ``ch_model_external_E`` given as the</span>
<span class="sd">      characteristic model over :math:`K` and with the argument</span>
<span class="sd">      ``exclude_zero_input_prop_external_E``.</span>
<span class="sd">    - This function yields 2-length tuples where the 2nd element is a</span>
<span class="sd">      4-length tuple; the last characteristic is the characteristic</span>
<span class="sd">      with probability 1 over :math:`K`.</span>
<span class="sd">      Thus, the concatenation of the first 3 characteristics is a universally-invalid</span>
<span class="sd">      characteristic over :math:`E` where the round key properties</span>
<span class="sd">      are given by the outputs of the probability-one characteristic</span>
<span class="sd">      over :math:`K`.</span>

<span class="sd">    Note that initial rounds are only skipped in the encryption function</span>
<span class="sd">    and not in the key-schedule function.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Let ``(tuple_nr, tuple_ch)`` be an element</span>
<span class="sd">        yielded by `round_based_invalidcipherprop_search`.</span>

<span class="sd">        Let :math:`\\alpha_{K}` be the input property of the</span>
<span class="sd">        4-th characteristic  in ``tuple_ch``,</span>
<span class="sd">        and let :math:`(\\alpha_{E}, \\beta_{E})` be the input-output</span>
<span class="sd">        property pair of the concatenation of the first three characteristic</span>
<span class="sd">        in ``tuple_ch``.</span>

<span class="sd">        If ``tuple_nr[0]`` is 0, no initial rounds are skipped,</span>
<span class="sd">        and :math:`(\\alpha_{K}, \\alpha_{E}) \mapsto \\beta_{E}`</span>
<span class="sd">        is a universally-invalid cipher characteristic</span>
<span class="sd">        (as defined in `InvalidCipherPropFinder`) of</span>
<span class="sd">        ``cipher.set_num_rounds_and_return(tuple_nr[1]+tuple_nr[2]+tuple_nr[3])``,</span>
<span class="sd">        that is, the ``cipher`` with number of rounds</span>
<span class="sd">        ``tuple_nr[1]+tuple_nr[2]+tuple_nr[3]``.</span>

<span class="sd">        If ``tuple_nr[0]`` is not zero then a universally-invalid cipher characteristic</span>
<span class="sd">        is also obtained but the underlying cipher is more difficult</span>
<span class="sd">        to generate due to the skipped initial rounds.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.smt.invalidpropsearch import round_based_invalidcipherprop_search</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">        &gt;&gt;&gt; iterator = round_based_invalidcipherprop_search(Speck32, 3, 3, XorDiff, &quot;btor&quot;,</span>
<span class="sd">        ...     extra_invalidcipherpropfinder_args={&quot;solver_seed&quot;:0})</span>
<span class="sd">        &gt;&gt;&gt; for i, (tuple_rounds, tuple_chs) in enumerate(iterator):</span>
<span class="sd">        ...     print(tuple_rounds, &quot;:&quot;, &#39;, &#39;.join([ch.srepr() for ch in tuple_chs]))</span>
<span class="sd">        ...     if i == 1: break  # doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS</span>
<span class="sd">        (0, 1, 1, 1) : Ch(w=0, id=0000 8000, od=8000 8002),</span>
<span class="sd">                       Ch(w=Infinity, id=8000 8002, od=0000 8000),</span>
<span class="sd">                       Ch(w=0, id=0000 8000, od=0002 0000),</span>
<span class="sd">                       Ch(w=0, id=0000 0040 0000, od=0000 8000 8002)</span>
<span class="sd">        (0, 1, 1, 1) : Ch(w=0, id=0000 8000, od=8000 8002),</span>
<span class="sd">                       Ch(w=Infinity, id=8000 8002, od=0040 8000),</span>
<span class="sd">                       Ch(w=0, id=0040 8000, od=8002 8000),</span>
<span class="sd">                       Ch(w=0, id=0000 0040 0000, od=0000 8000 8002)</span>


<span class="sd">    .. Implementation details:</span>

<span class="sd">         A universally-invalid cipher characteristic cannot be returned since</span>
<span class="sd">         the underlying cipher cannot be generated due to the</span>
<span class="sd">         skipped rounds.</span>

<span class="sd">         Initial rounds are not skipped in the key-schedule function</span>
<span class="sd">         since ``split`` changes the names of the variables and afterwards</span>
<span class="sd">         these names don&#39;t match the round key names in the</span>
<span class="sd">         encryption characteristics.</span>

<span class="sd">         The key-schedule and the encryption computations cannot be</span>
<span class="sd">         easily merged into a single bit-vector function with the ``eval``</span>
<span class="sd">         method because in that case first the whole key-schedule</span>
<span class="sd">         would be computed (and thus the whole key-schedule would</span>
<span class="sd">         be part of the first split characteristic).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">round_based_invalidprop_search</span><span class="p">(</span>
        <span class="n">cipher</span><span class="p">,</span> <span class="n">initial_num_rounds</span><span class="p">,</span> <span class="n">final_num_rounds</span><span class="p">,</span> <span class="n">prop_type</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">,</span>
        <span class="n">max_num_skipped_rounds</span><span class="o">=</span><span class="n">max_num_skipped_rounds</span><span class="p">,</span>
        <span class="n">min_num_E0_rounds</span><span class="o">=</span><span class="n">min_num_E0_rounds</span><span class="p">,</span>
        <span class="n">min_num_E2_rounds</span><span class="o">=</span><span class="n">min_num_E2_rounds</span><span class="p">,</span>
        <span class="n">extra_chmodel_args</span><span class="o">=</span><span class="n">extra_cipherchmodel_args</span><span class="p">,</span>
        <span class="n">extra_invalidpropfinder_args</span><span class="o">=</span><span class="n">extra_invalidcipherpropfinder_args</span><span class="p">,</span>
        <span class="n">exclude_zero_input_prop_E0</span><span class="o">=</span><span class="n">exclude_zero_input_prop_E0</span><span class="p">,</span>
        <span class="n">exclude_zero_input_prop_E2</span><span class="o">=</span><span class="n">exclude_zero_input_prop_E2</span><span class="p">,</span>
        <span class="n">exclude_zero_input_prop_external_E</span><span class="o">=</span><span class="n">exclude_zero_input_prop_external_E</span><span class="p">,</span>
        <span class="n">find_cipher_invalid_prop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="c1"># **kwargs</span>
    <span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Adrián Ranea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>