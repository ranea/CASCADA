<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cascada.bitvector.ssa &mdash; CASCADA 1.0.rc0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> CASCADA
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">CASCADA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../adding_primitive.html">Adding a primitive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primitives_implemented.html">Primitives implemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cascada.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CASCADA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>cascada.bitvector.ssa</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cascada.bitvector.ssa</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Represent bit-vector functions and their representation in static single assignment (SSA) form.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">operation</span>


<span class="nb">zip</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">zip</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="BvFunction"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.BvFunction">[docs]</a><span class="k">class</span> <span class="nc">BvFunction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent fixed-width bit-vector functions.</span>

<span class="sd">    A `BvFunction` takes fixed-width `Constant` operands and return a</span>
<span class="sd">    tuple of fixed-width `Constant`.</span>

<span class="sd">    Similar to `Operation`, `BvFunction` is evaluated</span>
<span class="sd">    using the operator ``()`` and provides *Automatic Constant Conversion*.</span>

<span class="sd">    .. note::</span>
<span class="sd">        `BvFunction` only supports `Constant` operands and</span>
<span class="sd">        must return a tuple of `Constant` values</span>
<span class="sd">        (as opposed to `Operation` that accepts `Term` and scalar operands</span>
<span class="sd">        and returns a single `Term`).</span>

<span class="sd">        `BvFunction` does not support returned values that independent</span>
<span class="sd">        of the inputs.</span>

<span class="sd">    This class is not meant to be instantiated but to provide a base class for</span>
<span class="sd">    bit-vector functions with fixed operands. To define a bit-vector function,</span>
<span class="sd">    subclass `BvFunction`, set the class attributes `input_widths` and</span>
<span class="sd">    `output_widths` and implement `eval` with bit-vector operations.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">        &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">        ...     input_widths, output_widths = [8, 8], [8, 8]</span>
<span class="sd">        ...     @classmethod</span>
<span class="sd">        ...     def eval(cls, x, y):  return x ^ y, x</span>
<span class="sd">        &gt;&gt;&gt; MyFoo.get_name()</span>
<span class="sd">        &#39;MyFoo&#39;</span>
<span class="sd">        &gt;&gt;&gt; MyFoo(1, 1)  # automatic conversion from int to Constant</span>
<span class="sd">        (0x00, 0x01)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        input_widths: a list containing the widths of the inputs</span>
<span class="sd">        output_widths: a list containing the widths of the outputs</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_widths</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">output_widths</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_logger</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">)</span><span class="si">}</span><span class="s2"> inputs, not </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2"> = len(</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">):</span>
            <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">bitvectify</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">newargs</span>

        <span class="n">simplify</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;simplify&quot;</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="o">.</span><span class="n">current_context</span><span class="p">)</span>
        <span class="n">symbolic_inputs</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;symbolic_inputs&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">ct_inputs</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ct_inputs</span> <span class="ow">or</span> <span class="n">symbolic_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ct_inputs</span> <span class="ow">and</span> <span class="n">simplify</span> <span class="ow">and</span> <span class="n">context</span><span class="o">.</span><span class="n">Memoization</span><span class="o">.</span><span class="n">current_context</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;very slow evaluation of </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2"> (with symbolic inputs, &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;with the Simplification context and without the &quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;Memoization context)&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="p">(</span><span class="n">simplify</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expected bit-vector Constant arguments, not </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must return a tuple of bit-vectors, &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;not a single </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> object&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">output_widths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expected a </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">output_widths</span><span class="p">)</span><span class="si">}</span><span class="s2">-length tuple &quot;</span>
                             <span class="sa">f</span><span class="s2">&quot;of bit-vectors returned, not </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">-length tuple </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">symbolic_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">result</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;if symbolic_inputs, expected no Constant values &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;in the returned tuple, not </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">result</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expected a tuple of Constant values returned, not </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">output_widths</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">bitvectify</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>

        <span class="bp">cls</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_logger</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

<div class="viewcode-block" id="BvFunction.get_name"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.BvFunction.get_name">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the name of the function (by default ``cls.__name__``).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span></div>

<div class="viewcode-block" id="BvFunction.vrepr"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.BvFunction.vrepr">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">vrepr</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an executable string representation.</span>

<span class="sd">        This method returns a string so that ``eval(cls.vrepr())``</span>
<span class="sd">        returns a new `BvFunction` object with the same content.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span></div>

<div class="viewcode-block" id="BvFunction.eval"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.BvFunction.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the function (internal method).&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;subclasses need to override this method&quot;</span><span class="p">)</span></div>

    <span class="c1"># noinspection PyArgumentList</span>
<div class="viewcode-block" id="BvFunction.to_ssa"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.BvFunction.to_ssa">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">to_ssa</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_names</span><span class="p">,</span> <span class="n">id_prefix</span><span class="p">,</span> <span class="n">decompose_sec_ops</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">ssa_options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `SSA` object of the bit-vector function.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_names: the names for the input variables</span>
<span class="sd">            id_prefix: the prefix to denote the intermediate variables</span>
<span class="sd">            decompose_sec_ops: if ``decompose_sec_ops`` is ``True``,</span>
<span class="sd">                `SecondaryOperation` objects within the bit-vector function are</span>
<span class="sd">                replaced by their decompositions into  `PrimaryOperation` objects.</span>
<span class="sd">            ssa_options: options passed to the ``__init__`` method of `SSA`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">),</span> \
            <span class="sa">f</span><span class="s2">&quot;len(</span><span class="si">{</span><span class="n">input_names</span><span class="si">}</span><span class="s2">) != len(</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">input_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">id_prefix</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;input_name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> starts with prefix </span><span class="si">{</span><span class="n">id_prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">input_names</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_names</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found duplicated names in input_names </span><span class="si">{</span><span class="n">input_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">input_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_names</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">):</span>
            <span class="n">input_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
        <span class="n">input_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">input_vars</span><span class="p">)</span>

        <span class="n">table</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MemoizationTable</span><span class="p">(</span><span class="n">id_prefix</span><span class="o">=</span><span class="n">id_prefix</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Memoization</span><span class="p">(</span><span class="n">table</span><span class="p">),</span> <span class="n">context</span><span class="o">.</span><span class="n">SecondaryOperationEvaluation</span><span class="p">(</span><span class="n">decompose_sec_ops</span><span class="p">):</span>
            <span class="c1"># noinspection PyArgumentList</span>
            <span class="n">output_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">symbolic_inputs</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="c1">##debugging</span>
        <span class="c1"># print(f&quot;\n{cls.__name__}(input_vars) = {cls(*input_vars, symbolic_inputs=True, simplify=False)}&quot;)</span>
        <span class="c1"># print(&quot;Memoization | table.table:&quot;, table.table)</span>

        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_ignore_replace_multiuse_vars&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ssa_options</span><span class="p">[</span><span class="s2">&quot;replace_multiuse_vars&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">SSA</span><span class="p">(</span><span class="n">input_vars</span><span class="o">=</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">output_vars</span><span class="o">=</span><span class="n">output_vars</span><span class="p">,</span>
                   <span class="n">assignments</span><span class="o">=</span><span class="n">table</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="o">**</span><span class="n">ssa_options</span><span class="p">)</span></div>

<div class="viewcode-block" id="BvFunction.log_msg"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.BvFunction.log_msg">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">log_msg</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">format_string</span><span class="p">,</span> <span class="n">format_field_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Log a message during the evaluation of the bit-vector function.</span>

<span class="sd">        This method is meant to be used within `eval` to log the values</span>
<span class="sd">        of internal variables. At the beggining of each evaluation,</span>
<span class="sd">        messages logged from the last evaluation are automatically removed.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">            ...     input_widths, output_widths = [8, 8], [8, 8]</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x, y):</span>
<span class="sd">            ...         cls.log_msg(&#39;input variables = [{}, {}]&#39;, [x, y])</span>
<span class="sd">            ...         return x ^ y, x</span>
<span class="sd">            &gt;&gt;&gt; MyFoo(0, 1)</span>
<span class="sd">            (0x01, 0x00)</span>
<span class="sd">            &gt;&gt;&gt; MyFoo.get_formatted_logged_msgs()</span>
<span class="sd">            [&#39;input variables = [0x00, 0x01]&#39;]</span>

<span class="sd">        Args:</span>
<span class="sd">            format_string: a Python `format string</span>
<span class="sd">                 &lt;https://docs.python.org/3/library/string.html#formatstrings&gt;`_</span>
<span class="sd">            format_field_objects: an optional list with the objects that will</span>
<span class="sd">                replace the format fields in the format_string (i.e.,</span>
<span class="sd">                the arguments associated to ``format_string.format()``)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format_string</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">format_field_objects</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">format_field_objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format_field_objects</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">):</span>
            <span class="n">format_field_objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_field_objects</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format_string</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">format_string</span><span class="p">,</span> <span class="n">format_field_objects</span><span class="p">))</span></div>

<div class="viewcode-block" id="BvFunction.get_formatted_logged_msgs"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.BvFunction.get_formatted_logged_msgs">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_formatted_logged_msgs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of logged messages.</span>

<span class="sd">        If the bit-vector function includes `log_msg` calls in its ``eval``,</span>
<span class="sd">        this method return the list of messages logged in the last evaluation</span>
<span class="sd">        with the format field objects applied. Otherwise, an exception is raised.</span>

<span class="sd">        See also `log_msg`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;eval must be called before get_formatted_logged_msgs&quot;</span><span class="p">)</span>
        <span class="n">list_msgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">format_string</span><span class="p">,</span> <span class="n">format_field_objects</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_logger</span><span class="p">:</span>
            <span class="n">list_msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_string</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">format_field_objects</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">list_msgs</span></div>

    <span class="c1"># dotprinting last method</span>
<div class="viewcode-block" id="BvFunction.dotprinting"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.BvFunction.dotprinting">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">dotprinting</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_names</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vrepr_label</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the DOT description of the expression tree of the function.</span>

<span class="sd">        See also `printing.dotprinting`.</span>

<span class="sd">        Args:</span>
<span class="sd">            input_names: the names for the input variables</span>
<span class="sd">            repeat: whether to use different nodes for common subexpressions</span>
<span class="sd">                (default True)</span>
<span class="sd">            vrepr_label: wheter to use the verbose representation (`Term.vrepr`)</span>
<span class="sd">                to label the nodes (default False)</span>
<span class="sd">            kwargs: additional arguments passed to `printing.dotprinting`</span>

<span class="sd">        ::</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">            ...     input_widths, output_widths = [8], [8, 8]</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x):  return x, x ^ 1</span>
<span class="sd">            &gt;&gt;&gt; print(MyFoo.dotprinting([&quot;x&quot;], repeat=False))  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            digraph{</span>
<span class="sd">            # Graph style</span>
<span class="sd">            &quot;ordering&quot;=&quot;out&quot;</span>
<span class="sd">            &quot;rankdir&quot;=&quot;TD&quot;</span>
<span class="sd">            #########</span>
<span class="sd">            # Nodes #</span>
<span class="sd">            #########</span>
<span class="sd">            &quot;Tuple(Variable(&#39;x&#39;, width=8), BvXor(Variable(&#39;x&#39;, width=8), Constant(0b00000001, width=8)))&quot;</span>
<span class="sd">                [&quot;color&quot;=&quot;grey&quot;, &quot;label&quot;=&quot;Tuple&quot;, &quot;shape&quot;=&quot;ellipse&quot;];</span>
<span class="sd">            &quot;Variable(&#39;x&#39;, width=8)&quot; [&quot;color&quot;=&quot;aquamarine3&quot;, &quot;label&quot;=&quot;x&quot;, &quot;shape&quot;=&quot;box&quot;];</span>
<span class="sd">            &quot;BvXor(Variable(&#39;x&#39;, width=8), Constant(0b00000001, width=8))&quot;</span>
<span class="sd">                [&quot;color&quot;=&quot;black&quot;, &quot;label&quot;=&quot;BvXor&quot;, &quot;shape&quot;=&quot;ellipse&quot;];</span>
<span class="sd">            &quot;Constant(0b00000001, width=8)&quot; [&quot;color&quot;=&quot;blue1&quot;, &quot;label&quot;=&quot;0x01&quot;, &quot;shape&quot;=&quot;box&quot;];</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            #########</span>
<span class="sd">            # Edges #</span>
<span class="sd">            #########</span>
<span class="sd">            &quot;Tuple(Variable(&#39;x&#39;, width=8), BvXor(Variable(&#39;x&#39;, width=8), Constant(0b00000001, width=8)))&quot; -&gt;</span>
<span class="sd">                &quot;Variable(&#39;x&#39;, width=8)&quot;;</span>
<span class="sd">            &quot;Tuple(Variable(&#39;x&#39;, width=8), BvXor(Variable(&#39;x&#39;, width=8), Constant(0b00000001, width=8)))&quot; -&gt;</span>
<span class="sd">                &quot;BvXor(Variable(&#39;x&#39;, width=8), Constant(0b00000001, width=8))&quot;;</span>
<span class="sd">            &quot;BvXor(Variable(&#39;x&#39;, width=8), Constant(0b00000001, width=8))&quot; -&gt; &quot;Variable(&#39;x&#39;, width=8)&quot;;</span>
<span class="sd">            &quot;BvXor(Variable(&#39;x&#39;, width=8), Constant(0b00000001, width=8))&quot; -&gt; &quot;Constant(0b00000001, width=8)&quot;;</span>
<span class="sd">            }</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">cascada.bitvector.printing</span> <span class="kn">import</span> <span class="n">dotprinting</span>
        <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Tuple</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">),</span> \
            <span class="sa">f</span><span class="s2">&quot;len(</span><span class="si">{</span><span class="n">input_names</span><span class="si">}</span><span class="s2">) != len(</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="n">input_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_names</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">):</span>
            <span class="n">input_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
        <span class="n">input_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">input_vars</span><span class="p">)</span>

        <span class="n">outputs</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">*</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">symbolic_inputs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dotprinting</span><span class="p">(</span><span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="n">outputs</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">repeat</span><span class="p">,</span> <span class="n">vrepr_label</span><span class="o">=</span><span class="n">vrepr_label</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RoundBasedFunction"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.RoundBasedFunction">[docs]</a><span class="k">class</span> <span class="nc">RoundBasedFunction</span><span class="p">(</span><span class="n">BvFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent round-based fixed-width bit-vector functions.</span>

<span class="sd">    A `RoundBasedFunction` is a `BvFunction` that can be decomposed</span>
<span class="sd">    into *rounds*, where in each round some subroutine is computed</span>
<span class="sd">    (not necessarily the same). Moreoever, the next round not only</span>
<span class="sd">    can use the outputs of the previous round but also any of the</span>
<span class="sd">    previous variables computed.</span>

<span class="sd">    In practice, the ``eval`` method of `RoundBasedFunction`</span>
<span class="sd">    depends on the class attribute `num_rounds`, which can be changed by</span>
<span class="sd">    calling the method `set_num_rounds`.</span>

<span class="sd">    This class is not meant to be instantiated but to provide a base class for</span>
<span class="sd">    round-based bit-vector functions with fixed operands. To define such a</span>
<span class="sd">    function, subclass `RoundBasedFunction`, set the class attributes</span>
<span class="sd">    `input_widths` and ``output_widths`` and implement ``eval`` with bit-vector</span>
<span class="sd">    operations (similar as `BvFunction`). Moreover, set the class attribute</span>
<span class="sd">    `num_rounds` and implement `set_num_rounds`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.ssa import RoundBasedFunction</span>
<span class="sd">        &gt;&gt;&gt; class MyFoo(RoundBasedFunction):</span>
<span class="sd">        ...     input_widths, output_widths, num_rounds = [8, 8], [8, 8], 1</span>
<span class="sd">        ...     @classmethod</span>
<span class="sd">        ...     def eval(cls, x, y):</span>
<span class="sd">        ...         for _ in range(cls.num_rounds):  x, y = y, x + 1</span>
<span class="sd">        ...         return x, y</span>
<span class="sd">        ...     @classmethod</span>
<span class="sd">        ...     def set_num_rounds(cls, new_num_rounds):  cls.num_rounds = new_num_rounds</span>
<span class="sd">        &gt;&gt;&gt; MyFoo.get_name()</span>
<span class="sd">        &#39;MyFoo_1R&#39;</span>
<span class="sd">        &gt;&gt;&gt; MyFoo(0, 0)</span>
<span class="sd">        (0x00, 0x01)</span>
<span class="sd">        &gt;&gt;&gt; MyFoo.set_num_rounds(2)</span>
<span class="sd">        &gt;&gt;&gt; MyFoo.get_name()</span>
<span class="sd">        &#39;MyFoo_2R&#39;</span>
<span class="sd">        &gt;&gt;&gt; MyFoo(0, 0)</span>
<span class="sd">        (0x01, 0x01)</span>

<span class="sd">    Attributes:</span>
<span class="sd">        num_rounds: the number of rounds</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_rounds</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_rounds_outputs</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># private attribute as _logger</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">num_rounds</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;add_round_outputs must be called 0 or num_rounds times&quot;</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="RoundBasedFunction.get_name"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.RoundBasedFunction.get_name">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_name</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the class name and the current number of rounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">get_name</span><span class="p">()</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">num_rounds</span><span class="si">}</span><span class="s2">R&quot;</span></div>

<div class="viewcode-block" id="RoundBasedFunction.to_ssa"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.RoundBasedFunction.to_ssa">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">to_ssa</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_names</span><span class="p">,</span> <span class="n">id_prefix</span><span class="p">,</span> <span class="n">decompose_sec_ops</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">ssa_options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `SSA` object of the round-based bit-vector function.</span>

<span class="sd">        This method calls `BvFunction.to_ssa` with the same argument list,</span>
<span class="sd">        and stores the round outputs in the `SSA` object if `add_round_outputs`</span>
<span class="sd">        calls were added in ``eval``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">my_ssa</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">to_ssa</span><span class="p">(</span><span class="n">input_names</span><span class="p">,</span> <span class="n">id_prefix</span><span class="p">,</span> <span class="n">decompose_sec_ops</span><span class="o">=</span><span class="n">decompose_sec_ops</span><span class="p">,</span> <span class="o">**</span><span class="n">ssa_options</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">my_ssa</span><span class="o">.</span><span class="n">_rounds_outputs</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span><span class="p">[:]</span>
        <span class="k">return</span> <span class="n">my_ssa</span></div>

<div class="viewcode-block" id="RoundBasedFunction.set_num_rounds"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.RoundBasedFunction.set_num_rounds">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set_num_rounds</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new_num_rounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set `RoundBasedFunction.num_rounds` and update `input_widths` and ``output_widths`` if necessary.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;subclasses need to override this method&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RoundBasedFunction.set_num_rounds_and_return"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.RoundBasedFunction.set_num_rounds_and_return">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">set_num_rounds_and_return</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new_num_rounds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call `set_num_rounds` and return ``cls``.&quot;&quot;&quot;</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">set_num_rounds</span><span class="p">(</span><span class="n">new_num_rounds</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span></div>

<div class="viewcode-block" id="RoundBasedFunction.vrepr"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.RoundBasedFunction.vrepr">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">vrepr</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an executable string representation.</span>

<span class="sd">        This method returns a string so that ``eval(cls.vrepr())``</span>
<span class="sd">        returns a new `RoundBasedFunction` object with the same content.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span><span class="si">}</span><span class="s2">.set_num_rounds_and_return(</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">num_rounds</span><span class="si">}</span><span class="s2">)&quot;</span></div>

<div class="viewcode-block" id="RoundBasedFunction.add_round_outputs"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.RoundBasedFunction.add_round_outputs">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">add_round_outputs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Store the current round outputs in the evaluation of the round-based function.</span>

<span class="sd">        This method is meant to be used within ``eval`` to store the outputs</span>
<span class="sd">        of each round. At the beggining of each evaluation, round ouputs stored</span>
<span class="sd">        in the last evaluation are automatically removed.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import RoundBasedFunction</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(RoundBasedFunction):</span>
<span class="sd">            ...     input_widths, output_widths, num_rounds = [8, 8], [8, 8], 1</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x, y):</span>
<span class="sd">            ...         for _ in range(cls.num_rounds):</span>
<span class="sd">            ...             x, y = y, x + 1</span>
<span class="sd">            ...             cls.add_round_outputs(x, y)</span>
<span class="sd">            ...         return x, y</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def set_num_rounds(cls, new_num_rounds):  cls.num_rounds = new_num_rounds</span>
<span class="sd">            &gt;&gt;&gt; MyFoo.set_num_rounds(3)</span>
<span class="sd">            &gt;&gt;&gt; MyFoo(0, 0)</span>
<span class="sd">            (0x01, 0x02)</span>
<span class="sd">            &gt;&gt;&gt; MyFoo.get_rounds_outputs()</span>
<span class="sd">            ((0x00, 0x01), (0x01, 0x01), (0x01, 0x02))</span>
<span class="sd">            &gt;&gt;&gt; MyFoo(Variable(&quot;x&quot;, 8), Variable(&quot;y&quot;, 8), symbolic_inputs=True)</span>
<span class="sd">            (y + 0x01, x + 0x02)</span>
<span class="sd">            &gt;&gt;&gt; MyFoo.get_rounds_outputs()</span>
<span class="sd">            ((y, x + 0x01), (x + 0x01, y + 0x01), (y + 0x01, x + 0x02))</span>

<span class="sd">        Args:</span>
<span class="sd">            args: a list of bit-vectors representing the outputs of the current round.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">)</span> <span class="k">for</span> <span class="n">bv</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the arguments of add_round_outputs must be a bit-vectors&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">))</span></div>

<div class="viewcode-block" id="RoundBasedFunction.get_rounds_outputs"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.RoundBasedFunction.get_rounds_outputs">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_rounds_outputs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the list of round outputs obtained in the last evaluation.</span>

<span class="sd">        See also `add_round_outputs`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;eval must be called before get_rounds_outputs&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_rounds_outputs</span></div></div>


<div class="viewcode-block" id="SSAReturn"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSAReturn">[docs]</a><span class="k">class</span> <span class="nc">SSAReturn</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvIdentity</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Subclass of `BvIdentity` used to denote the returned variables in `SSA`.</span>

<span class="sd">    Note that both `BvIdentity` and `SSAReturn` have the same string representation</span>
<span class="sd">    (but different `Term.vrepr`).</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvIdentity</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.ssa import SSAReturn</span>
<span class="sd">        &gt;&gt;&gt; BvIdentity(Constant(0x1, 4)), SSAReturn(Constant(0x1, 4))</span>
<span class="sd">        (0x1, 0x1)</span>
<span class="sd">        &gt;&gt;&gt; BvIdentity(Variable(&quot;x&quot;, 8)), SSAReturn(Variable(&quot;x&quot;, 8))</span>
<span class="sd">        (Id(x), Id(x))</span>
<span class="sd">        &gt;&gt;&gt; BvIdentity(Variable(&quot;x&quot;, 8)).vrepr(), SSAReturn(Variable(&quot;x&quot;, 8)).vrepr()</span>
<span class="sd">        (&quot;BvIdentity(Variable(&#39;x&#39;, width=8))&quot;, &quot;SSAReturn(Variable(&#39;x&#39;, width=8))&quot;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="SSA"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSA">[docs]</a><span class="k">class</span> <span class="nc">SSA</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent a `BvFunction` as a static single assignment program.</span>

<span class="sd">    An `SSA` object represents a decomposition of a `BvFunction`</span>
<span class="sd">    into a list of *simple* assignments :math:`x_{i+1} \leftarrow f_i(x_i)`,</span>
<span class="sd">    similar as the method `memoization_table` for `Operation` objects.</span>
<span class="sd">    Recall a *simple* assignment is given by the output `Variable`</span>
<span class="sd">    :math:`x_{i+1}` representing the output of the given</span>
<span class="sd">    `Operation` :math:`f_i(x_i)`, where :math:`x_i` is an input or</span>
<span class="sd">    previous output `Variable`, a `Constant`, a scalar, or a list of them</span>
<span class="sd">    (but not an `Operation` object).</span>

<span class="sd">    An `SSA` object is defined for</span>

<span class="sd">    -  A list of `Variable` objects representing the inputs of the bit-vector function.</span>
<span class="sd">    -  A list of `Variable` objects representing the outputs of the function.</span>
<span class="sd">    -  The list of of assignments as a `collections.OrderedDict` mapping</span>
<span class="sd">       each intermediate `Variable` :math:`x_{i+1}` to the `Operation` :math:`f_i(x_i)`.</span>

<span class="sd">    The assignments might contain variables not defined in previous assignments</span>
<span class="sd">    nor contained in the input variables.</span>
<span class="sd">    These variables are called *external variables* and are stored</span>
<span class="sd">    in the attribute `external_vars`.</span>

<span class="sd">    Apart from these three initialization argument,</span>
<span class="sd">    if the initialization argument ``replace_multiuse_vars`` is set</span>
<span class="sd">    to ``True``, variables appearing two or more times</span>
<span class="sd">    in the list of assignments (as arguments of `Operation` objects</span>
<span class="sd">    excluding `BvIdentity`) are replaced by new variables (ending in</span>
<span class="sd">    ``__d`` where ``d`` is the occurrence index) that are used only once.</span>
<span class="sd">    In this case, the mapping from the old multiuse variables</span>
<span class="sd">    to the new singleuse variables is stored in ``multiuse_var2singleuse_vars``.</span>
<span class="sd">    In other words, new variables are created to uniquely label each</span>
<span class="sd">    branch of the forking subroutine (see `LinearModelFreeBranch`).</span>

<span class="sd">    .. note::</span>

<span class="sd">        For example, with ``replace_multiuse_vars=True`` the assignment list</span>
<span class="sd">        ``(a0, x + 1), (a1, x &amp; 1)`` is replaced by</span>
<span class="sd">        ``(x__0, Id(x)), (x__1, Id(x)) (a0, x__0 + 1), (a1, x__1 &amp; 1)``.</span>

<span class="sd">    `SSA` objects can be easily created from `BvFunction.to_ssa`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        When initializing the SSA object, external variables are</span>
<span class="sd">        automatically obtained, redundant assignments are automatically</span>
<span class="sd">        removed (and a warning is printed in this case), and</span>
<span class="sd">        partial operations are automatically created from</span>
<span class="sd">        operations with constant or scalar operands.</span>

<span class="sd">        Moreover, additional assignments with the operations `BvIdentity`</span>
<span class="sd">        and `SSAReturn` might be added at the end.</span>
<span class="sd">        These last assignemnts are added to ensure that each output</span>
<span class="sd">        variable of the `SSA` has a unique name (ending in ``_out``)</span>
<span class="sd">        and to ensure that the output variables of the last assignments</span>
<span class="sd">        are actually the output variables of the `SSA`.</span>
<span class="sd">        If these assignments are already present in the given</span>
<span class="sd">        list of assigments no additional ones are added.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">        &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">        ...     input_widths, output_widths = [8, 8], [8, 8]</span>
<span class="sd">        ...     @classmethod</span>
<span class="sd">        ...     def eval(cls, x, y):  return x ^ y, x</span>
<span class="sd">        &gt;&gt;&gt; MyFoo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;a&quot;)  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">        SSA(input_vars=[x, y], output_vars=[a0_out, x_out],</span>
<span class="sd">            assignments=[(a0, x ^ y), (a0_out, Id(a0)), (x_out, Id(x))])</span>
<span class="sd">        &gt;&gt;&gt; ssa = MyFoo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;a&quot;, replace_multiuse_vars=True)</span>
<span class="sd">        &gt;&gt;&gt; ssa  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">        SSA(input_vars=[x, y], output_vars=[a0_out, x_out],</span>
<span class="sd">            assignments=[(x__0, Id(x)), (x__1, Id(x)), (a0, x__0 ^ y), (a0_out, Id(a0)), (x_out, Id(x__1))])</span>
<span class="sd">        &gt;&gt;&gt; ssa.multiuse_var2singleuse_vars, ssa.singleuse_var2multiuse_var</span>
<span class="sd">        (OrderedDict([(x, [x__0, x__1])]), OrderedDict([(x__0, x), (x__1, x)]))</span>
<span class="sd">        &gt;&gt;&gt; last_assignments = list(ssa.assignments.items())[-len(ssa.output_vars):]</span>
<span class="sd">        &gt;&gt;&gt; for var, expr in last_assignments: print(var.vrepr(), &quot;, &quot;, expr.vrepr(), sep=&quot;&quot;)</span>
<span class="sd">        Variable(&#39;a0_out&#39;, width=8), SSAReturn(Variable(&#39;a0&#39;, width=8))</span>
<span class="sd">        Variable(&#39;x_out&#39;, width=8), SSAReturn(Variable(&#39;x__1&#39;, width=8))</span>

<span class="sd">    Attributes:</span>
<span class="sd">        input_vars: a list of `Variable` objects representing the inputs.</span>
<span class="sd">        output_vars: a list of `Variable` objects representing the outputs.</span>
<span class="sd">        assignments: a `collections.OrderedDict` containing the assignments</span>
<span class="sd">            (`Variable`, `Operation`) of the SSA program.</span>
<span class="sd">        external_vars: a list of `Variable` objects which appear in the</span>
<span class="sd">            assignments but are not defined in previous assignments</span>
<span class="sd">            nor contained in the input variables.</span>
<span class="sd">        multiuse_var2singleuse_vars: an empty dictionary if the initialization</span>
<span class="sd">            argument ``replace_multiuse_vars`` is set to ``False``, otherwise</span>
<span class="sd">            a `collections.OrderedDict` mapping the old multiuse variables</span>
<span class="sd">            to the new singleused variables.</span>
<span class="sd">        singleuse_var2multiuse_var: the inverse mapping of</span>
<span class="sd">            ``multiuse_var2singleuse_vars``.</span>

<span class="sd">    .. Implementation details::</span>
<span class="sd">        This class does not decompose secondary operations into</span>
<span class="sd">        primary ones. This is implemented in `BvFunction.to_ssa`.</span>

<span class="sd">        The list of assignments is not stored as a `MemoizationTable`</span>
<span class="sd">        (a bidict.OrderedBidict()) since duplicated operation objects</span>
<span class="sd">        might be contained in the list of assignments.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_vars</span><span class="p">,</span> <span class="n">output_vars</span><span class="p">,</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">replace_multiuse_vars</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">input_vars</span><span class="p">),</span> \
            <span class="sa">f</span><span class="s2">&quot;expected a list of Variable for the input_vars, not </span><span class="si">{</span><span class="n">input_vars</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_vars</span><span class="p">),</span> \
            <span class="sa">f</span><span class="s2">&quot;expected a list of Variable for the output_vars, not </span><span class="si">{</span><span class="n">output_vars</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">input_vars</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_vars</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found duplicated vars in input_vars </span><span class="si">{</span><span class="n">input_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">output_vars</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_vars</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found duplicated vars in output_vars </span><span class="si">{</span><span class="n">output_vars</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">input_vars</span> <span class="o">=</span> <span class="n">input_vars</span><span class="p">[:]</span>
        <span class="n">output_vars</span> <span class="o">=</span> <span class="n">output_vars</span><span class="p">[:]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">):</span>
            <span class="n">assignments</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span><span class="n">assignments</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">assignments</span> <span class="o">=</span> <span class="n">assignments</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">is_simple_assignment</span><span class="p">(</span><span class="n">my_outvar</span><span class="p">,</span> <span class="n">my_expr</span><span class="p">,</span> <span class="n">raise_exception</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_expr</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">Operation</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found invalid assignment (expr is not an Operation): </span><span class="si">{</span><span class="n">my_outvar</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_expr</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvIdentity</span><span class="p">)</span> <span class="ow">and</span> <span class="n">my_expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">my_outvar</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;redundant identity operations </span><span class="si">{</span><span class="n">my_outvar</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="n">my_expr</span><span class="si">}</span><span class="s2"> not supported&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">my_arg</span> <span class="ow">in</span> <span class="n">my_expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_arg</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">Operation</span><span class="p">)</span> <span class="ow">or</span> \
                        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found not simple assignment </span><span class="si">{</span><span class="n">my_outvar</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="n">my_expr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">outvar</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">is_simple_assignment</span><span class="p">(</span><span class="n">outvar</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_are_last_assignments_valid</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">output_vars</span><span class="p">):</span>
            <span class="c1"># _make_last_assignments_valid before _replace_multiuse_vars</span>
            <span class="c1"># as the first call might create branches</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_make_last_assignments_valid</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">output_vars</span><span class="p">,</span> <span class="n">input_vars</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_old_outvar_assignments</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">assignments</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">arg2outvars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>  <span class="c1"># list of outvar where arg appears as operand</span>
        <span class="n">set_in_out_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">input_vars</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">output_vars</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">find_partial_and_redundant_assignments</span><span class="p">(</span><span class="n">ignore_arg2outvars</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_arg2outvars</span><span class="p">:</span>
                <span class="n">arg2outvars</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">to_delete</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vars_needed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">output_vars</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">my_outvar</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">assignments</span><span class="p">):</span>
                <span class="c1"># find partial operations</span>
                <span class="n">my_expr</span> <span class="o">=</span> <span class="n">assignments</span><span class="p">[</span><span class="n">my_outvar</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">))</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">my_expr</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                    <span class="n">fixed_args</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">my_expr</span><span class="o">.</span><span class="n">args</span><span class="p">):</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)):</span>
                            <span class="n">fixed_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">fixed_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                            <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                    <span class="n">expr_op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">make_partial_operation</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">my_expr</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fixed_args</span><span class="p">))</span>
                    <span class="n">my_expr</span> <span class="o">=</span> <span class="n">expr_op</span><span class="p">(</span><span class="o">*</span><span class="n">new_args</span><span class="p">)</span>
                    <span class="n">assignments</span><span class="p">[</span><span class="n">my_outvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_expr</span>
                <span class="c1"># find non-redundant assignments</span>
                <span class="k">if</span> <span class="n">my_outvar</span> <span class="ow">in</span> <span class="n">vars_needed</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">my_expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>  <span class="c1"># expr.atoms() not needed due to simple assignments</span>
                        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span>
                        <span class="n">vars_needed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_arg2outvars</span> <span class="ow">and</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set_in_out_vars</span> <span class="ow">and</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">assignments</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_expr</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvIdentity</span><span class="p">)</span> <span class="ow">or</span> \
                                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">assignments</span><span class="p">[</span><span class="n">arg</span><span class="p">],</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvIdentity</span><span class="p">):</span>
                                <span class="c1"># added 2 occurrences to ensure it is not used when simplified</span>
                                <span class="n">arg2outvars</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">arg2outvars</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg2outvars</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span><span class="n">my_outvar</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">my_outvar</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">to_delete</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;removing redundant assignments </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">my_outvar</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">my_outvar</span><span class="p">])</span> <span class="k">for</span> <span class="n">my_outvar</span> <span class="ow">in</span> <span class="n">to_delete</span><span class="p">]))</span>
                <span class="k">for</span> <span class="n">my_outvar</span> <span class="ow">in</span> <span class="n">to_delete</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">assignments</span><span class="p">[</span><span class="n">my_outvar</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="o">.</span><span class="n">current_context</span><span class="p">:</span>
            <span class="n">find_partial_and_redundant_assignments</span><span class="p">(</span><span class="n">ignore_arg2outvars</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">assignments_xreplace</span><span class="p">(</span><span class="n">my_dict</span><span class="p">):</span>
                <span class="c1"># assume keys() in my_dict are not in assignments</span>
                <span class="n">my_outvar2ct_expr</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">my_outvar</span> <span class="ow">in</span> <span class="n">assignments</span><span class="p">:</span>
                    <span class="n">my_expr</span> <span class="o">=</span> <span class="n">assignments</span><span class="p">[</span><span class="n">my_outvar</span><span class="p">]</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>
                    <span class="n">assignments</span><span class="p">[</span><span class="n">my_outvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_expr</span>
                    <span class="c1"># vars are not removed from SSA to avoid side effects</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_expr</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
                        <span class="n">assignments</span><span class="p">[</span><span class="n">my_outvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvIdentity</span><span class="p">(</span><span class="n">my_expr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_expr</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                        <span class="n">my_outvar2ct_expr</span><span class="p">[</span><span class="n">my_outvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">my_expr</span>
                <span class="k">if</span> <span class="n">my_outvar2ct_expr</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">my_outvar</span> <span class="ow">in</span> <span class="n">my_outvar2ct_expr</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="k">del</span> <span class="n">assignments</span><span class="p">[</span><span class="n">my_outvar</span><span class="p">]</span>
                    <span class="n">assignments_xreplace</span><span class="p">(</span><span class="n">my_outvar2ct_expr</span><span class="p">)</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">find_partial_and_redundant_assignments</span><span class="p">(</span><span class="n">ignore_arg2outvars</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="c1"># only variables appearing once in assignments</span>
                <span class="n">arg2outvars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">arg</span><span class="p">,</span> <span class="n">outvars</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">outvars</span> <span class="ow">in</span> <span class="n">arg2outvars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">outvars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># print(f&quot;\nbefore simplifying\n\targ2outvars = {arg2outvars}\n\tassignments: {assignments}&quot;)</span>

                <span class="n">assignments_modified</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">outvar</span> <span class="ow">in</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arg2outvars</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                    <span class="c1"># outvar can also be a previous arg its assignment</span>
                    <span class="c1"># could have been deleted (in del assignments[arg])</span>
                    <span class="k">if</span> <span class="n">outvar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">assignments</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">new_expr</span> <span class="o">=</span> <span class="n">assignments</span><span class="p">[</span><span class="n">outvar</span><span class="p">]</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">arg</span><span class="p">:</span> <span class="n">assignments</span><span class="p">[</span><span class="n">arg</span><span class="p">]})</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_expr</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
                        <span class="c1"># avoid replacing vars</span>
                        <span class="n">new_expr</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvIdentity</span><span class="p">(</span><span class="n">new_expr</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_expr</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">or</span> \
                            <span class="n">is_simple_assignment</span><span class="p">(</span><span class="n">outvar</span><span class="p">,</span> <span class="n">new_expr</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;assignment (</span><span class="si">{</span><span class="n">outvar</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">assignments</span><span class="p">[</span><span class="n">outvar</span><span class="p">]</span><span class="si">}</span><span class="s2">) was simplified to &quot;</span>
                                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_expr</span><span class="si">}</span><span class="s2"> using </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="n">assignments</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">assignments_modified</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">del</span> <span class="n">assignments</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_expr</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                            <span class="k">del</span> <span class="n">assignments</span><span class="p">[</span><span class="n">outvar</span><span class="p">]</span>
                            <span class="n">assignments_xreplace</span><span class="p">({</span><span class="n">outvar</span><span class="p">:</span> <span class="n">new_expr</span><span class="p">})</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">assignments</span><span class="p">[</span><span class="n">outvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_expr</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">assignments_modified</span><span class="p">:</span>
                    <span class="k">break</span>

        <span class="k">if</span> <span class="n">replace_multiuse_vars</span><span class="p">:</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_multiuse_vars</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">output_vars</span><span class="p">,</span> <span class="n">input_vars</span><span class="p">)</span>
            <span class="n">assignments</span><span class="p">,</span> <span class="n">multiuse_var2singleuse_vars</span><span class="p">,</span> <span class="n">singleuse_var2multiuse_var</span> <span class="o">=</span> <span class="n">aux</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">multiuse_var2singleuse_vars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">singleuse_var2multiuse_var</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_are_last_assignments_valid</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">output_vars</span><span class="p">,</span> <span class="n">ignore_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">external_vars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">input_vars_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">input_vars</span><span class="p">)</span>
        <span class="n">input_vars_used_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">outvar</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">Operation</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;assignment </span><span class="si">{</span><span class="n">outvar</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2"> not properly decomposed&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">input_vars_set</span><span class="p">:</span>
                        <span class="n">input_vars_used_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">assignments</span><span class="p">:</span>  <span class="c1"># arg not an outvar</span>
                        <span class="k">assert</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_vars</span>
                        <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">external_vars</span><span class="p">:</span>  <span class="c1"># avoid duplicates</span>
                            <span class="n">external_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="n">input_vars_not_used</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">input_vars_set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">input_vars_used_set</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">input_vars_not_used</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;found unused input vars </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">input_vars_not_used</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">input_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assignments</span> <span class="o">=</span> <span class="n">assignments</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">external_vars</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">external_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiuse_var2singleuse_vars</span> <span class="o">=</span> <span class="n">multiuse_var2singleuse_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">singleuse_var2multiuse_var</span> <span class="o">=</span> <span class="n">singleuse_var2multiuse_var</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_replace_multiuse_vars_bool</span> <span class="o">=</span> <span class="n">replace_multiuse_vars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_input_vars_not_used</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">input_vars_not_used</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_replace_multiuse_vars</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">output_vars</span><span class="p">,</span> <span class="n">input_vars</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">)</span>

        <span class="n">multiuse_var2singleuse_vars</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">singleuse_var2multiuse_var</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># 1st iteration: find multiuse vars (variables used 2+ times)</span>

        <span class="n">var2occurrences</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">var2assigns_with_var</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var_i</span><span class="p">,</span> <span class="n">expr_i</span> <span class="ow">in</span> <span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">var_j</span> <span class="ow">in</span> <span class="n">expr_i</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_j</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
                    <span class="n">var2occurrences</span><span class="p">[</span><span class="n">var_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">var2occurrences</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_j</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">var2assigns_with_var</span><span class="p">[</span><span class="n">var_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">var2assigns_with_var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var_j</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[(</span><span class="n">var_i</span><span class="p">,</span> <span class="n">expr_i</span><span class="p">)]</span>

        <span class="c1"># vars v where all the occurrences are * &lt;- BvIdentity(v) (and not SSAReturn) do not need to be replaced</span>
        <span class="c1"># (but they need to be stored in multi2single and single2multi)</span>
        <span class="k">for</span> <span class="n">var_j</span><span class="p">,</span> <span class="n">assigns</span> <span class="ow">in</span> <span class="n">var2assigns_with_var</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assigns</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvIdentity</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">assigns</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">var2occurrences</span><span class="p">[</span><span class="n">var_j</span><span class="p">]</span>
                <span class="c1"># see below definition of var_j and var_j__k</span>
                <span class="n">multiuse_var2singleuse_vars</span><span class="p">[</span><span class="n">var_j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">var_i</span><span class="p">,</span> <span class="n">expr_i</span> <span class="ow">in</span> <span class="n">assigns</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">expr_i</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">var_j</span>
                    <span class="n">var_j__k</span> <span class="o">=</span> <span class="n">var_i</span>
                    <span class="k">assert</span> <span class="n">var_j__k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">multiuse_var2singleuse_vars</span>
                    <span class="k">assert</span> <span class="n">var_j__k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">singleuse_var2multiuse_var</span>
                    <span class="n">multiuse_var2singleuse_vars</span><span class="p">[</span><span class="n">var_j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_j__k</span><span class="p">)</span>
                    <span class="n">singleuse_var2multiuse_var</span><span class="p">[</span><span class="n">var_j__k</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_j</span>

        <span class="n">multiuse_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">var_j</span><span class="p">,</span> <span class="n">occurrences</span> <span class="ow">in</span> <span class="n">var2occurrences</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">occurrences</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">var_j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_vars</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var_j</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">output_vars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">multiuse_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var_j</span><span class="p">)</span>

        <span class="c1"># var2occurrences = out_var + external vars</span>
        <span class="n">all_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">output_vars</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">var2occurrences</span><span class="p">)</span>
        <span class="n">branch_infix</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">branch_infix</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                    <span class="n">branch_infix</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># 2nd iteration: replace multiuse variables by new unique variables</span>
        <span class="c1">#                and add new assignments to define the new variables</span>
        <span class="n">new_assignments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">var_i</span><span class="p">,</span> <span class="n">expr_i</span> <span class="ow">in</span> <span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># var_i no need to replace, only the vars (the args) in expr_i</span>
            <span class="n">new_args_expr_i</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">var_j</span> <span class="ow">in</span> <span class="n">expr_i</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_j</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span> <span class="ow">or</span> <span class="n">var_j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">multiuse_vars</span><span class="p">:</span>
                    <span class="n">new_args_expr_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_j</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># var_j is a branched variable that appears in expr_i</span>
                    <span class="c1"># var_j__k is the new variable replacing (in expr_i) the k-th global occurrence var_j</span>

                    <span class="k">if</span> <span class="n">var_j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">multiuse_var2singleuse_vars</span><span class="p">:</span>  <span class="c1"># first occurrence of var_j in ssa</span>
                        <span class="n">multiuse_var2singleuse_vars</span><span class="p">[</span><span class="n">var_j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="c1"># we define all var_j__k variables consecutively for readability</span>
                        <span class="c1"># with at least 2 underscores (branch_infix) to avoid collisions with MemoizationTable</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">var2occurrences</span><span class="p">[</span><span class="n">var_j</span><span class="p">]):</span>
                            <span class="n">var_j__k</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var_j</span><span class="o">.</span><span class="n">name</span><span class="si">}{</span><span class="n">branch_infix</span><span class="si">}{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">var_j</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">var_j__k</span> <span class="ow">in</span> <span class="n">all_vars</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new variable var_j</span><span class="si">{</span><span class="n">branch_infix</span><span class="si">}</span><span class="s2">k=</span><span class="si">{</span><span class="n">var_j__k</span><span class="si">}</span><span class="s2"> already in SSA, &quot;</span>
                                                 <span class="sa">f</span><span class="s2">&quot;input_vars=</span><span class="si">{</span><span class="n">input_vars</span><span class="si">}</span><span class="s2">, output_vars=</span><span class="si">{</span><span class="n">output_vars</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2">&quot;</span>
                                                 <span class="sa">f</span><span class="s2">&quot;assignments=</span><span class="si">{</span><span class="n">assignments</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">new_assignments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">var_j__k</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvIdentity</span><span class="p">(</span><span class="n">var_j</span><span class="p">)))</span>

                    <span class="n">name_var_j__k</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var_j</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">branch_infix</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">multiuse_var2singleuse_vars</span><span class="p">[</span><span class="n">var_j</span><span class="p">]))</span>
                    <span class="n">var_j__k</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">name_var_j__k</span><span class="p">,</span> <span class="n">var_j</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
                    <span class="n">new_args_expr_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_j__k</span><span class="p">)</span>

                    <span class="k">assert</span> <span class="n">var_j__k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">multiuse_var2singleuse_vars</span>
                    <span class="k">assert</span> <span class="n">var_j__k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">singleuse_var2multiuse_var</span>
                    <span class="n">multiuse_var2singleuse_vars</span><span class="p">[</span><span class="n">var_j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_j__k</span><span class="p">)</span>
                    <span class="n">singleuse_var2multiuse_var</span><span class="p">[</span><span class="n">var_j__k</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_j</span>

            <span class="k">if</span> <span class="n">new_args_expr_i</span> <span class="o">!=</span> <span class="n">expr_i</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="n">expr_i</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr_i</span><span class="p">)(</span><span class="o">*</span><span class="n">new_args_expr_i</span><span class="p">)</span>
            <span class="n">new_assignments</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">var_i</span><span class="p">,</span> <span class="n">expr_i</span><span class="p">))</span>

        <span class="n">new_assignments</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span><span class="n">new_assignments</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_assignments</span><span class="p">,</span> <span class="n">multiuse_var2singleuse_vars</span><span class="p">,</span> <span class="n">singleuse_var2multiuse_var</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_are_last_assignments_valid</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">output_vars</span><span class="p">,</span> <span class="n">ignore_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check whether the last assignments are SSAReturn of the output variables.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">assignments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">last_assignments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">assign_outvar</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">assignments</span><span class="p">):</span>
            <span class="n">last_assignments</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">assign_outvar</span><span class="p">,</span> <span class="n">assignments</span><span class="p">[</span><span class="n">assign_outvar</span><span class="p">]])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">last_assignments</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_vars</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="n">last_assignments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">last_assignments</span><span class="p">))</span>  <span class="c1"># proper order</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">assign_outvar</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">last_assignments</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">assign_outvar</span> <span class="o">==</span> <span class="n">output_vars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> \
                    <span class="ow">not</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">SSAReturn</span><span class="p">))</span> <span class="ow">or</span> \
                    <span class="ow">not</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">output_vars</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_exception</span><span class="p">:</span>
                    <span class="n">last_assignments_vrepr</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="o">.</span><span class="n">vrepr</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">vrepr</span><span class="p">())</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">last_assignments</span><span class="p">]</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;last assignments are not of the form &quot;</span>
                                     <span class="s2">&quot;output_var &lt;- SSAReturn(non_output_var)&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">output vars = </span><span class="si">{</span><span class="n">output_vars</span><span class="si">}</span><span class="s2">&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">last assignments </span><span class="si">{</span><span class="n">last_assignments_vrepr</span><span class="si">}</span><span class="s2">&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">assignments</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_make_last_assignments_valid</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">output_vars</span><span class="p">,</span> <span class="n">input_vars</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assignments</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">)</span>
        <span class="c1"># avoid using MemoizationTable since duplicate expr will be added</span>

        <span class="c1"># any output var appearing twice or more in the list of output_vars</span>
        <span class="c1"># is replaced by a new variable with a different name</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_vars</span><span class="p">)):</span>
            <span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">output_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_vars</span><span class="p">[:</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">old_v_i</span> <span class="o">=</span> <span class="n">output_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># new name just _ to avoid collision with MemoizationTable and _replace_multiuse_vars</span>
                <span class="n">new_v_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">old_v_i</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_&quot;</span><span class="p">,</span> <span class="n">old_v_i</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_v_i</span> <span class="ow">in</span> <span class="n">assignments</span> <span class="ow">or</span> <span class="n">new_v_i</span> <span class="ow">in</span> <span class="n">input_vars</span> <span class="ow">or</span> <span class="n">new_v_i</span> <span class="ow">in</span> <span class="n">output_vars</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new variable new_v_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">new_v_i</span><span class="si">}</span><span class="s2"> already in SSA, &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;input_vars=</span><span class="si">{</span><span class="n">input_vars</span><span class="si">}</span><span class="s2">, output_vars=</span><span class="si">{</span><span class="n">output_vars</span><span class="si">}</span><span class="s2">,&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">assignments=</span><span class="si">{</span><span class="n">assignments</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># duplicate expr in assignments are allowed</span>
                <span class="n">assignments</span><span class="p">[</span><span class="n">new_v_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvIdentity</span><span class="p">(</span><span class="n">old_v_i</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_vars</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">output_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">old_v_i</span><span class="p">:</span>
                        <span class="n">output_vars</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_v_i</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">output_vars</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_vars</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_vars</span><span class="p">)):</span>
            <span class="c1"># SSAReturn is used to ensure the output variables</span>
            <span class="c1"># come from the last operations in the MemoizationTable</span>
            <span class="c1"># (SSAReturn used instead of BvIdentity to ensure that</span>
            <span class="c1"># SSAReturn inputs are not outputs of previous SSAReturn)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">output_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">new_v_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_out&quot;</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="n">new_expr</span> <span class="o">=</span> <span class="n">SSAReturn</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_v_i</span> <span class="ow">in</span> <span class="n">assignments</span> <span class="ow">or</span> <span class="n">new_v_i</span> <span class="ow">in</span> <span class="n">input_vars</span> <span class="ow">or</span> <span class="n">new_v_i</span> <span class="ow">in</span> <span class="n">output_vars</span> <span class="ow">or</span> \
                    <span class="n">new_expr</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">assignments</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;new assignment new_v_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">new_v_i</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="n">new_expr</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span><span class="si">}</span><span class="s2"> &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;already in SSA (either the output variable or the expr), &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;input_vars=</span><span class="si">{</span><span class="n">input_vars</span><span class="si">}</span><span class="s2">, output_vars=</span><span class="si">{</span><span class="n">output_vars</span><span class="si">}</span><span class="s2">,&quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">assignments=</span><span class="si">{</span><span class="n">assignments</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">output_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_v_i</span>
            <span class="n">assignments</span><span class="p">[</span><span class="n">new_v_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_expr</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">output_vars</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_vars</span><span class="p">:</span>
            <span class="n">aux_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; external_vars=[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_vars</span><span class="p">])</span><span class="si">}</span><span class="s2">],&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aux_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(input_vars=</span><span class="si">{}</span><span class="s2">, output_vars=</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2"> assignments=</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="c1"># str(self.input_vars) ignored to print it in a list-like way</span>
            <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">])</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">])</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
            <span class="n">aux_str</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">)&#39;</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="fm">__repr__</span> <span class="o">=</span> <span class="fm">__str__</span>

<div class="viewcode-block" id="SSA.vrepr"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSA.vrepr">[docs]</a>    <span class="k">def</span> <span class="nf">vrepr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an executable string representation.</span>

<span class="sd">        This method returns a string so that</span>
<span class="sd">        ``eval(self.vrepr())`` returns a new `SSA` object</span>
<span class="sd">        with the same content.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.operation import BvXor, BvIdentity</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">            &gt;&gt;&gt; z = Variable(&quot;z&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">            ...     input_widths, output_widths = [8, 8], [8, 8]</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x, y):  return y ^ z, x ^ 1</span>
<span class="sd">            &gt;&gt;&gt; MyFoo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;i&quot;).vrepr()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            &quot;SSA(input_vars=[Variable(&#39;x&#39;, width=8), Variable(&#39;y&#39;, width=8)],</span>
<span class="sd">                output_vars=[Variable(&#39;i0_out&#39;, width=8), Variable(&#39;i1_out&#39;, width=8)],</span>
<span class="sd">                assignments=[(Variable(&#39;i0&#39;, width=8), BvXor(Variable(&#39;y&#39;, width=8), Variable(&#39;z&#39;, width=8))),</span>
<span class="sd">                    (Variable(&#39;i1&#39;, width=8),</span>
<span class="sd">                        make_partial_operation(BvXor, (None, Constant(0b00000001, width=8)))(Variable(&#39;x&#39;, width=8))),</span>
<span class="sd">                    (Variable(&#39;i0_out&#39;, width=8), SSAReturn(Variable(&#39;i0&#39;, width=8))),</span>
<span class="sd">                    (Variable(&#39;i1_out&#39;, width=8), SSAReturn(Variable(&#39;i1&#39;, width=8)))])&quot;</span>

<span class="sd">        .. Implementation details:</span>
<span class="sd">            Since the equality operator is not implemented,</span>
<span class="sd">            ``eval(self.vrepr()) == self`` does NOT hold.</span>

<span class="sd">            This method does not store all the information,</span>
<span class="sd">            only the info needed to be recreated the object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">(input_vars=</span><span class="si">{}</span><span class="s2">, output_vars=</span><span class="si">{}</span><span class="s2">, assignments=</span><span class="si">{}{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">])</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">])</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">v</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">e</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span><span class="si">}</span><span class="s1">)&#39;</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_multiuse_vars_bool</span> <span class="k">else</span> <span class="s2">&quot;, replace_multiuse_vars=True&quot;</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="SSA.get_C_code"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSA.get_C_code">[docs]</a>    <span class="k">def</span> <span class="nf">get_C_code</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">C_function_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return two strings (header and body) of a C function evalauting the SSA.</span>

<span class="sd">        This method returns two strings (the function header and the function body)</span>
<span class="sd">        of a function in the C programming language that computes the SSA.</span>

<span class="sd">        The C function is of ``void`` type and its list of arguments consists of</span>
<span class="sd">        the input variables, the external variables (if any) and the output variables.</span>
<span class="sd">        The output variables are defined as pointers to store the results.</span>

<span class="sd">        See also `crepr`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.operation import BvXor, BvIdentity</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">            &gt;&gt;&gt; z = Variable(&quot;z&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">            ...     input_widths, output_widths = [8, 8], [8, 8]</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x, y):  return y ^ z, x ^ 1</span>
<span class="sd">            &gt;&gt;&gt; header, body = MyFoo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;i&quot;).get_C_code(&quot;MyFoo&quot;)</span>
<span class="sd">            &gt;&gt;&gt; header</span>
<span class="sd">            &#39;void MyFoo(uint8_t x, uint8_t y, uint8_t z, uint8_t *i0_out, uint8_t *i1_out);&#39;</span>
<span class="sd">            &gt;&gt;&gt; print(body)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            #include &lt;stdint.h&gt;</span>
<span class="sd">            void MyFoo(uint8_t x, uint8_t y, uint8_t z, uint8_t *i0_out, uint8_t *i1_out){</span>
<span class="sd">                uint8_t i0 = y ^ z;</span>
<span class="sd">                uint8_t i1 = x ^ 0x1U;</span>
<span class="sd">                *i0_out = i0;</span>
<span class="sd">                *i1_out = i1;</span>
<span class="sd">            };</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">cascada.bitvector.printing</span> <span class="kn">import</span> <span class="n">BvCCodePrinter</span>

        <span class="n">width2type</span> <span class="o">=</span> <span class="n">BvCCodePrinter</span><span class="o">.</span><span class="n">_width2C_type</span>

        <span class="c1"># in C, * binds to the declarator, not the type specifier</span>
        <span class="n">input_vars_c</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">width2type</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">])</span>
        <span class="n">output_vars_c</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> *</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">width2type</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_vars</span><span class="p">:</span>
            <span class="n">external_vars_c</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">width2type</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_vars</span><span class="p">])</span>
            <span class="n">external_vars_c</span> <span class="o">=</span> <span class="n">external_vars_c</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">external_vars_c</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;void </span><span class="si">{</span><span class="n">C_function_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">input_vars_c</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">external_vars_c</span><span class="si">}{</span><span class="n">output_vars_c</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">aux</span><span class="si">}</span><span class="s2">;&quot;</span>
        <span class="n">body</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;#include &lt;stdint.h&gt;</span><span class="se">\n</span><span class="si">{</span><span class="n">aux</span><span class="si">}</span><span class="se">{{</span><span class="s2">&quot;</span>  <span class="c1"># stdint for uint_*</span>

        <span class="n">outvar2outvar_c</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;*&quot;</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">allowed_symbols</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">primary_assignment2C_code</span><span class="p">(</span><span class="n">my_var</span><span class="p">,</span> <span class="n">my_expr</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_expr</span><span class="p">,</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">PrimaryOperation</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">my_var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;*</span><span class="si">{</span><span class="n">my_var</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">my_expr</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span><span class="si">}</span><span class="s2">;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">width2type</span><span class="p">(</span><span class="n">my_var</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">my_var</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">my_expr</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span><span class="si">}</span><span class="s2">;&quot;</span>

        <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">outvar2outvar_c</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">SecondaryOperation</span><span class="p">):</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">eval_sec_ops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="si">{</span><span class="n">primary_assignment2C_code</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">body</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">};&quot;</span>

        <span class="k">return</span> <span class="n">header</span><span class="p">,</span> <span class="n">body</span></div>

<div class="viewcode-block" id="SSA.eval"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSA.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_vals</span><span class="p">,</span> <span class="n">external_var2val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">C_code</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the SSA with `Constant` inputs and return the `Constant` outputs.</span>

<span class="sd">        If some external variable is not given, it is replaced by the zero bit-vector.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Variable, Constant</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">            &gt;&gt;&gt; z = Variable(&quot;z&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">            ...     input_widths, output_widths = [8, 8], [8, 8]</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x, y):  return y ^ z, x</span>
<span class="sd">            &gt;&gt;&gt; my_ssa = MyFoo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;i&quot;)</span>
<span class="sd">            &gt;&gt;&gt; my_ssa  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x, y], output_vars=[i0_out, x_out], external_vars=[z],</span>
<span class="sd">                assignments=[(i0, y ^ z), (i0_out, Id(i0)), (x_out, Id(x))])</span>
<span class="sd">            &gt;&gt;&gt; my_ssa.external_vars</span>
<span class="sd">            (z,)</span>
<span class="sd">            &gt;&gt;&gt; my_ssa.eval([Constant(0, 8), Constant(0, 8)])</span>
<span class="sd">            (0x00, 0x00)</span>

<span class="sd">        Args:</span>
<span class="sd">            input_vals: a list of `Constant` objects representing the inputs.</span>
<span class="sd">            external_var2val: a dictionary mapping the external variables</span>
<span class="sd">                to its `Constant` values.</span>
<span class="sd">            C_code: whether to evaluate the SSA by compiling and running</span>
<span class="sd">                its C code (see also `get_C_code`).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">external_var2val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">external_var2val</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">C_code</span><span class="p">:</span>
            <span class="c1"># avoid extra asserts in C_code</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_C_code</span><span class="p">(</span><span class="s2">&quot;eval_ssa&quot;</span><span class="p">)</span>
            <span class="n">pymod</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">_compile_C_code</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="kn">from</span> <span class="nn">cascada.bitvector.printing</span> <span class="kn">import</span> <span class="n">BvCCodePrinter</span>

            <span class="n">ffi</span> <span class="o">=</span> <span class="n">pymod</span><span class="o">.</span><span class="n">ffi</span>

            <span class="n">width2type</span> <span class="o">=</span> <span class="n">BvCCodePrinter</span><span class="o">.</span><span class="n">_width2C_type</span>

            <span class="n">input_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">ffi</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">width2type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">input_vals</span><span class="p">]</span>
            <span class="n">external_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">ffi</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">width2type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">external_var2val</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
                             <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_vars</span><span class="p">]</span>
            <span class="n">output_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">ffi</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">width2type</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2"> *&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">]</span>

            <span class="n">args</span> <span class="o">=</span> <span class="n">input_vals</span> <span class="o">+</span> <span class="n">external_vals</span> <span class="o">+</span> <span class="n">output_vals</span>

            <span class="n">pymod</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">eval_ssa</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

            <span class="n">offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_vals</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">external_vals</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">output_vals</span><span class="p">)):</span>
                <span class="c1"># [0] to access the content of the pointer</span>
                <span class="n">output_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">args</span>  <span class="c1"># free pointers</span>

            <span class="n">tmpdir</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_vals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;symbolic_inputs&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">input_vals</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">)</span>

            <span class="n">substitutions</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">input_vals</span><span class="p">):</span>
                <span class="n">substitutions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_vars</span><span class="p">:</span>
                <span class="n">substitutions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">external_var2val</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;symbolic_inputs&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> &lt;- </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span>
                <span class="n">substitutions</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span>

            <span class="n">output_vals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">:</span>
                <span class="n">output_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">substitutions</span><span class="p">[</span><span class="n">var</span><span class="p">])</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_vals</span><span class="p">)</span></div>

<div class="viewcode-block" id="SSA.to_bvfunction"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSA.to_bvfunction">[docs]</a>    <span class="k">def</span> <span class="nf">to_bvfunction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a `BvFunction` that evaluates  ``self``.</span>

<span class="sd">        The returned `BvFunction` stores ``self`` in the ``_ssa`` attribute.</span>
<span class="sd">        Moreover, the method `BvFunction.to_ssa` of the returned `BvFunction`</span>
<span class="sd">        raises an exception unless it is called with the same arguments that</span>
<span class="sd">        were used to create ``_ssa`` (in this case ``_ssa`` is returned).</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">            ...     input_widths, output_widths = [8, 8], [8, 8]</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x, y):  return x ^ y, x</span>
<span class="sd">            &gt;&gt;&gt; MyFoo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;a&quot;)  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x, y], output_vars=[a0_out, x_out],</span>
<span class="sd">                assignments=[(a0, x ^ y), (a0_out, Id(a0)), (x_out, Id(x))])</span>
<span class="sd">            &gt;&gt;&gt; MyFoo_v2 = MyFoo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;a&quot;).to_bvfunction()</span>
<span class="sd">            &gt;&gt;&gt; MyFoo_v2.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;a&quot;)  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x, y], output_vars=[a0_out, x_out],</span>
<span class="sd">                assignments=[(a0, x ^ y), (a0_out, Id(a0)), (x_out, Id(x))])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_input_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">]</span>
        <span class="n">_output_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">]</span>

        <span class="k">class</span> <span class="nc">MyBvFunction</span><span class="p">(</span><span class="n">BvFunction</span><span class="p">):</span>
            <span class="n">input_widths</span> <span class="o">=</span> <span class="n">_input_widths</span>
            <span class="n">output_widths</span> <span class="o">=</span> <span class="n">_output_widths</span>
            <span class="n">_ssa</span> <span class="o">=</span> <span class="bp">self</span>

            <span class="nd">@classmethod</span>
            <span class="k">def</span> <span class="nf">vrepr</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span><span class="si">}</span><span class="s2">.to_bvfunction()&quot;</span>

            <span class="nd">@classmethod</span>
            <span class="k">def</span> <span class="nf">to_ssa</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">input_names</span><span class="p">,</span> <span class="n">id_prefix</span><span class="p">,</span> <span class="n">decompose_sec_ops</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">ssa_options</span><span class="p">):</span>
                <span class="n">old_names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old_names</span> <span class="ow">or</span> <span class="n">decompose_sec_ops</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> \
                        <span class="n">ssa_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;replace_multiuse_vars&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_ssa</span><span class="o">.</span><span class="n">_replace_multiuse_vars_bool</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;the arguments of to_ssa(input_names=</span><span class="si">{</span><span class="n">input_names</span><span class="si">}</span><span class="s2">, &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;decompose_sec_ops=</span><span class="si">{</span><span class="n">decompose_sec_ops</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ssa_options</span><span class="si">}</span><span class="s2">)&quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot; are not the arguments used to generate </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="n">_ssa</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_ssa</span>

            <span class="nd">@classmethod</span>
            <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">input_vals</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">input_vals</span><span class="p">):</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

                <span class="k">for</span> <span class="n">outvar</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_ssa</span><span class="o">.</span><span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># avoiding expr.xreplace(d)</span>
                    <span class="c1"># (only calls Operation.__new__ if there is some substitution)</span>
                    <span class="n">out_val</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)(</span><span class="o">*</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">])</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">outvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_val</span>

                <span class="n">output_vals</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">:</span>
                    <span class="n">output_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">var</span><span class="p">))</span>

                <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_vals</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">MyBvFunction</span></div>

<div class="viewcode-block" id="SSA.copy"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSA.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a deep copy of ``self``.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">            ...     input_widths, output_widths = [8, 8], [8, 8]</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x, y):  return x ^ y, x</span>
<span class="sd">            &gt;&gt;&gt; ssa = MyFoo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;a&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ssa  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x, y], output_vars=[a0_out, x_out],</span>
<span class="sd">                assignments=[(a0, x ^ y), (a0_out, Id(a0)), (x_out, Id(x))])</span>
<span class="sd">            &gt;&gt;&gt; ssa_copy = ssa.copy()</span>
<span class="sd">            &gt;&gt;&gt; ssa_copy  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x, y], output_vars=[a0_out, x_out],</span>
<span class="sd">                assignments=[(a0, x ^ y), (a0_out, Id(a0)), (x_out, Id(x))])</span>
<span class="sd">            &gt;&gt;&gt; ssa_copy.input_vars = tuple()</span>
<span class="sd">            &gt;&gt;&gt; ssa_copy.output_vars = tuple()</span>
<span class="sd">            &gt;&gt;&gt; ssa_copy.assignments = collections.OrderedDict()</span>
<span class="sd">            &gt;&gt;&gt; ssa_copy</span>
<span class="sd">            SSA(input_vars=[], output_vars=[], assignments=[])</span>
<span class="sd">            &gt;&gt;&gt; ssa  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x, y], output_vars=[a0_out, x_out],</span>
<span class="sd">                assignments=[(a0, x ^ y), (a0_out, Id(a0)), (x_out, Id(x))])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">python_copy</span>
        <span class="n">my_ssa</span> <span class="o">=</span> <span class="n">python_copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># fast shallow copy (avoid __init__)</span>
        <span class="n">my_ssa</span><span class="o">.</span><span class="n">input_vars</span> <span class="o">=</span> <span class="n">my_ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">[:]</span>
        <span class="n">my_ssa</span><span class="o">.</span><span class="n">output_vars</span> <span class="o">=</span> <span class="n">my_ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">[:]</span>
        <span class="n">my_ssa</span><span class="o">.</span><span class="n">assignments</span> <span class="o">=</span> <span class="n">my_ssa</span><span class="o">.</span><span class="n">assignments</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">my_ssa</span></div>

<div class="viewcode-block" id="SSA.split"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSA.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_separators</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split into multiple `SSA` objects given the list of variable separators.</span>

<span class="sd">        Given the `SSA` :math:`s`, this method returns a list of `SSA` objects</span>
<span class="sd">        :math:`s_1, s_2, ..., s_n`, such that their composition</span>
<span class="sd">        :math:`s_n \circ s_{n-1} \dots \circ s_1` is functionally equivalent to</span>
<span class="sd">        :math:`s`.</span>

<span class="sd">        The argument ``var_separators`` is a list containing lists of variables.</span>
<span class="sd">        The :math:`i`-th variable list denote the last variables of :math:`s_i`.</span>
<span class="sd">        In other words, the list of assignments of :math:`s_{i+1}` immediately</span>
<span class="sd">        starts after the last assignments of the last variable in</span>
<span class="sd">        ``var_separators[i]``.</span>

<span class="sd">        To split into :math:`n` `SSA` objects, ``var_separators`` must contain</span>
<span class="sd">        :math:`n-1` lists, as the variable list for :math:`s_n` is not given</span>
<span class="sd">        (its last variables are the output variables of :math:`s`).</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">            &gt;&gt;&gt; z = Variable(&quot;z&quot;, 8)</span>
<span class="sd">            &gt;&gt;&gt; var_separators = []</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">            ...     input_widths, output_widths = [8], [8]</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x0):</span>
<span class="sd">            ...         var_separators.clear()</span>
<span class="sd">            ...         x1, y1 = (x0 + x0), x0</span>
<span class="sd">            ...         non_used_var = x1 + y1</span>
<span class="sd">            ...         var_separators.append([x1, y1, non_used_var])</span>
<span class="sd">            ...         return [(x1 | y1) &amp; z]</span>
<span class="sd">            &gt;&gt;&gt; ssa = MyFoo.to_ssa([&quot;x&quot;], &quot;a&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ssa  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x], output_vars=[a3_out], external_vars=[z],</span>
<span class="sd">                assignments=[(a0, x + x), (a2, a0 | x), (a3, a2 &amp; z), (a3_out, Id(a3))])</span>
<span class="sd">            &gt;&gt;&gt; var_separators</span>
<span class="sd">            [[a0, x, a1]]</span>
<span class="sd">            &gt;&gt;&gt; for sub_ssa in ssa.split(var_separators): print(sub_ssa)  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x], output_vars=[a0_out, x_out],</span>
<span class="sd">                assignments=[(a0, x + x), (a0_out, Id(a0)), (x_out, Id(x))])</span>
<span class="sd">            SSA(input_vars=[a0, x], output_vars=[a3_out], external_vars=[z],</span>
<span class="sd">                assignments=[(a2, a0 | x), (a3, a2 &amp; z), (a3_out, Id(a3))])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_separators</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>

        <span class="n">_listify</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>

        <span class="n">input_vars_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">)</span>
        <span class="n">external_vars_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">external_vars</span><span class="p">)</span>

        <span class="c1"># remove input and external vars from var_separators</span>
        <span class="n">var_separators</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_listify</span><span class="p">(</span><span class="n">vs_list</span><span class="p">)</span>
                           <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">input_vars_set</span><span class="o">|</span><span class="n">external_vars_set</span><span class="p">]</span>
                          <span class="k">for</span> <span class="n">vs_list</span> <span class="ow">in</span> <span class="n">var_separators</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var_separators</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_separators</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_separators</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;no non-input/non-external vars in var_separators[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_separators</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">var_separators</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_separators</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">singleuse_var2multiuse_var</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">external_vars_set</span><span class="p">:</span>
                    <span class="n">is_last_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiuse_var2singleuse_vars</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">singleuse_var2multiuse_var</span><span class="p">[</span><span class="n">var</span><span class="p">]][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_last_copy</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;split does not support copies of external variables (</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">) in var_separators&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignments</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_outvar_assignments</span><span class="p">,</span> \
                        <span class="sa">f</span><span class="s2">&quot;var </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> is not in SSA</span><span class="se">\n</span><span class="s2"> - </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="se">\n</span><span class="s2">and not in old SSA</span><span class="se">\n</span><span class="s2"> - </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_old_outvar_assignments</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="n">old_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_outvar_assignments</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">new_var_index</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">old_index</span><span class="p">)):</span>
                        <span class="n">new_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_old_outvar_assignments</span><span class="p">[</span><span class="n">new_var_index</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">new_var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignments</span><span class="p">:</span>
                            <span class="c1"># it doesn&#39;t matter if new_var in var_separators[i]</span>
                            <span class="c1"># (duplicates removed later)</span>
                            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;var_separators[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">][</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">] = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> replaced by </span><span class="si">{</span><span class="n">new_var</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">var_separators</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_var</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;var_separators[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">][</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">] = </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> not in assignments</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># removing duplicates</span>
            <span class="n">var_separators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">var_separators</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">prev_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
                <span class="n">var_separators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">var_separators</span><span class="p">[</span><span class="n">prev_i</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_separators</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;var_separators[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">] only contains variables from &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;var_separators[j] with j &lt; </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># var_terminators is var_separators w/ output vars (entries required to be sets)</span>
        <span class="n">var_terminators</span> <span class="o">=</span> <span class="n">var_separators</span> <span class="o">+</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">)]</span>

        <span class="k">class</span> <span class="nc">SubSSA</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
            <span class="n">replace_multiuse_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_multiuse_vars_bool</span>

            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="n">self_subssa</span><span class="p">):</span>
                <span class="n">self_subssa</span><span class="o">.</span><span class="n">input_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">self_subssa</span><span class="o">.</span><span class="n">output_vars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">self_subssa</span><span class="o">.</span><span class="n">assignments</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">self_subssa</span><span class="o">.</span><span class="n">external_vars</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="n">self_subssa</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;SubSSA:&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - input_vars: </span><span class="si">{</span><span class="n">self_subssa</span><span class="o">.</span><span class="n">input_vars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - output_vars: </span><span class="si">{</span><span class="n">self_subssa</span><span class="o">.</span><span class="n">output_vars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - external_vars: </span><span class="si">{</span><span class="n">self_subssa</span><span class="o">.</span><span class="n">external_vars</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> - assignments: </span><span class="si">{</span><span class="n">self_subssa</span><span class="o">.</span><span class="n">assignments</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">return</span> <span class="n">msg</span>

        <span class="n">sub_ssa_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">SubSSA</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">var_terminators</span><span class="p">))]</span>
        <span class="n">sub_ssa_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">input_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_vars</span><span class="p">[:]</span>
        <span class="n">sub_ssa_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">output_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_vars</span><span class="p">[:]</span>

        <span class="c1"># fill assignments and external_vars.</span>
        <span class="c1"># when var_terminators[i] is empty we move to the next sub_ssa</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">assign_out_var</span><span class="p">,</span> <span class="n">assign_expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">assignments</span><span class="p">[</span><span class="n">assign_out_var</span><span class="p">]</span> <span class="o">=</span> <span class="n">assign_expr</span>
            <span class="n">var_terminators</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">assign_out_var</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">assign_expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">external_vars_set</span><span class="p">:</span>
                    <span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">external_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="c1"># # debugging</span>
            <span class="c1"># print(f&quot; - added {(assign_out_var, assign_expr)} to sub_ssa_list[{i}] and added&quot;</span>
            <span class="c1">#       f&quot;{[v for v in assign_expr.args if v in external_vars_set]} to &quot;</span>
            <span class="c1">#       f&quot;sub_ssa_list[{i}].external_vars&quot;)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var_terminators</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_ssa_list</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_input_vars</span><span class="p">(</span><span class="n">my_sub_ssa</span><span class="p">):</span>
            <span class="n">vars_not_defined</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># input vars</span>
            <span class="n">vars_defined</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">external_vars</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">assign_out_var</span><span class="p">,</span> <span class="n">assign_expr</span> <span class="ow">in</span> <span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">assign_expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vars_defined</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">arg</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vars_not_defined</span><span class="p">:</span>  <span class="c1"># avoid duplicates</span>
                            <span class="c1"># print(f&quot;   - var {arg} added to {vars_not_defined} from {(assign_out_var, assign_expr)}&quot;)</span>
                            <span class="n">vars_not_defined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="n">vars_defined</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">assign_out_var</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vars_defined</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">vars_not_defined</span><span class="p">)))</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="c1"># input vars also contain output vars not defined</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="n">vars_defined</span> <span class="o">|=</span> <span class="nb">set</span><span class="p">(</span><span class="n">vars_not_defined</span><span class="p">)</span>  <span class="c1"># ows input_vars contain duplicates</span>
            <span class="k">for</span> <span class="n">output_var</span> <span class="ow">in</span> <span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">output_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vars_defined</span><span class="p">:</span>
                    <span class="c1"># output_var can still be used in some assignment expression</span>
                    <span class="n">vars_not_defined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_var</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">vars_not_defined</span>

        <span class="k">def</span> <span class="nf">check_output_vars</span><span class="p">(</span><span class="n">my_sub_ssa</span><span class="p">,</span> <span class="n">my_i</span><span class="p">):</span>
            <span class="c1"># check all output vars are in input_vars or assignments</span>
            <span class="n">aux_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">assignments</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">aux_set</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">),</span> \
                <span class="sa">f</span><span class="s2">&quot;sub_ssa_list[</span><span class="si">{</span><span class="n">my_i</span><span class="si">}</span><span class="s2">] | output_vars=</span><span class="si">{</span><span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="si">}</span><span class="s2"> not in &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot;input_vars=</span><span class="si">{</span><span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="si">}</span><span class="s2"> or assignments=</span><span class="si">{</span><span class="n">my_sub_ssa</span><span class="o">.</span><span class="n">assignments</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># fill sub_ssa[i].input_vars from get_input_vars_from_sub_ssa(sub_ssa[i])</span>
        <span class="c1"># fill sub_ssa[i-1].output_vars from sub_ssa[i].input_vars</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_ssa_list</span><span class="p">))):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">input_vars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># copy vars to sub_ssa_list to avoid sharing the vars between multiple objects</span>
                <span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">input_vars</span> <span class="o">=</span> <span class="n">get_input_vars</span><span class="p">(</span><span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">])[:]</span>
                <span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">output_vars</span> <span class="o">=</span> <span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">input_vars</span><span class="p">[:]</span>
            <span class="n">check_output_vars</span><span class="p">(</span><span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_ssa_list</span><span class="p">)):</span>
            <span class="c1"># after calling SSA(), the suffix of output_vars might change</span>
            <span class="c1"># (some ``_`` or ``_out`` might be added)</span>
            <span class="c1"># but better not to use the new output_vars for the input vars</span>
            <span class="c1"># of the next sub_ssa (to avoid variables with suffix ``_out_out_out``)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># check that the base name (except the suffix) has not changed</span>
                <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">prev_v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">input_vars</span><span class="p">,</span> <span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">output_vars</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">prev_v</span><span class="o">.</span><span class="n">name</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span>

            <span class="n">check_output_vars</span><span class="p">(</span><span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

            <span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SSA</span><span class="p">(</span><span class="n">input_vars</span><span class="o">=</span><span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">input_vars</span><span class="p">,</span>
                                  <span class="n">output_vars</span><span class="o">=</span><span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">output_vars</span><span class="p">,</span>
                                  <span class="n">assignments</span><span class="o">=</span><span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">assignments</span><span class="p">,</span>
                                  <span class="n">replace_multiuse_vars</span><span class="o">=</span><span class="n">SubSSA</span><span class="o">.</span><span class="n">replace_multiuse_vars</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ev</span> <span class="ow">in</span> <span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">external_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ev</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">external_vars_set</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sub_ssa_list[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">].external_vars </span><span class="si">{</span><span class="n">sub_ssa_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">external_vars</span><span class="si">}</span><span class="s2"> &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;not a subset of parent SSA external_vars </span><span class="si">{</span><span class="n">external_vars_set</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sub_ssa_list</span></div>

<div class="viewcode-block" id="SSA.get_round_separators"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSA.get_round_separators">[docs]</a>    <span class="k">def</span> <span class="nf">get_round_separators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the round separators if the SSA was obtained from a `RoundBasedFunction`.</span>

<span class="sd">        If the `SSA` object was obtained from `RoundBasedFunction.to_ssa` of a</span>
<span class="sd">        `RoundBasedFunction` including `add_round_outputs` calls in its ``eval``,</span>
<span class="sd">        this method returns a list with the round outputs delimiting the rounds.</span>
<span class="sd">        Otherwise, ``None`` is returned.</span>

<span class="sd">        In the first case, this list contains ``num_rounds - 1`` entries,</span>
<span class="sd">        where the ``i``-th entry is the list of outputs of the ``i``-th round.</span>
<span class="sd">        In particular, the outputs of the last round are not included in this list.</span>

<span class="sd">        The list returned by this method is meant to be used as the argument</span>
<span class="sd">        of `split` to get the `SSA` object of each round.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import RoundBasedFunction</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(RoundBasedFunction):</span>
<span class="sd">            ...     input_widths, output_widths, num_rounds = [8, 8], [8, 8], 1</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, x, y):</span>
<span class="sd">            ...         for _ in range(cls.num_rounds):</span>
<span class="sd">            ...             x, y = y, x + 1</span>
<span class="sd">            ...             cls.add_round_outputs(x, y)</span>
<span class="sd">            ...         return x, y</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def set_num_rounds(cls, new_num_rounds):  cls.num_rounds = new_num_rounds</span>
<span class="sd">            &gt;&gt;&gt; MyFoo.set_num_rounds(3)</span>
<span class="sd">            &gt;&gt;&gt; ssa = MyFoo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;a&quot;)</span>
<span class="sd">            &gt;&gt;&gt; ssa  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x, y], output_vars=[a1_out, a2_out],</span>
<span class="sd">                assignments=[(a0, x + 0x01), (a1, y + 0x01), (a2, a0 + 0x01),</span>
<span class="sd">                    (a1_out, Id(a1)), (a2_out, Id(a2))])</span>
<span class="sd">            &gt;&gt;&gt; round_separators = ssa.get_round_separators()</span>
<span class="sd">            &gt;&gt;&gt; round_separators</span>
<span class="sd">            ((y, a0), (a0, a1))</span>
<span class="sd">            &gt;&gt;&gt; for sub_ssa in ssa.split(round_separators): print(sub_ssa)  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            SSA(input_vars=[x, y], output_vars=[y_out, a0_out],</span>
<span class="sd">                assignments=[(a0, x + 0x01), (y_out, Id(y)), (a0_out, Id(a0))])</span>
<span class="sd">            SSA(input_vars=[y, a0], output_vars=[a0_out, a1_out],</span>
<span class="sd">                assignments=[(a1, y + 0x01), (a0_out, Id(a0)), (a1_out, Id(a1))])</span>
<span class="sd">            SSA(input_vars=[a0, a1], output_vars=[a1_out, a2_out],</span>
<span class="sd">                assignments=[(a2, a0 + 0x01), (a1_out, Id(a1)), (a2_out, Id(a2))])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_rounds_outputs&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rounds_outputs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rounds_outputs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="SSA.dotprinting"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.SSA.dotprinting">[docs]</a>    <span class="k">def</span> <span class="nf">dotprinting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">vrepr_label</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the DOT description of the expression tree of the assignments.</span>

<span class="sd">        See also `printing.dotprinting`.</span>

<span class="sd">        Args:</span>
<span class="sd">            repeat: whether to use different nodes for common subexpressions</span>
<span class="sd">                (default True)</span>
<span class="sd">            vrepr_label: whether to use the verbose representation (`Term.vrepr`)</span>
<span class="sd">                to label the nodes (default False)</span>
<span class="sd">            kwargs: additional arguments passed to `printing.dotprinting`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">cascada.bitvector.printing</span> <span class="kn">import</span> <span class="n">dotprinting</span>
        <span class="kn">from</span> <span class="nn">sympy.core.containers</span> <span class="kn">import</span> <span class="n">Tuple</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">assignments</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">dotprinting</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">repeat</span><span class="p">,</span> <span class="n">vrepr_label</span><span class="o">=</span><span class="n">vrepr_label</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="get_random_bvfunction"><a class="viewcode-back" href="../../../cascada.bitvector.ssa.html#cascada.bitvector.ssa.get_random_bvfunction">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_random_bvfunction</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_outputs</span><span class="p">,</span> <span class="n">num_assignments</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span>
                          <span class="n">external_variable_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operation_set_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_rounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">extra_operations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a random `BvFunction` with given shape.</span>

<span class="sd">    Args:</span>
<span class="sd">        width: the common bitsize of the input and output variables of the function</span>
<span class="sd">        num_inputs: the number of inputs of the function</span>
<span class="sd">        num_outputs: the number of outputs of the function</span>
<span class="sd">        num_assignments: an estimation of the number of operations within the function</span>
<span class="sd">        seed: the seed used when sampling</span>
<span class="sd">        external_variable_prefix: if not ``None``, external variables are used</span>
<span class="sd">            with the given prefix (at least one)</span>
<span class="sd">        operation_set_index: four set of operations to choose indexed by 0, 1, 2 and 3</span>
<span class="sd">        num_rounds: if not ``None``, returns a random `RoundBasedFunction` with</span>
<span class="sd">            the given number of rounds</span>
<span class="sd">        extra_operations: an optional `tuple` containing `Operation` subclasses</span>
<span class="sd">            to add to the list of operations to choose</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.ssa import get_random_bvfunction</span>
<span class="sd">        &gt;&gt;&gt; my_foo = get_random_bvfunction(4, 2, 2, 2, seed=0)</span>
<span class="sd">        &gt;&gt;&gt; my_foo.to_ssa([&quot;x&quot;, &quot;y&quot;], &quot;a&quot;)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        SSA(input_vars=[x, y], output_vars=[a0_out, a1_out],</span>
<span class="sd">            assignments=[(a0, y &gt;&gt; 0x2), (a1, ~y), (a0_out, Id(a0)), (a1_out, Id(a1))])</span>
<span class="sd">        &gt;&gt;&gt; my_foo = get_random_bvfunction(4, 1, 1, 2, seed=20)</span>
<span class="sd">        &gt;&gt;&gt; my_foo.to_ssa([&quot;x&quot;], &quot;a&quot;)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        SSA(input_vars=[x], output_vars=[a7_out],</span>
<span class="sd">            assignments=[(a0, x[0]), (a1, x[1]), (a2, x[2]), (a3, x[3]),</span>
<span class="sd">            (a4, a0 :: a1), (a5, a4 :: a2), (a6, a5 :: a3), (a7, a6 + 0xe), (a7_out, Id(a7))])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">num_inputs</span> <span class="o">+</span> <span class="n">num_assignments</span> <span class="o">&gt;=</span> <span class="n">num_outputs</span>

    <span class="kn">import</span> <span class="nn">random</span>
    <span class="kn">import</span> <span class="nn">functools</span>
    <span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="p">(</span>
        <span class="n">BvAnd</span><span class="p">,</span> <span class="n">BvOr</span><span class="p">,</span> <span class="n">BvXor</span><span class="p">,</span> <span class="n">BvShl</span><span class="p">,</span> <span class="n">BvLshr</span><span class="p">,</span> <span class="n">RotateLeft</span><span class="p">,</span> <span class="n">RotateRight</span><span class="p">,</span> <span class="n">BvAdd</span><span class="p">,</span>
        <span class="n">BvSub</span><span class="p">,</span> <span class="n">BvNeg</span><span class="p">,</span> <span class="n">BvNot</span><span class="p">,</span> <span class="n">Concat</span><span class="p">,</span> <span class="n">BvIdentity</span><span class="p">,</span> <span class="n">make_partial_operation</span>
    <span class="p">)</span>
    <span class="kn">from</span> <span class="nn">cascada.bitvector.secondaryop</span> <span class="kn">import</span> <span class="n">BvIf</span><span class="p">,</span> <span class="n">BvMaj</span>

    <span class="n">PRNG</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>
    <span class="n">PRNG</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

    <span class="c1"># SimpleReverse contains Concat and Extract</span>
    <span class="c1"># implemented as a class to later use issubclass()</span>
    <span class="k">class</span> <span class="nc">SimpleReverse</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bv</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">Concat</span><span class="p">,</span> <span class="p">[</span><span class="n">bv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bv</span><span class="o">.</span><span class="n">width</span><span class="p">)])</span>

    <span class="k">if</span> <span class="n">operation_set_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">list_ops</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">BvNot</span><span class="p">,</span> <span class="n">BvXor</span><span class="p">,</span> <span class="n">BvAnd</span><span class="p">,</span> <span class="n">BvOr</span><span class="p">,</span>
            <span class="n">BvAdd</span><span class="p">,</span> <span class="n">BvSub</span><span class="p">,</span> <span class="n">BvNeg</span><span class="p">,</span>
            <span class="n">BvIdentity</span><span class="p">,</span>
            <span class="n">BvIf</span><span class="p">,</span> <span class="n">BvMaj</span><span class="p">,</span>
            <span class="n">RotateLeft</span><span class="p">,</span> <span class="n">RotateRight</span><span class="p">,</span>
            <span class="n">BvShl</span><span class="p">,</span> <span class="n">BvLshr</span><span class="p">,</span>
            <span class="n">SimpleReverse</span>
            <span class="c1"># Concat, Extract, Ite,</span>
            <span class="c1"># BvComp, BvUlt, BvUle, BvUgt, BvUge,</span>
            <span class="c1"># BvMul, BvUdiv, BvUrem,</span>
            <span class="c1"># PopCount, Reverse, PopCountSum2, PopCountSum3, PopCountDiff, LeadingZeros,</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">operation_set_index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">list_ops</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">BvNot</span><span class="p">,</span> <span class="n">BvXor</span><span class="p">,</span> <span class="n">BvAnd</span><span class="p">,</span> <span class="n">BvOr</span><span class="p">,</span>
            <span class="n">BvAdd</span><span class="p">,</span> <span class="n">BvSub</span><span class="p">,</span> <span class="n">BvNeg</span><span class="p">,</span>
            <span class="n">BvIdentity</span><span class="p">,</span>
            <span class="n">BvIf</span><span class="p">,</span> <span class="n">BvMaj</span><span class="p">,</span>
            <span class="n">RotateLeft</span><span class="p">,</span> <span class="n">RotateRight</span><span class="p">,</span>
            <span class="n">make_partial_operation</span><span class="p">(</span><span class="n">BvShl</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">width</span><span class="p">))),</span>
            <span class="n">make_partial_operation</span><span class="p">(</span><span class="n">BvLshr</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">width</span><span class="p">))),</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">operation_set_index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">list_ops</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">BvNot</span><span class="p">,</span> <span class="n">BvXor</span><span class="p">,</span> <span class="n">BvAnd</span><span class="p">,</span> <span class="n">BvOr</span><span class="p">,</span>
            <span class="n">BvAdd</span><span class="p">,</span> <span class="n">BvSub</span><span class="p">,</span>
            <span class="n">BvIdentity</span><span class="p">,</span>
            <span class="n">RotateLeft</span><span class="p">,</span> <span class="n">RotateRight</span><span class="p">,</span>
            <span class="n">BvShl</span><span class="p">,</span> <span class="n">BvLshr</span><span class="p">,</span>
            <span class="n">SimpleReverse</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">operation_set_index</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">list_ops</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">BvNot</span><span class="p">,</span> <span class="n">BvXor</span><span class="p">,</span> <span class="n">BvAnd</span><span class="p">,</span> <span class="n">BvOr</span><span class="p">,</span>
            <span class="n">BvAdd</span><span class="p">,</span> <span class="n">BvSub</span><span class="p">,</span> <span class="n">BvNeg</span><span class="p">,</span>
            <span class="n">BvIdentity</span><span class="p">,</span>
            <span class="n">BvIf</span><span class="p">,</span> <span class="n">BvMaj</span><span class="p">,</span>
            <span class="n">RotateLeft</span><span class="p">,</span> <span class="n">RotateRight</span><span class="p">,</span>
            <span class="n">BvShl</span><span class="p">,</span> <span class="n">BvLshr</span><span class="p">,</span>
            <span class="n">SimpleReverse</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;operation_set_index must be 0, 1, 2, or 3&quot;</span><span class="p">)</span>

    <span class="n">extra_operations_vrepr</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">extra_operations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">list_ops</span> <span class="o">+=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">extra_operations</span><span class="p">)</span>
        <span class="n">extra_operations_vrepr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">extra_operations</span><span class="p">)</span><span class="si">}</span><span class="s2">,)&quot;</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>  <span class="c1"># outer loop to check RandomBvFunction does not return Constant</span>
        <span class="n">list_of_lambda_assignments</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">class</span> <span class="nc">RandomBvFunction</span><span class="p">(</span><span class="n">BvFunction</span><span class="p">):</span>
            <span class="n">input_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_inputs</span>
            <span class="n">output_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">width</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_outputs</span>
            
            <span class="nd">@classmethod</span>
            <span class="k">def</span> <span class="nf">vrepr</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                <span class="n">evp</span> <span class="o">=</span> <span class="n">external_variable_prefix</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;get_random_bvfunction(</span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_inputs</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_outputs</span><span class="si">}</span><span class="s2">, &quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">num_assignments</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">seed</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">evp</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">operation_set_index</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">num_rounds</span><span class="si">}</span><span class="s2">, &quot;</span> \
                       <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">extra_operations_vrepr</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="k">if</span> <span class="n">external_variable_prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">RandomBvFunction</span><span class="o">.</span><span class="n">round_keys</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">get_random_var_index</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_lambda_assignments</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">num_inputs</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="n">num_inputs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">min_index</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_lambda_assignments</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_inputs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_random_var_indices</span><span class="p">(</span><span class="n">num_indices</span><span class="p">,</span> <span class="n">my_unique_indices</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="n">get_random_var_index</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">my_unique_indices</span> <span class="ow">or</span> <span class="n">new_index</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_index</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_indices</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">return</span> <span class="n">indices</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">_op</span> <span class="o">=</span> <span class="n">list_ops</span><span class="p">[</span><span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_ops</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">_op</span> <span class="ow">in</span> <span class="p">[</span><span class="n">RotateLeft</span><span class="p">,</span> <span class="n">RotateRight</span><span class="p">]:</span>  <span class="c1"># only operations with scalar inputs</span>
                <span class="k">class</span> <span class="nc">Op</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>  <span class="c1"># need a class to store the randomness</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_op</span>
                    <span class="n">my_index</span> <span class="o">=</span> <span class="n">get_random_var_index</span><span class="p">()</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># != 0</span>
                    <span class="c1"># kwargs required for external vars (see below)</span>
                    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">my_index</span><span class="p">],</span> <span class="bp">cls</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">_op</span> <span class="o">==</span> <span class="n">SimpleReverse</span><span class="p">:</span>
                <span class="k">class</span> <span class="nc">Op</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_op</span>
                    <span class="n">my_index</span> <span class="o">=</span> <span class="n">get_random_var_index</span><span class="p">()</span>
                    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">my_index</span><span class="p">])</span>

            <span class="k">elif</span> <span class="n">_op</span> <span class="ow">in</span> <span class="p">[</span><span class="n">BvShl</span><span class="p">,</span> <span class="n">BvLshr</span><span class="p">]:</span>  <span class="c1"># ensure 2nd operand ct</span>
                <span class="k">class</span> <span class="nc">Op</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_op</span>
                    <span class="n">my_index</span> <span class="o">=</span> <span class="n">get_random_var_index</span><span class="p">()</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">width</span><span class="p">)</span>
                    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">my_index</span><span class="p">],</span> <span class="bp">cls</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">_op</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">Operation</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">_op</span><span class="o">.</span><span class="n">arity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">_op</span><span class="o">.</span><span class="n">arity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># 1 in 4 to have a ct or external var (each 50%)</span>
                    <span class="k">if</span> <span class="n">external_variable_prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">extra_arg</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="n">width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">width</span><span class="p">)</span>  <span class="c1"># != 0, allones</span>

                        <span class="k">class</span> <span class="nc">Op</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
                            <span class="n">op</span> <span class="o">=</span> <span class="n">_op</span>
                            <span class="n">indices</span> <span class="o">=</span> <span class="n">get_random_var_indices</span><span class="p">(</span><span class="n">_op</span><span class="o">.</span><span class="n">arity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                            <span class="n">ct</span> <span class="o">=</span> <span class="n">extra_arg</span>
                            <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">cls</span><span class="o">.</span><span class="n">ct</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">evi</span> <span class="o">=</span> <span class="n">PRNG</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">RandomBvFunction</span><span class="o">.</span><span class="n">round_keys</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">evi</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">RandomBvFunction</span><span class="o">.</span><span class="n">round_keys</span><span class="p">):</span>
                            <span class="n">RandomBvFunction</span><span class="o">.</span><span class="n">round_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">external_variable_prefix</span><span class="si">}{</span><span class="n">evi</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>

                        <span class="k">class</span> <span class="nc">Op</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
                            <span class="n">op</span> <span class="o">=</span> <span class="n">_op</span>
                            <span class="n">indices</span> <span class="o">=</span> <span class="n">get_random_var_indices</span><span class="p">(</span><span class="n">_op</span><span class="o">.</span><span class="n">arity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                            <span class="n">ev_index</span> <span class="o">=</span> <span class="n">evi</span>
                            <span class="c1"># kwargs[&quot;round_keys&quot;] instead of RandomBvFunction.round_keys</span>
                            <span class="c1"># to provide round_keys from cls in running time (in an argument of Op(</span>
                            <span class="c1"># (otherwise round_keys cannot be changed)</span>
                            <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">+</span>
                                                                              <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;round_keys&quot;</span><span class="p">][</span><span class="bp">cls</span><span class="o">.</span><span class="n">ev_index</span><span class="p">]]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unique_indices</span> <span class="o">=</span> <span class="n">_op</span> <span class="ow">in</span> <span class="p">[</span><span class="n">BvAnd</span><span class="p">,</span> <span class="n">BvOr</span><span class="p">,</span> <span class="n">BvXor</span><span class="p">,</span> <span class="n">BvSub</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">unique_indices</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_lambda_assignments</span><span class="p">)</span> <span class="o">+</span> <span class="n">num_inputs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># avoid using duplicated inputs for these operations</span>
                        <span class="k">continue</span>

                    <span class="k">class</span> <span class="nc">Op</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
                        <span class="n">op</span> <span class="o">=</span> <span class="n">_op</span>
                        <span class="n">indices</span> <span class="o">=</span> <span class="n">get_random_var_indices</span><span class="p">(</span><span class="n">_op</span><span class="o">.</span><span class="n">arity</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unique_indices</span><span class="p">)</span>
                        <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">external_variable_prefix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">RandomBvFunction</span><span class="o">.</span><span class="n">round_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># ensure at least 1 external variable</span>
                <span class="n">_op</span> <span class="o">=</span> <span class="n">BvXor</span>
                <span class="n">evi</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">RandomBvFunction</span><span class="o">.</span><span class="n">round_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">external_variable_prefix</span><span class="si">}{</span><span class="n">evi</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>

                <span class="k">class</span> <span class="nc">Op</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
                    <span class="n">op</span> <span class="o">=</span> <span class="n">_op</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">get_random_var_indices</span><span class="p">(</span><span class="n">_op</span><span class="o">.</span><span class="n">arity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="n">ev_index</span> <span class="o">=</span> <span class="n">evi</span>
                    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="p">([</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">indices</span><span class="p">]</span> <span class="o">+</span>
                                                                      <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;round_keys&quot;</span><span class="p">][</span><span class="bp">cls</span><span class="o">.</span><span class="n">ev_index</span><span class="p">]]))</span>

            <span class="c1">## debugging</span>
            <span class="c1"># print(f&quot;{len(list_of_lambda_assignments)+1}/{num_assignments} | op: {Op.op}&quot;)</span>
            <span class="c1"># if hasattr(Op, &quot;my_index&quot;):  print(&quot;\tmy_index:&quot;, Op.my_index)</span>
            <span class="c1"># if hasattr(Op, &quot;indices&quot;):  print(&quot;\tindices:&quot;, Op.indices)</span>
            <span class="c1"># if hasattr(Op, &quot;ct&quot;):  print(&quot;\tct:&quot;, Op.ct)</span>
            <span class="c1"># if hasattr(Op, &quot;offset&quot;):  print(&quot;\toffset:&quot;, Op.offset)</span>
            <span class="c1"># if hasattr(Op, &quot;ev_index&quot;):  print(&quot;\tev_index:&quot;, Op.ev_index)</span>

            <span class="n">list_of_lambda_assignments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Op</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_lambda_assignments</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_assignments</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">list_of_lambda_assignments</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">list_of_lambda_assignments</span><span class="p">)</span>

        <span class="nd">@classmethod</span>
        <span class="k">def</span> <span class="nf">eval_method</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
            <span class="n">all_vars</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">round_keys</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;round_keys&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1">## debugging</span>
            <span class="c1"># print(f&quot;eval_method({args}):&quot;)</span>
            <span class="k">for</span> <span class="n">index_assign</span><span class="p">,</span> <span class="n">lambda_assign</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_of_lambda_assignments</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">lambda_assign</span><span class="p">(</span><span class="n">all_vars</span><span class="p">,</span> <span class="n">round_keys</span><span class="o">=</span><span class="n">round_keys</span><span class="p">)</span>

                <span class="n">Op</span> <span class="o">=</span> <span class="n">lambda_assign</span>
                <span class="n">ffo_arg0</span><span class="p">,</span> <span class="n">ffo_arg1</span><span class="p">,</span> <span class="n">ffo_arg2</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="s2">&quot;my_index&quot;</span><span class="p">):</span>
                    <span class="n">ffo_arg0</span> <span class="o">=</span> <span class="n">all_vars</span><span class="p">[</span><span class="n">Op</span><span class="o">.</span><span class="n">my_index</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="s2">&quot;indices&quot;</span><span class="p">)</span>
                    <span class="n">ffo_arg0</span> <span class="o">=</span> <span class="n">all_vars</span><span class="p">[</span><span class="n">Op</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">ffo_arg1</span> <span class="o">=</span> <span class="n">all_vars</span><span class="p">[</span><span class="n">Op</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Op</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">ffo_arg2</span> <span class="o">=</span> <span class="n">all_vars</span><span class="p">[</span><span class="n">Op</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                <span class="n">ffo_extra_args</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="s2">&quot;ct&quot;</span><span class="p">):</span>
                    <span class="n">ffo_extra_args</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">ct</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="s2">&quot;offset&quot;</span><span class="p">):</span>
                    <span class="n">ffo_extra_args</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">offset</span>
                <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="s2">&quot;ev_index&quot;</span><span class="p">):</span>
                    <span class="n">ffo_extra_args</span> <span class="o">=</span> <span class="n">round_keys</span><span class="p">[</span><span class="n">Op</span><span class="o">.</span><span class="n">ev_index</span><span class="p">]</span>
                <span class="n">format_string</span> <span class="o">=</span> <span class="s2">&quot;assignment </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">(</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, extra=</span><span class="si">{}</span><span class="s2">) = </span><span class="si">{}</span><span class="s2">&quot;</span>
                <span class="n">ffo</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_assign</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_lambda_assignments</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                       <span class="n">Op</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">ffo_arg0</span><span class="p">,</span> <span class="n">ffo_arg1</span><span class="p">,</span> <span class="n">ffo_arg2</span><span class="p">,</span>
                       <span class="n">ffo_extra_args</span><span class="p">,</span> <span class="n">result</span><span class="p">]</span>
                <span class="bp">cls</span><span class="o">.</span><span class="n">log_msg</span><span class="p">(</span><span class="n">format_string</span><span class="p">,</span> <span class="n">ffo</span><span class="p">)</span>

                <span class="c1">## debugging</span>
                <span class="c1"># print(f&quot;\t{result.width}-width op: {Op.op.__name__}&quot;)</span>
                <span class="c1"># if hasattr(Op, &quot;my_index&quot;):  print(&quot;\t\targ:&quot;, all_vars[Op.my_index])</span>
                <span class="c1"># if hasattr(Op, &quot;indices&quot;):  print(&quot;\t\targs:&quot;, [all_vars[i] for i in Op.indices])</span>
                <span class="c1"># if hasattr(Op, &quot;ct&quot;):  print(&quot;\t\tct:&quot;, Op.ct)</span>
                <span class="c1"># if hasattr(Op, &quot;offset&quot;):  print(&quot;\t\toffset:&quot;, Op.offset)</span>
                <span class="c1"># if hasattr(Op, &quot;ev_index&quot;):  print(&quot;\t\text_arg:&quot;, round_keys[Op.ev_index])</span>
                <span class="c1"># print(f&quot;\t\tresult:&quot;, result)</span>
                <span class="n">all_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">all_vars</span><span class="p">[</span><span class="o">-</span><span class="n">num_outputs</span><span class="p">:]</span>

        <span class="n">RandomBvFunction</span><span class="o">.</span><span class="n">eval</span> <span class="o">=</span> <span class="n">eval_method</span>

        <span class="c1"># check RandomBvFunction does not return Constant</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">RandomBvFunction</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_inputs</span><span class="p">)],</span>
                             <span class="n">symbolic_inputs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;if symbolic_inputs, expected no Constant values&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">e</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="k">if</span> <span class="n">num_rounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RandomBvFunction</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_num_rounds</span> <span class="o">=</span> <span class="n">num_rounds</span>

            <span class="k">class</span> <span class="nc">RandomRBF</span><span class="p">(</span><span class="n">RandomBvFunction</span><span class="p">,</span> <span class="n">RoundBasedFunction</span><span class="p">):</span>
                <span class="n">num_rounds</span> <span class="o">=</span> <span class="n">_num_rounds</span>

                <span class="nd">@classmethod</span>
                <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">index_round</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">num_rounds</span><span class="p">):</span>
                        <span class="n">args</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">index_round</span> <span class="o">&lt;</span> <span class="bp">cls</span><span class="o">.</span><span class="n">num_rounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">):</span>
                                <span class="n">args</span> <span class="o">=</span> <span class="n">args</span> <span class="o">*</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">)</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">input_widths</span><span class="p">)]</span>

                        <span class="bp">cls</span><span class="o">.</span><span class="n">add_round_outputs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

                        <span class="n">format_string</span> <span class="o">=</span> <span class="s2">&quot;round </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">: outputs = (&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">, &quot;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
                        <span class="n">ffo</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_round</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">num_rounds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                        <span class="bp">cls</span><span class="o">.</span><span class="n">log_msg</span><span class="p">(</span><span class="n">format_string</span><span class="p">,</span> <span class="n">ffo</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">args</span>

                <span class="nd">@classmethod</span>
                <span class="k">def</span> <span class="nf">set_num_rounds</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">new_num_rounds</span><span class="p">):</span>
                    <span class="bp">cls</span><span class="o">.</span><span class="n">num_rounds</span> <span class="o">=</span> <span class="n">new_num_rounds</span>

            <span class="c1"># check RandomRBF does not return Constant</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">RandomRBF</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_inputs</span><span class="p">)],</span>
                          <span class="n">symbolic_inputs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;if symbolic_inputs, expected no Constant values&quot;</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">RandomRBF</span></div>


<span class="k">def</span> <span class="nf">_compile_C_code</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">return_unloaded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compile a C function given its C code as two strings (function header and body).</span>

<span class="sd">    This method returns a list of two objects: ``pymod`` and ``tmpdir``.</span>

<span class="sd">    The first object ``pymod``  is a python CFFI wrapper of the compiled</span>
<span class="sd">    the C function. The C function can be called as ``pymod.lib.foo_name()``</span>
<span class="sd">    where ``foo_name`` is the name of the C function given in the C code.</span>

<span class="sd">    The second object ``tmpdir`` is the temporary directory (obtained from</span>
<span class="sd">    `tempfile.TemporaryDirectory` where the python module and the DLL are stored).</span>
<span class="sd">    This directory can be emptied by ``tmpdir.cleanup()``.</span>

<span class="sd">    If ``return_unloaded`` is True, then the path of the (unloaded) python</span>
<span class="sd">    wrapper, ``module_name`` and ``tmpdir`` are returned instead.</span>

<span class="sd">    Sources:</span>
<span class="sd">    https://cffi.readthedocs.io/en/latest/overview.html#api-mode-calling-the-c-standard-library</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">importlib</span>
    <span class="kn">import</span> <span class="nn">tempfile</span>
    <span class="kn">import</span> <span class="nn">uuid</span>

    <span class="kn">import</span> <span class="nn">cffi</span>

    <span class="n">module_name</span> <span class="o">=</span> <span class="s2">&quot;module_&quot;</span> <span class="o">+</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span>

    <span class="k">if</span> <span class="s2">&quot;__uint128&quot;</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;_compile_C_code does not support bit-vector widths &quot;</span>
                         <span class="s2">&quot;larger than 64 bits (cffi does not support __uint128)&quot;</span><span class="p">)</span>

    <span class="n">ffibuilder</span> <span class="o">=</span> <span class="n">cffi</span><span class="o">.</span><span class="n">FFI</span><span class="p">()</span>
    <span class="n">ffibuilder</span><span class="o">.</span><span class="n">cdef</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
    <span class="n">ffibuilder</span><span class="o">.</span><span class="n">set_source</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>

    <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span>
    <span class="n">lib_path</span> <span class="o">=</span> <span class="n">ffibuilder</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">tmpdir</span><span class="o">=</span><span class="n">tmpdir</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_unloaded</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lib_path</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">tmpdir</span>

    <span class="c1"># dynamic import</span>
    <span class="c1"># https://docs.python.org/3/library/importlib.html#importing-a-source-file-directly</span>
    <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">module_name</span><span class="p">,</span> <span class="n">lib_path</span><span class="p">)</span>
    <span class="n">pymod_parent</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
    <span class="c1"># sys.modules[module_name] = module</span>
    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">pymod_parent</span><span class="p">)</span>

    <span class="n">pymod</span> <span class="o">=</span> <span class="n">pymod_parent</span>

    <span class="k">return</span> <span class="n">pymod</span><span class="p">,</span> <span class="n">tmpdir</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Adrin Ranea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>