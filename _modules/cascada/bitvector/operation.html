<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cascada.bitvector.operation &mdash; CASCADA 1.0.rc0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> CASCADA
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">CASCADA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../adding_primitive.html">Adding a primitive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../advanced_usage.html">Advanced Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primitives_implemented.html">Primitives implemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cascada.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CASCADA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>cascada.bitvector.operation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cascada.bitvector.operation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Provide the common bit-vector operators.</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">    Operation</span>
<span class="sd">    PrimaryOperation</span>
<span class="sd">    SecondaryOperation</span>
<span class="sd">    PartialOperation</span>
<span class="sd">    make_partial_operation</span>
<span class="sd">    BvNot</span>
<span class="sd">    BvAnd</span>
<span class="sd">    BvOr</span>
<span class="sd">    BvXor</span>
<span class="sd">    BvComp</span>
<span class="sd">    BvUlt</span>
<span class="sd">    BvUle</span>
<span class="sd">    BvUgt</span>
<span class="sd">    BvUge</span>
<span class="sd">    BvShl</span>
<span class="sd">    BvLshr</span>
<span class="sd">    RotateLeft</span>
<span class="sd">    RotateRight</span>
<span class="sd">    Ite</span>
<span class="sd">    Extract</span>
<span class="sd">    Concat</span>
<span class="sd">    BvNeg</span>
<span class="sd">    BvAdd</span>
<span class="sd">    BvSub</span>
<span class="sd">    BvMul</span>
<span class="sd">    BvUdiv</span>
<span class="sd">    BvUrem</span>
<span class="sd">    BvIdentity</span>
<span class="sd">    zero_extend</span>
<span class="sd">    repeat</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">sympy.core</span> <span class="kn">import</span> <span class="n">cache</span>
<span class="kn">from</span> <span class="nn">sympy.printing</span> <span class="kn">import</span> <span class="n">precedence</span> <span class="k">as</span> <span class="n">sympy_precedence</span>

<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">core</span>


<span class="nb">zip</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">zip</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cacheit</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cache functions if `CacheContext` is enabled.&quot;&quot;&quot;</span>
    <span class="n">cfunc</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">cacheit</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cached_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">context</span><span class="o">.</span><span class="n">Cache</span><span class="o">.</span><span class="n">current_context</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cfunc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cached_func</span>


<span class="k">def</span> <span class="nf">_tuplify</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">seq</span><span class="p">])</span>


<span class="c1"># noinspection PyUnresolvedReferences</span>
<div class="viewcode-block" id="Operation"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Operation">[docs]</a><span class="k">class</span> <span class="nc">Operation</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent bit-vector operations.</span>

<span class="sd">    A bit-vector operation is a mathematical function that takes some bit-vector</span>
<span class="sd">    operands (i.e. `Term`) and some scalar operands (i.e. `int`),</span>
<span class="sd">    and returns a single bit-vector term. Often, *operator* is used to</span>
<span class="sd">    denote the Python class representing the mathematical function (without operands)</span>
<span class="sd">    and *operation* is used to denote the application of an operator to some operands.</span>

<span class="sd">    A particular operator (a subclass of `Operation`) can be evaluated</span>
<span class="sd">    by instantiating an object with the operands as the object arguments.</span>
<span class="sd">    The instantiation internally calls the method `eval`, containing the logic</span>
<span class="sd">    of the operator. This behaviour is similar as those of the SymPy classes</span>
<span class="sd">    `Add &lt;https://docs.sympy.org/latest/modules/core.html?highlight=add#sympy.core.add.Add&gt;`_</span>
<span class="sd">    or `Mul &lt;https://docs.sympy.org/latest/modules/core.html?highlight=mul#sympy.core.mul.Mul&gt;`_.</span>

<span class="sd">    Unless the `Simplification` context is disabled (enabled by default),</span>
<span class="sd">    many of the operations automatically simplify complex expressions</span>
<span class="sd">    by applying basic rules from `Boolean algebra</span>
<span class="sd">    &lt;https://en.wikipedia.org/wiki/Bitwise_operation#Boolean_algebra&gt;`_.</span>
<span class="sd">    Moreoever, operations are also affected by other context managers</span>
<span class="sd">    such as `Cache`, `PrimaryOperationEvaluation`, `SecondaryOperationEvaluation`,</span>
<span class="sd">    `Validation` or `Memoization`.</span>

<span class="sd">    This class is not meant to be instantiated but to provide a base</span>
<span class="sd">    class for the two types of operations: `PrimaryOperation`</span>
<span class="sd">    and `SecondaryOperation`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        New bit-vector operations can be defined by subclassing `SecondaryOperation`</span>
<span class="sd">        (see `BvMaj` as example). It is also possible to define new bit-vector</span>
<span class="sd">        operations by subclassing `PrimaryOperation`, but this is not recommended.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        arity: a pair of number specifying the number of bit-vector operands</span>
<span class="sd">            (at least one) and scalar operands, respectively.</span>
<span class="sd">        is_symmetric: True if the operator is symmetric with respect to</span>
<span class="sd">            its operands (a permutation of the inputs does not change the output).</span>
<span class="sd">            Operators with scalar operands cannot be symmetric.</span>
<span class="sd">        is_simple: True if the operator is *simple*, that is, all its</span>
<span class="sd">            operands are bit-vector of the same width. Simple operators allow</span>
<span class="sd">            *Automatic Constant Conversion*, that is, instead of passing</span>
<span class="sd">            all arguments as bit-vector types, it is possible to pass</span>
<span class="sd">            arguments as plain integers.</span>

<span class="sd">            ::</span>

<span class="sd">                &gt;&gt;&gt; from cascada.bitvector.core import Constant</span>
<span class="sd">                &gt;&gt;&gt; (Constant(1, 8) + 1).vrepr()</span>
<span class="sd">                &#39;Constant(0b00000010, width=8)&#39;</span>

<span class="sd">        operand_types: a list specifying the types of the operands (optional</span>
<span class="sd">            if all operands are bit-vectors)</span>
<span class="sd">        alt_name: an alternative name used when printing (optional)</span>
<span class="sd">        unary_symbol: a symbol used when printing (optional)</span>
<span class="sd">        infix_symbol: a symbol used when printing (optional)</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        New operations should be added in the header of test_operation.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_Atom</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">precedence</span> <span class="o">=</span> <span class="n">sympy_precedence</span><span class="o">.</span><span class="n">PRECEDENCE</span><span class="p">[</span><span class="s2">&quot;Func&quot;</span><span class="p">]</span>

    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@_cacheit</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">,</span> <span class="n">SecondaryOperation</span><span class="p">))</span>

        <span class="n">val_op</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;validate_operands&quot;</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">Validation</span><span class="o">.</span><span class="n">current_context</span><span class="p">)</span>

        <span class="c1"># evaluate used in _binary_symmetric_simplification</span>
        <span class="n">evaluate</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;evaluate&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">pre_evaluate</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">evaluate</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">evaluate</span>
        <span class="k">if</span> <span class="n">evaluate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># options[&quot;evaluate&quot;] overrides context</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">PrimaryOperation</span><span class="p">):</span>
                <span class="n">evaluate</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">PrimaryOperationEvaluation</span><span class="o">.</span><span class="n">current_context</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">evaluate</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">SecondaryOperationEvaluation</span><span class="o">.</span><span class="n">current_context</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">,</span> <span class="n">Operation</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
                <span class="c1"># constant args</span>
                <span class="n">evaluate</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">simplify</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;simplify&quot;</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="o">.</span><span class="n">current_context</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;state&quot;</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">Memoization</span><span class="o">.</span><span class="n">current_context</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">val_op</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_parse_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">st</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">found_non_memoized_op_input</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">st</span><span class="o">.</span><span class="n">contain_op</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                        <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">get_id</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># non-simple assignments allowed in MemoizationTable</span>
                        <span class="n">found_non_memoized_op_input</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">newargs</span>

        <span class="n">width</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">output_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># if cls is secondary op, intermediate primary operations</span>
        <span class="c1"># need to be stored in st (but not for primary op)</span>
        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Memoization</span><span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">PrimaryOperation</span><span class="p">)</span> <span class="k">else</span> <span class="n">st</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">pre_evaluate</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">SecondaryOperation</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">pre_eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">evaluate</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># result is already a Term/Operation (possibly simplified)</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Operation</span><span class="p">)</span> <span class="ow">and</span> <span class="n">simplify</span> <span class="ow">and</span> <span class="n">evaluate</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="p">(</span><span class="kc">False</span><span class="p">),</span> <span class="n">context</span><span class="o">.</span><span class="n">Memoization</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">obj</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">_simplify</span><span class="p">()</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
                            <span class="k">break</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Operation</span><span class="p">)</span> <span class="ow">and</span> <span class="n">st</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">found_non_memoized_op_input</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arg </span><span class="si">{}</span><span class="s2"> of </span><span class="si">{}</span><span class="s2"> was not memoized&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">st</span><span class="o">.</span><span class="n">contain_op</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">get_id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__hash__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_symmetric</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">is_symmetric</span><span class="p">:</span>
            <span class="n">eval_sec_ops</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">SecondaryOperationEvaluation</span><span class="o">.</span><span class="n">current_context</span>
            <span class="n">sorted_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">eval_sec_ops</span><span class="o">=</span><span class="n">eval_sec_ops</span><span class="p">,</span> <span class="n">sort_symmetric_args</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sorted_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">eval_sec_ops</span><span class="o">=</span><span class="n">eval_sec_ops</span><span class="p">,</span> <span class="n">sort_symmetric_args</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">sorted_self</span><span class="p">,</span> <span class="n">sorted_other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_parse_args</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="c1"># Automatic Constant Conversion</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">is_simple</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">):</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> expects at least 1 term operand&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;operand_types&quot;</span><span class="p">):</span>
            <span class="n">operand_types</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">operand_types</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">operand_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Term</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">arg_type</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">operand_types</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">arg_type</span><span class="p">)</span>

        <span class="n">num_terms</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">num_scalars</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">):</span>
                <span class="n">num_terms</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">num_scalars</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>
        <span class="k">assert</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">arity</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">num_terms</span><span class="p">,</span> <span class="n">num_scalars</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">num_terms</span> <span class="o">&gt;=</span> <span class="mi">1</span>

        <span class="c1"># # disabled sorting symmetric operations by default</span>
        <span class="c1"># if cls.is_symmetric:</span>
        <span class="c1">#     args = sorted(args, key=sympy.default_sort_key)</span>

        <span class="k">assert</span> <span class="bp">cls</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.condition(</span><span class="si">{}</span><span class="s2">) did not hold&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">args</span>

    <span class="k">def</span> <span class="nf">_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simplify the bit-vector operation.</span>

<span class="sd">        Return the simplified value and a boolean flag depending on</span>
<span class="sd">        whether the expression was reduced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_binary_symmetric_simplification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compatible_terms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Simplify a binary symmetric operation.</span>

<span class="sd">        Replace pairs of *compatible connected terms* by their resulting value.</span>
<span class="sd">        * Two terms are connected if they are arguments of the same operator</span>
<span class="sd">          node when the bit-vector expression is flattened (e.g. ``z``</span>
<span class="sd">          and ``t`` are connected in ``((x ^ y) + z) + t``.</span>
<span class="sd">        * Two connected terms are compatible if they can be simplified.</span>
<span class="sd">          For example, two constants are always compatible.</span>

<span class="sd">        Note that this function assumed the arguments of the operation</span>
<span class="sd">        are already simplified.</span>

<span class="sd">        Args:</span>
<span class="sd">            compatible_terms: a list of lambda functions specifying</span>
<span class="sd">            the compatible terms for a particular operator.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">op</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compatible_terms</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>

        <span class="c1"># noinspection PyShadowingNames</span>
        <span class="k">def</span> <span class="nf">replace_constant</span><span class="p">(</span><span class="n">cte</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">modified</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                        <span class="n">arg</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">cte</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
                        <span class="n">modified</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
                        <span class="n">arg</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">replace_constant</span><span class="p">(</span><span class="n">cte</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_expr</span> <span class="o">=</span> <span class="n">newargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">new_expr</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid newargs length: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">newargs</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">new_expr</span><span class="p">,</span> <span class="n">modified</span>

        <span class="c1"># noinspection PyShadowingNames</span>
        <span class="k">def</span> <span class="nf">replace_term</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">compatible_terms</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
            <span class="n">modified</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">compatible_terms</span><span class="p">:</span>
                        <span class="n">arg</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
                        <span class="n">modified</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
                        <span class="n">arg</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">replace_term</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">compatible_terms</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_expr</span> <span class="o">=</span> <span class="n">newargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">newargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">new_expr</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">newargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid newargs length: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">newargs</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">new_expr</span><span class="p">,</span> <span class="n">modified</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span>

        <span class="n">modified</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># modified</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
            <span class="n">new_expr</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">replace_constant</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
            <span class="n">new_expr</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">replace_constant</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
            <span class="n">new_expr</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">replace_term</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">compatible_terms</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
            <span class="n">new_expr</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">replace_term</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">compatible_terms</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span>

            <span class="k">if</span> <span class="n">op</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">!=</span> <span class="n">op</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="n">new_expr</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">op</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                <span class="n">modified</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span> <span class="ow">and</span> <span class="n">op</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">!=</span> <span class="n">op</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="n">new_expr</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">op</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                <span class="n">modified</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span><span class="p">:</span>
                <span class="n">new_expr</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">_simplify</span><span class="p">()</span>
                <span class="n">new_expr</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">new_expr</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">modified</span><span class="p">:</span>
                <span class="n">new_expr</span><span class="p">,</span> <span class="n">modified</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">_simplify</span><span class="p">()</span>
                <span class="n">new_expr</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">new_expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">modified</span><span class="p">:</span>
            <span class="c1"># noinspection PyUnboundLocalVariable</span>
            <span class="k">return</span> <span class="n">new_expr</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="kc">False</span>

<div class="viewcode-block" id="Operation.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Operation.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if the operands verify the restrictions of the operator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Operation.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Operation.output_width">[docs]</a>    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bit-width of the resulting bit-vector.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;subclasses need to override this method&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Operation.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Operation.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the operator with given operands.</span>

<span class="sd">        This is an internal method that assumes the list ``args`` has been parsed.</span>
<span class="sd">        To evaluate a bit-vector operation, instantiate a new object with</span>
<span class="sd">        the operands as the object arguments (i.e., use the Python operator ``()``).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;subclasses need to override this method&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Operation.formula_size"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Operation.formula_size">[docs]</a>    <span class="k">def</span> <span class="nf">formula_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The formula size of the operation.&quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">log2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>

        <span class="k">def</span> <span class="nf">bin_enc</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">log2</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">bin_enc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="n">bin_enc</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="n">arg</span><span class="o">.</span><span class="n">formula_size</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">size</span></div>

<div class="viewcode-block" id="Operation.memoization_table"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Operation.memoization_table">[docs]</a>    <span class="k">def</span> <span class="nf">memoization_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_prefix</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">decompose_sec_ops</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a decomposition of the current operation into simple assignments.</span>

<span class="sd">        Given an `Operation` object :math:`F(a_1, a_2, \dots)`, this method</span>
<span class="sd">        decomposes it into a list of *simple* assignments</span>
<span class="sd">        :math:`x_{i+1} \leftarrow f_i(x_i)` such that the last output variable</span>
<span class="sd">        :math:`x_{n}` represents the output of :math:`F(a_1, a_2, \dots)`.</span>
<span class="sd">        The i-th assignment is given by:</span>

<span class="sd">            - the output `Variable` :math:`x_{i+1}` that represents</span>
<span class="sd">              the output of :math:`f_i(x_i)`,</span>

<span class="sd">            - the `Operation` object :math:`f_i(x_i)` where the input</span>
<span class="sd">              :math:`x_i` is a previous output `Variable`,</span>
<span class="sd">              an input `Variable` (of :math:`F(a_1, a_2, \dots)`),</span>
<span class="sd">              a `Constant`, a scalar, o a list of them</span>
<span class="sd">              but not an `Operation` object.</span>

<span class="sd">        The list of assignments is given as a `MemoizationTable`,</span>
<span class="sd">        and it is obtained by re-evaluating the current operation</span>
<span class="sd">        under the `Memoization` context.</span>

<span class="sd">        The argument ``id_prefix`` is the string prefix used to name</span>
<span class="sd">        intermediate variables and the argument ``decompose_sec_ops``</span>
<span class="sd">        determines whether to use the context `SecondaryOperationEvaluation`.</span>
<span class="sd">        In other words, if ``decompose_sec_ops`` is ``True``,</span>
<span class="sd">        `SecondaryOperation` objects are not allowed in the list of</span>
<span class="sd">        assignments and they are replaced by their</span>
<span class="sd">        decomposition into  `PrimaryOperation` objects.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.secondaryop import BvMaj</span>
<span class="sd">            &gt;&gt;&gt; expr = 1 + BvMaj(2, Variable(&quot;a_1&quot;, 8), 3 | Variable(&quot;a_2&quot;, 8))</span>
<span class="sd">            &gt;&gt;&gt; expr.memoization_table()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            MemoizationTable([(x0, a_2 | 0x03), (x1, 0x02 &amp; a_1), (x2, 0x02 &amp; x0),</span>
<span class="sd">            (x3, x1 | x2), (x4, a_1 &amp; x0), (x5, x3 | x4), (x6, x5 + 0x01), (x7, Id(x6))])</span>
<span class="sd">            &gt;&gt;&gt; expr.memoization_table(decompose_sec_ops=False)</span>
<span class="sd">            MemoizationTable([(x0, a_2 | 0x03), (x1, BvMaj(0x02, a_1, x0)), (x2, x1 + 0x01), (x3, Id(x2))])</span>

<span class="sd">        .. Implementation details:</span>

<span class="sd">            To use this method not only for decomposing secondary operations</span>
<span class="sd">            but also for printing complex bit-vector expressions:</span>

<span class="sd">             - This method is added to Operation and not to SecondaryOperation,</span>
<span class="sd">               to support (1 + BvMaj()).decompose() and printing any complex operation.</span>

<span class="sd">             - SSA is not returned, just the table (input/output vars not needed)</span>

<span class="sd">             - Constant and scalar inputs are supported (for printing)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">table</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">MemoizationTable</span><span class="p">(</span><span class="n">id_prefix</span><span class="o">=</span><span class="n">id_prefix</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Memoization</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">eval_sec_ops</span><span class="o">=</span><span class="n">decompose_sec_ops</span><span class="p">)</span>
        <span class="n">last_assignment</span> <span class="o">=</span> <span class="n">BvIdentity</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">evaluate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">table</span><span class="o">.</span><span class="n">contain_op</span><span class="p">(</span><span class="n">last_assignment</span><span class="p">)</span>
        <span class="n">table</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">last_assignment</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">table</span></div></div>


<div class="viewcode-block" id="PrimaryOperation"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.PrimaryOperation">[docs]</a><span class="k">class</span> <span class="nc">PrimaryOperation</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the primary bit-vector operations.</span>

<span class="sd">    The primary bit-vector operations are those *basic*</span>
<span class="sd">    operations that are included in the  bit-vector theory of the</span>
<span class="sd">    `SMT_LIBv2 &lt;http://smtlib.cs.uiowa.edu/theories-FixedSizeBitVectors.shtml&gt;`_</span>
<span class="sd">    format.</span>

<span class="sd">    The primary operations are `BvAnd`, `BvOr`, `BvXor`, `BvComp`, `BvUlt`,</span>
<span class="sd">    `BvUle`, `BvUgt`, `BvUge`, `BvShl`, `BvLshr`, `RotateLeft`, `RotateRight`,</span>
<span class="sd">    `Concat`, `BvAdd`, `BvSub`, `BvMul`, `BvUdiv`, `BvUrem`, `BvNeg`, `BvNot`,</span>
<span class="sd">    `Extract`, `Ite` and `BvIdentity`.</span>

<span class="sd">    This class is not meant to be instantiated but to provide a base</span>
<span class="sd">    class to define primary operators.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PrimaryOperation.class_key"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.PrimaryOperation.class_key">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_key</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span></div></div>


<div class="viewcode-block" id="SecondaryOperation"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.SecondaryOperation">[docs]</a><span class="k">class</span> <span class="nc">SecondaryOperation</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent secondary bit-vector operations.</span>

<span class="sd">    Secondary bit-vector operations are those bit-vector operations</span>
<span class="sd">    that are not primary operations (see `PrimaryOperation`).</span>
<span class="sd">    Secondary operations must be defined in terms of primary operations.</span>

<span class="sd">    By default, secondary operations are fully evaluated (`Operation.eval`</span>
<span class="sd">    is used) if all the operands are scalar or `Constant` objects (see also</span>
<span class="sd">    `context.SecondaryOperationEvaluation`). On the other hand, `pre_eval`</span>
<span class="sd">    is always called in the evaluation (even with symbolic inputs).</span>

<span class="sd">    This class is not meant to be instantiated but to provide a base</span>
<span class="sd">    class to define secondary operators.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SecondaryOperation.pre_eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.SecondaryOperation.pre_eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">pre_eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the operator before `Operation.eval`.</span>

<span class="sd">        This is an internal method that assumes the list ``args`` has been parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="SecondaryOperation.class_key"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.SecondaryOperation.class_key">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">class_key</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span></div>

<div class="viewcode-block" id="SecondaryOperation.formula_size"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.SecondaryOperation.formula_size">[docs]</a>    <span class="k">def</span> <span class="nf">formula_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span><span class="o">.</span><span class="n">formula_size</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="PartialOperation"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.PartialOperation">[docs]</a><span class="k">class</span> <span class="nc">PartialOperation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent bit-vector operations with fixed operands.</span>

<span class="sd">    Given a base operator :math:`(x, y) \mapsto  f(x, y)`,</span>
<span class="sd">    a partial operator is a function obtained by fixing some</span>
<span class="sd">    of the inputs to constants, e.g., :math:`x \mapsto f(x, y=0)`.</span>

<span class="sd">    This class is not meant to be instantiated but to provide a base</span>
<span class="sd">    class for bit-vector operations with fixed operands generated</span>
<span class="sd">    through `make_partial_operation`.</span>
<span class="sd">    `PartialOperation` subclasses generated by `make_partial_operation`</span>
<span class="sd">    are also subclasses of `PrimaryOperation` or `SecondaryOperation`</span>
<span class="sd">    depending on the type of the base operator.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        base_op: a subclass of `Operation` denoting the base operator.</span>
<span class="sd">        fixed_args: a `tuple` with the same length as the number of operands</span>
<span class="sd">            of the base function containing ``None``, scalar or `Constant` elements.</span>
<span class="sd">            If ``fixed_args[i]`` is ``None``, the i-th operand is not fixed;</span>
<span class="sd">            otherwise, the i-th operand is replaced with ``fixed_args[i]``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_get_base_op_args</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">full_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">f_arg</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f_arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">full_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">full_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">full_args</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">base_op</span><span class="o">.</span><span class="n">condition</span><span class="p">(</span><span class="o">*</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_base_op_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">base_op</span><span class="o">.</span><span class="n">output_width</span><span class="p">(</span><span class="o">*</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_base_op_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">pre_eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">base_op</span><span class="p">,</span> <span class="n">SecondaryOperation</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">base_op</span><span class="p">,</span> <span class="s2">&quot;pre_eval&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">base_op</span><span class="o">.</span><span class="n">pre_eval</span><span class="p">(</span><span class="o">*</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_base_op_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">base_op_eval</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">base_op</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="o">*</span><span class="bp">cls</span><span class="o">.</span><span class="n">_get_base_op_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base_op_eval</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">base_op</span><span class="p">):</span>
            <span class="c1"># trying to convert base_op_eval to a PartialOp object</span>
            <span class="n">non_fixed_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">b_arg</span><span class="p">,</span> <span class="n">f_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">base_op_eval</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">f_arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">b_arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="n">non_fixed_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">b_arg</span> <span class="o">!=</span> <span class="n">f_arg</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">base_op_eval</span>  <span class="c1"># conversion failed</span>
            <span class="c1"># similar as super().__new__ in Operation.__new__</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">base_op_eval</span><span class="o">.</span><span class="n">width</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">non_fixed_args</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>  <span class="c1"># conversion succeed</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">base_op_eval</span>

    <span class="k">def</span> <span class="nf">_get_base_op_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">base_op</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">_get_base_op_args</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">formula_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_base_op_expr</span><span class="p">()</span><span class="o">.</span><span class="n">formula_size</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">memoization_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_prefix</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">decompose_sec_ops</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_base_op_expr</span><span class="p">()</span><span class="o">.</span><span class="n">memoization_table</span><span class="p">(</span>
            <span class="n">id_prefix</span><span class="o">=</span><span class="n">id_prefix</span><span class="p">,</span> <span class="n">decompose_sec_ops</span><span class="o">=</span><span class="n">decompose_sec_ops</span><span class="p">)</span></div>


<div class="viewcode-block" id="make_partial_operation"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.make_partial_operation">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># temporary hack to create singletons</span>
<span class="k">def</span> <span class="nf">make_partial_operation</span><span class="p">(</span><span class="n">base_op</span><span class="p">,</span> <span class="n">fixed_args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a new `PartialOperation` subclass with the given base operator and fixed arguments.</span>

<span class="sd">    The argument ``fixed_args`` is a `tuple`, with the same length as</span>
<span class="sd">    the number of operands of the base operator, containing ``None``,</span>
<span class="sd">    scalar or `Constant` elements. If ``fixed_args[i]`` is ``None``,</span>
<span class="sd">    the i-th operand is not fixed; otherwise, the i-th operand is</span>
<span class="sd">    replaced with ``fixed_args[i]``.</span>

<span class="sd">    The resulting class is also a subclass of `PrimaryOperation` or</span>
<span class="sd">    `SecondaryOperation`, depending on the type of the base operator.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvAdd, Extract, make_partial_operation</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.secondaryop import BvMaj</span>
<span class="sd">        &gt;&gt;&gt; BvAddCte = make_partial_operation(BvAdd, tuple([None, Constant(1, 4)]))</span>
<span class="sd">        &gt;&gt;&gt; BvAddCte.__name__</span>
<span class="sd">        &#39;BvAdd_{·, 0x1}&#39;</span>
<span class="sd">        &gt;&gt;&gt; expr = BvAddCte(Variable(&quot;a&quot;, 4))</span>
<span class="sd">        &gt;&gt;&gt; expr</span>
<span class="sd">        a + 0x1</span>
<span class="sd">        &gt;&gt;&gt; expr.vrepr()</span>
<span class="sd">        &quot;make_partial_operation(BvAdd, (None, Constant(0b0001, width=4)))(Variable(&#39;a&#39;, width=4))&quot;</span>
<span class="sd">        &gt;&gt;&gt; ExtractLSB = make_partial_operation(Extract, tuple([None, 0, 0]))</span>
<span class="sd">        &gt;&gt;&gt; ExtractLSB.__name__</span>
<span class="sd">        &#39;Extract_{·, 0, 0}&#39;</span>
<span class="sd">        &gt;&gt;&gt; ExtractLSB(Extract(Variable(&quot;a&quot;, 4), 2, 0))  # result is simplified</span>
<span class="sd">        a[0]</span>
<span class="sd">        &gt;&gt;&gt; BvCteMaj = make_partial_operation(BvMaj, tuple([None, None, Constant(1, 4)]))</span>
<span class="sd">        &gt;&gt;&gt; BvCteMaj.__name__</span>
<span class="sd">        &#39;BvMaj_{·, ·, 0x1}&#39;</span>
<span class="sd">        &gt;&gt;&gt; BvCteMaj(Variable(&quot;a&quot;, 4), Variable(&quot;a&quot;, 4))</span>
<span class="sd">        a</span>
<span class="sd">        &gt;&gt;&gt; expr = BvCteMaj(Variable(&quot;a&quot;, 4), Variable(&quot;b&quot;, 4))</span>
<span class="sd">        &gt;&gt;&gt; expr</span>
<span class="sd">        BvMaj_{·, ·, 0x1}(a, b)</span>
<span class="sd">        &gt;&gt;&gt; expr.doit()</span>
<span class="sd">        (a &amp; b) | (a &amp; 0x1) | (b &amp; 0x1)</span>
<span class="sd">        &gt;&gt;&gt; expr.memoization_table()</span>
<span class="sd">        MemoizationTable([(x0, a &amp; b), (x1, a &amp; 0x1), (x2, x0 | x1), (x3, b &amp; 0x1), (x4, x2 | x3), (x5, Id(x4))])</span>
<span class="sd">        &gt;&gt;&gt; BvCteMaj_v2 = make_partial_operation(BvCteMaj, tuple([Constant(2, 4), None]))</span>
<span class="sd">        &gt;&gt;&gt; BvCteMaj_v2.__name__</span>
<span class="sd">        &#39;BvMaj_{0x2, ·, 0x1}&#39;</span>
<span class="sd">        &gt;&gt;&gt; BvCteMaj_v2(Variable(&quot;a&quot;, 4))</span>
<span class="sd">        BvMaj_{0x2, ·, 0x1}(a)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">base_op</span><span class="p">,</span> <span class="n">Operation</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fixed_args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixed_args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">base_op</span><span class="o">.</span><span class="n">arity</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">))</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">fixed_args</span><span class="p">)</span>

    <span class="c1"># at least one None and one non-None in fixed_args</span>
    <span class="k">assert</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">fixed_args</span>
    <span class="k">assert</span> <span class="nb">any</span><span class="p">(</span><span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">fixed_args</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">base_op</span><span class="p">,</span> <span class="n">PartialOperation</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixed_args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">base_op</span><span class="o">.</span><span class="n">fixed_args</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">])</span>
        <span class="n">combined_fixed_args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">base_op</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">)</span>
        <span class="n">counter_None</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">combined_fixed_args</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">combined_fixed_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">combined_fixed_args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fixed_args</span><span class="p">[</span><span class="n">counter_None</span><span class="p">]</span>
                <span class="n">counter_None</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">counter_None</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fixed_args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_partial_operation</span><span class="p">(</span><span class="n">base_op</span><span class="o">.</span><span class="n">base_op</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">combined_fixed_args</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">base_op</span><span class="p">,</span> <span class="s2">&quot;operand_types&quot;</span><span class="p">):</span>
        <span class="n">operand_types</span> <span class="o">=</span> <span class="n">base_op</span><span class="o">.</span><span class="n">operand_types</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">operand_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Term</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fixed_args</span><span class="p">))]</span>

    <span class="n">num_terms_fixed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">num_scalars_fixed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">free_operand_types</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fixed_args_str</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arg</span><span class="p">,</span> <span class="n">type_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fixed_args</span><span class="p">,</span> <span class="n">operand_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">free_operand_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">type_arg</span><span class="p">)</span>
            <span class="n">fixed_args_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;·&quot;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">type_arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">type_arg</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
            <span class="n">num_scalars_fixed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">):</span>
            <span class="n">num_terms_fixed</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>
        <span class="n">fixed_args_str</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">base_op</span><span class="p">,</span> <span class="n">PrimaryOperation</span><span class="p">):</span>
        <span class="n">parent_class</span> <span class="o">=</span> <span class="n">PrimaryOperation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">base_op</span><span class="p">,</span> <span class="n">SecondaryOperation</span><span class="p">)</span>
        <span class="n">parent_class</span> <span class="o">=</span> <span class="n">SecondaryOperation</span>

    <span class="n">_base_op</span> <span class="o">=</span> <span class="n">base_op</span>
    <span class="n">_fixed_args</span> <span class="o">=</span> <span class="n">fixed_args</span>

    <span class="n">_arity</span> <span class="o">=</span> <span class="p">[</span><span class="n">base_op</span><span class="o">.</span><span class="n">arity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_terms_fixed</span><span class="p">,</span> <span class="n">base_op</span><span class="o">.</span><span class="n">arity</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_scalars_fixed</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">_arity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="n">_is_symmetric</span> <span class="o">=</span> <span class="n">base_op</span><span class="o">.</span><span class="n">is_symmetric</span>
    <span class="n">_is_simple</span> <span class="o">=</span> <span class="n">base_op</span><span class="o">.</span><span class="n">is_simple</span> <span class="ow">and</span> <span class="nb">sum</span><span class="p">(</span><span class="n">_arity</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="n">_operand_types</span> <span class="o">=</span> <span class="n">free_operand_types</span>

    <span class="c1"># avoid subclassing base_op (may introduce side effects)</span>
    <span class="k">class</span> <span class="nc">MyPartialOperation</span><span class="p">(</span><span class="n">PartialOperation</span><span class="p">,</span> <span class="n">parent_class</span><span class="p">):</span>
        <span class="n">base_op</span> <span class="o">=</span> <span class="n">_base_op</span>
        <span class="n">fixed_args</span> <span class="o">=</span> <span class="n">_fixed_args</span>

        <span class="n">arity</span> <span class="o">=</span> <span class="n">_arity</span>
        <span class="n">is_symmetric</span> <span class="o">=</span> <span class="n">_is_symmetric</span>
        <span class="n">is_simple</span> <span class="o">=</span> <span class="n">_is_simple</span>
        <span class="n">operand_types</span> <span class="o">=</span> <span class="n">_operand_types</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">base_op</span><span class="p">,</span> <span class="s2">&quot;alt_name&quot;</span><span class="p">):</span>
        <span class="n">MyPartialOperation</span><span class="o">.</span><span class="n">alt_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_op</span><span class="o">.</span><span class="n">alt_name</span><span class="si">}</span><span class="s2">_</span><span class="se">{{</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fixed_args_str</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>

    <span class="n">MyPartialOperation</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_op</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">_</span><span class="se">{{</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fixed_args_str</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>

    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">parent_class</span><span class="p">,</span> <span class="n">PrimaryOperation</span><span class="p">)</span> <span class="o">==</span> \
           <span class="nb">issubclass</span><span class="p">(</span><span class="n">MyPartialOperation</span><span class="p">,</span> <span class="n">PrimaryOperation</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">parent_class</span><span class="p">,</span> <span class="n">SecondaryOperation</span><span class="p">)</span> <span class="o">==</span> \
           <span class="nb">issubclass</span><span class="p">(</span><span class="n">MyPartialOperation</span><span class="p">,</span> <span class="n">SecondaryOperation</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">MyPartialOperation</span></div>


<span class="c1"># Bitwise operators</span>

<div class="viewcode-block" id="BvNot"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvNot">[docs]</a><span class="k">class</span> <span class="nc">BvNot</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bitwise negation operation.</span>

<span class="sd">    It overrides the operator ~. See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvNot</span>
<span class="sd">        &gt;&gt;&gt; BvNot(Constant(0b1010101, 7))</span>
<span class="sd">        0b0101010</span>
<span class="sd">        &gt;&gt;&gt; ~Constant(0b1010101, 7)</span>
<span class="sd">        0b0101010</span>
<span class="sd">        &gt;&gt;&gt; ~Variable(&quot;x&quot;, 8)</span>
<span class="sd">        ~x</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">unary_symbol</span> <span class="o">=</span> <span class="s2">&quot;~&quot;</span>

<div class="viewcode-block" id="BvNot.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvNot.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvNot.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvNot.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;NOT operation when the operand is int.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="o">~</span><span class="n">x</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BvNot</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div>
        <span class="c1"># # De Morgan&#39;s laws (disabled, all op equal precedence)</span>
        <span class="c1"># if isinstance(x, BvAnd):</span>
        <span class="c1">#     return BvOr(BvNot(x.args[0]), BvNot(x.args[1]))</span>
        <span class="c1"># elif isinstance(x, BvOr):</span>
        <span class="c1">#     return BvAnd(BvNot(x.args[0]), BvNot(x.args[1]))</span>


<div class="viewcode-block" id="BvAnd"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvAnd">[docs]</a><span class="k">class</span> <span class="nc">BvAnd</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bitwise AND (logical conjunction) operation.</span>

<span class="sd">    It overrides the operator &amp; and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvAnd</span>
<span class="sd">        &gt;&gt;&gt; BvAnd(Constant(5, 8), Constant(3, 8))</span>
<span class="sd">        0x01</span>
<span class="sd">        &gt;&gt;&gt; BvAnd(Constant(5, 8), 3)</span>
<span class="sd">        0x01</span>
<span class="sd">        &gt;&gt;&gt; Constant(5, 8) &amp; 3</span>
<span class="sd">        0x01</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) &amp; Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x &amp; y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;&amp;&quot;</span>

<div class="viewcode-block" id="BvAnd.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvAnd.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvAnd.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvAnd.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvAnd.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvAnd.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;AND operation when both operands are int.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="n">allones</span> <span class="o">=</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">zero</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">allones</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="n">allones</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BvOr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>  <span class="c1"># (... | y) &amp; y = y</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">BvOr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>  <span class="c1"># x &amp; (x | ...) = x</span>
            <span class="k">return</span> <span class="n">x</span></div>

    <span class="k">def</span> <span class="nf">_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># simplify if x and x (or x and ~x) appear in a flattened conjunction</span>
        <span class="n">compatible_terms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_symmetric_simplification</span><span class="p">(</span><span class="n">compatible_terms</span><span class="p">)</span></div>


<div class="viewcode-block" id="BvOr"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvOr">[docs]</a><span class="k">class</span> <span class="nc">BvOr</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bitwise OR (logical disjunction) operation.</span>

<span class="sd">    It overrides the operator | and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvOr</span>
<span class="sd">        &gt;&gt;&gt; BvOr(Constant(5, 8), Constant(3, 8))</span>
<span class="sd">        0x07</span>
<span class="sd">        &gt;&gt;&gt; BvOr(Constant(5, 8), 3)</span>
<span class="sd">        0x07</span>
<span class="sd">        &gt;&gt;&gt; Constant(5, 8) | 3</span>
<span class="sd">        0x07</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) | Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x | y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span>

<div class="viewcode-block" id="BvOr.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvOr.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvOr.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvOr.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvOr.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvOr.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;OR operation when both operands are int.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="n">allones</span> <span class="o">=</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">zero</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">allones</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="n">allones</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">allones</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">allones</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BvAnd</span><span class="p">)</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>  <span class="c1"># (... &amp; y) | y = y</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">BvAnd</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>  <span class="c1"># x | (x &amp; ...) = x</span>
            <span class="k">return</span> <span class="n">x</span></div>

    <span class="k">def</span> <span class="nf">_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">compatible_terms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_symmetric_simplification</span><span class="p">(</span><span class="n">compatible_terms</span><span class="p">)</span></div>


<div class="viewcode-block" id="BvXor"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvXor">[docs]</a><span class="k">class</span> <span class="nc">BvXor</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bitwise XOR (exclusive-or) operation.</span>

<span class="sd">    It overrides the operator ^ and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvXor</span>
<span class="sd">        &gt;&gt;&gt; BvXor(Constant(5, 8), Constant(3, 8))</span>
<span class="sd">        0x06</span>
<span class="sd">        &gt;&gt;&gt; BvXor(Constant(5, 8), 3)</span>
<span class="sd">        0x06</span>
<span class="sd">        &gt;&gt;&gt; Constant(5, 8) ^ 3</span>
<span class="sd">        0x06</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) ^ Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x ^ y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;^&quot;</span>

<div class="viewcode-block" id="BvXor.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvXor.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvXor.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvXor.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvXor.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvXor.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;XOR operation when both operands are int.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="n">allones</span> <span class="o">=</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">zero</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">allones</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="n">allones</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">allones</span></div>

    <span class="k">def</span> <span class="nf">_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">compatible_terms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">BvNot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_symmetric_simplification</span><span class="p">(</span><span class="n">compatible_terms</span><span class="p">)</span></div>

<span class="c1"># Relational operators</span>


<div class="viewcode-block" id="BvComp"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvComp">[docs]</a><span class="k">class</span> <span class="nc">BvComp</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Equality operator.</span>

<span class="sd">    Provides Automatic Constant Conversion. See `PrimaryOperation` for more</span>
<span class="sd">    information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvComp</span>
<span class="sd">        &gt;&gt;&gt; BvComp(Constant(1, 8), Constant(2, 8))</span>
<span class="sd">        0b0</span>
<span class="sd">        &gt;&gt;&gt; BvComp(Constant(1, 8), 2)</span>
<span class="sd">        0b0</span>
<span class="sd">        &gt;&gt;&gt; x, y = Variable(&quot;x&quot;, 8), Variable(&quot;y&quot;, 8)</span>
<span class="sd">        &gt;&gt;&gt; BvComp(Constant(1, 8), Variable(&quot;y&quot;, 8))</span>
<span class="sd">        0x01 == y</span>
<span class="sd">        &gt;&gt;&gt; bool(BvComp(x + y, y + x))</span>
<span class="sd">        True</span>

<span class="sd">    The operator == is used for exact structural equality testing and</span>
<span class="sd">    it returns either True or False. On the other hand, BvComp</span>
<span class="sd">    performs symbolic equality testing and it leaves the relation unevaluated</span>
<span class="sd">    if it cannot prove the objects are equal (or unequal).</span>

<span class="sd">        &gt;&gt;&gt; x == y</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; BvComp(x, y)  # symbolic equality</span>
<span class="sd">        x == y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;==&quot;</span>

<div class="viewcode-block" id="BvComp.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvComp.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvComp.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvComp.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="BvComp.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvComp.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">one</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">one</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">val</span> <span class="k">else</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;is_symmetric&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span>  <span class="nb">getattr</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="s2">&quot;is_symmetric&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">eval_sec_ops</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">SecondaryOperationEvaluation</span><span class="o">.</span><span class="n">current_context</span>
            <span class="n">sorted_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">eval_sec_ops</span><span class="o">=</span><span class="n">eval_sec_ops</span><span class="p">,</span> <span class="n">sort_symmetric_args</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">sorted_y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">doit</span><span class="p">(</span><span class="n">eval_sec_ops</span><span class="o">=</span><span class="n">eval_sec_ops</span><span class="p">,</span> <span class="n">sort_symmetric_args</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sorted_x</span> <span class="o">==</span> <span class="n">sorted_y</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">one</span></div></div>


<div class="viewcode-block" id="BvUlt"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUlt">[docs]</a><span class="k">class</span> <span class="nc">BvUlt</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unsigned less than operator.</span>

<span class="sd">    It overrides &lt; and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvUlt</span>
<span class="sd">        &gt;&gt;&gt; BvUlt(Constant(1, 8), Constant(2, 8))</span>
<span class="sd">        0b1</span>
<span class="sd">        &gt;&gt;&gt; BvUlt(Constant(1, 8), 2)</span>
<span class="sd">        0b1</span>
<span class="sd">        &gt;&gt;&gt; Constant(1, 8) &lt; 2</span>
<span class="sd">        0b1</span>
<span class="sd">        &gt;&gt;&gt; Constant(1, 8) &lt; Variable(&quot;y&quot;, 8)</span>
<span class="sd">        0x01 &lt; y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;&lt;&quot;</span>

<div class="viewcode-block" id="BvUlt.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUlt.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvUlt.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUlt.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="BvUlt.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUlt.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">one</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">.</span><span class="n">val</span> <span class="k">else</span> <span class="n">zero</span></div></div>


<div class="viewcode-block" id="BvUle"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUle">[docs]</a><span class="k">class</span> <span class="nc">BvUle</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unsigned less than or equal operator.</span>

<span class="sd">    It overrides &lt;= and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvUle</span>
<span class="sd">        &gt;&gt;&gt; BvUle(Constant(2, 8), Constant(2, 8))</span>
<span class="sd">        0b1</span>
<span class="sd">        &gt;&gt;&gt; BvUle(Constant(2, 8), 2)</span>
<span class="sd">        0b1</span>
<span class="sd">        &gt;&gt;&gt; Constant(2, 8) &lt;= 2</span>
<span class="sd">        0b1</span>
<span class="sd">        &gt;&gt;&gt; Constant(2, 8) &lt;= Variable(&quot;y&quot;, 8)</span>
<span class="sd">        0x02 &lt;= y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;&lt;=&quot;</span>

<div class="viewcode-block" id="BvUle.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUle.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvUle.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUle.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="BvUle.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUle.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">one</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">.</span><span class="n">val</span> <span class="k">else</span> <span class="n">zero</span></div></div>


<div class="viewcode-block" id="BvUgt"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUgt">[docs]</a><span class="k">class</span> <span class="nc">BvUgt</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unsigned greater than operator.</span>

<span class="sd">    It overrides &gt; and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvUgt</span>
<span class="sd">        &gt;&gt;&gt; BvUgt(Constant(1, 8), Constant(2, 8))</span>
<span class="sd">        0b0</span>
<span class="sd">        &gt;&gt;&gt; BvUgt(Constant(1, 8), 2)</span>
<span class="sd">        0b0</span>
<span class="sd">        &gt;&gt;&gt; Constant(1, 8) &gt; 2</span>
<span class="sd">        0b0</span>
<span class="sd">        &gt;&gt;&gt; Constant(1, 8) &gt; Variable(&quot;y&quot;, 8)</span>
<span class="sd">        0x01 &gt; y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;&gt;&quot;</span>

<div class="viewcode-block" id="BvUgt.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUgt.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvUgt.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUgt.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="BvUgt.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUgt.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">one</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">.</span><span class="n">val</span> <span class="k">else</span> <span class="n">zero</span></div></div>


<div class="viewcode-block" id="BvUge"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUge">[docs]</a><span class="k">class</span> <span class="nc">BvUge</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unsigned greater than or equal operator.</span>

<span class="sd">    It overrides &gt;= and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvUgt</span>
<span class="sd">        &gt;&gt;&gt; BvUge(Constant(2, 8), Constant(2, 8))</span>
<span class="sd">        0b1</span>
<span class="sd">        &gt;&gt;&gt; BvUge(Constant(2, 8), 2)</span>
<span class="sd">        0b1</span>
<span class="sd">        &gt;&gt;&gt; Constant(2, 8) &gt;= 2</span>
<span class="sd">        0b1</span>
<span class="sd">        &gt;&gt;&gt; Constant(2, 8) &gt;= Variable(&quot;y&quot;, 8)</span>
<span class="sd">        0x02 &gt;= y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;&gt;=&quot;</span>

<div class="viewcode-block" id="BvUge.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUge.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvUge.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUge.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="BvUge.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUge.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">one</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="o">.</span><span class="n">val</span> <span class="k">else</span> <span class="n">zero</span></div></div>


<span class="c1"># Shifts operators</span>

<div class="viewcode-block" id="BvShl"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvShl">[docs]</a><span class="k">class</span> <span class="nc">BvShl</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shift left operation.</span>

<span class="sd">    It overrides &lt;&lt; and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvShl</span>
<span class="sd">        &gt;&gt;&gt; BvShl(Constant(0b10001, 5), Constant(1, 5))</span>
<span class="sd">        0b00010</span>
<span class="sd">        &gt;&gt;&gt; BvShl(Constant(0b10001, 5), 1)</span>
<span class="sd">        0b00010</span>
<span class="sd">        &gt;&gt;&gt; Constant(0b10001, 5) &lt;&lt; 1</span>
<span class="sd">        0b00010</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) &lt;&lt; Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x &lt;&lt; y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;&lt;&lt;&quot;</span>

<div class="viewcode-block" id="BvShl.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvShl.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvShl.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvShl.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvShl.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvShl.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Shift left operation when both operands are int.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">width</span><span class="p">)</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="c1"># y &gt;= x.width doesn&#39;t evaluate even if y is a Constant</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BvShl</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="c1"># prevent out of bound</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">BvShl</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="BvLshr"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvLshr">[docs]</a><span class="k">class</span> <span class="nc">BvLshr</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Logical right shift operation.</span>

<span class="sd">    It overrides &gt;&gt; and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvLshr</span>
<span class="sd">        &gt;&gt;&gt; BvLshr(Constant(0b10001, 5), Constant(1, 5))</span>
<span class="sd">        0b01000</span>
<span class="sd">        &gt;&gt;&gt; BvLshr(Constant(0b10001, 5), 1)</span>
<span class="sd">        0b01000</span>
<span class="sd">        &gt;&gt;&gt; Constant(0b10001, 5) &gt;&gt; 1</span>
<span class="sd">        0b01000</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) &gt;&gt; Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x &gt;&gt; y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&quot;</span>

<div class="viewcode-block" id="BvLshr.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvLshr.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvLshr.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvLshr.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvLshr.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvLshr.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Logical right shift operation when both operands are int.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BvLshr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">BvLshr</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="RotateLeft"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.RotateLeft">[docs]</a><span class="k">class</span> <span class="nc">RotateLeft</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Circular left rotation operation.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import RotateLeft</span>
<span class="sd">        &gt;&gt;&gt; RotateLeft(Constant(150, 8), 2)</span>
<span class="sd">        0x5a</span>
<span class="sd">        &gt;&gt;&gt; RotateLeft(Variable(&quot;x&quot;, 8), 2)</span>
<span class="sd">        x &lt;&lt;&lt; 2</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;&lt;&lt;&lt;&quot;</span>
    <span class="n">operand_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<div class="viewcode-block" id="RotateLeft.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.RotateLeft.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="RotateLeft.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.RotateLeft.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="RotateLeft.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.RotateLeft.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Left cyclic rotation operation when both operands are int.&quot;&quot;&quot;</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">%</span> <span class="n">width</span>
            <span class="c1"># source: hacker&#39;s delight 2-15</span>
            <span class="c1"># equivalently ((val &lt;&lt; r) | (val &gt;&gt; (width - r))) &amp; mask</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="n">r</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RotateLeft</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">RotateLeft</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">%</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RotateRight</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">RotateRight</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">%</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="RotateRight"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.RotateRight">[docs]</a><span class="k">class</span> <span class="nc">RotateRight</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Circular right rotation operation.</span>

<span class="sd">    It provides Automatic Constant Conversion. See `PrimaryOperation` for more</span>
<span class="sd">    information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import RotateRight</span>
<span class="sd">        &gt;&gt;&gt; RotateRight(Constant(150, 8), 3)</span>
<span class="sd">        0xd2</span>
<span class="sd">        &gt;&gt;&gt; RotateRight(Variable(&quot;x&quot;, 8), 3)</span>
<span class="sd">        x &gt;&gt;&gt; 3</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&gt;&quot;</span>
    <span class="n">operand_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<div class="viewcode-block" id="RotateRight.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.RotateRight.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="RotateRight.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.RotateRight.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="RotateRight.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.RotateRight.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Right cyclic rotation operation when both operands are int.&quot;&quot;&quot;</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">%</span> <span class="n">width</span>
            <span class="c1"># source: hacker&#39;s delight 2-15</span>
            <span class="c1"># equivalently ((val &gt;&gt; r) | (val &lt;&lt; (width - r))) &amp; mask</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RotateRight</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">RotateRight</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">%</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">RotateLeft</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">RotateLeft</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">%</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">)</span></div></div>


<span class="c1"># Others</span>

<div class="viewcode-block" id="Ite"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Ite">[docs]</a><span class="k">class</span> <span class="nc">Ite</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;If-then-else operator.</span>

<span class="sd">    ``Ite(b, x, y)`` returns ``x`` if ``b == 0b1`` and ``y`` otherwise.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import Ite</span>
<span class="sd">        &gt;&gt;&gt; Ite(Constant(0, 1), Constant(0b11, 2), Constant(0b00, 2))</span>
<span class="sd">        0b00</span>
<span class="sd">        &gt;&gt;&gt; Ite(Constant(1, 1), Constant(0x1, 4), Constant(0x0, 4))</span>
<span class="sd">        0x1</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Ite.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Ite.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="Ite.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Ite.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="Ite.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Ite.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">y</span></div></div>


<div class="viewcode-block" id="Extract"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Extract">[docs]</a><span class="k">class</span> <span class="nc">Extract</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extraction of bits.</span>

<span class="sd">    ``Extract(t, i, j)`` extracts the bits from position ``i`` down</span>
<span class="sd">    position ``j`` (end points included, position 0 corresponding</span>
<span class="sd">    to the least significant bit).</span>

<span class="sd">    It overrides the operation [], that is, ``Extract(t, i, j)``</span>
<span class="sd">    is equivalent to ``t[i:j]``.</span>

<span class="sd">    Note that the indices can be omitted when they point the most</span>
<span class="sd">    significant bit or the least significant bit.</span>
<span class="sd">    For example, if ``t`` is a bit-vector of length ``n``,</span>
<span class="sd">    then ``t[n-1:j] = t[:j]`` and ``t[i:0] = t[i:]``</span>

<span class="sd">    Warning:</span>
<span class="sd">        In python, given a list ``l``, ``l[i:j]`` denotes the elements</span>
<span class="sd">        from position ``i`` up to (but not included) position ``j``.</span>
<span class="sd">        Note that with bit-vectors, the order of the arguments is</span>
<span class="sd">        swapped and both end points are included.</span>

<span class="sd">        For example, for a given list ``l`` and bit-vector ``t``,</span>
<span class="sd">        ``l[0:1] == l[0]`` and ``t[1:0] == (t[0], t[1])``.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import Extract</span>
<span class="sd">        &gt;&gt;&gt; Extract(Constant(0b11100, 5), 4, 2,)</span>
<span class="sd">        0b111</span>
<span class="sd">        &gt;&gt;&gt; Constant(0b11100, 5)[4:2]</span>
<span class="sd">        0b111</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8)[4:2]</span>
<span class="sd">        x[4:2]</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8)[7:0]</span>
<span class="sd">        x</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">operand_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>

<div class="viewcode-block" id="Extract.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Extract.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span></div>

<div class="viewcode-block" id="Extract.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Extract.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Extract.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Extract.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Extract from x[i] down x[j] from a constant x.&quot;&quot;&quot;</span>
            <span class="n">bin_repr</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">bin</span><span class="p">()</span>
            <span class="n">prefix</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">bin_repr</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">bin_repr</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">:</span><span class="n">n</span> <span class="o">-</span> <span class="n">j</span><span class="p">]</span>  <span class="c1"># e.g.: i=n-1, j=0</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">value</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="bp">cls</span><span class="o">.</span><span class="n">output_width</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Extract</span><span class="p">):</span>
            <span class="c1"># x[3:1][2] = (x3 x2 x1)[2] = x3 = x[3]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Extract</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Concat</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># 4-bit x, y: concat(x, y)[3:] = y[3:]</span>
                <span class="k">return</span> <span class="n">Extract</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
                <span class="c1"># 4-bit x, y: concat(x, y)[:5] = x[:1]</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">width</span>
                <span class="k">return</span> <span class="n">Extract</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">BvShl</span><span class="p">,</span> <span class="n">RotateLeft</span><span class="p">))</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
            <span class="c1"># (x &lt;&lt; 1)[:2] = x[n-2: 1]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Extract</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">BvLshr</span><span class="p">,</span> <span class="n">RotateRight</span><span class="p">))</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">))</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># (x &gt;&gt; 1)[n-3:] = x[n-2: 1]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Extract</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Concat"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Concat">[docs]</a><span class="k">class</span> <span class="nc">Concat</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Concatenation operation.</span>

<span class="sd">    Given the bit-vectors :math:`(x_{n-1}, \dots, x_0)` and</span>
<span class="sd">    :math:`(y_{m-1}, \dots, y_0)`, ``Concat(x, y)`` returns the bit-vector</span>
<span class="sd">    :math:`(x_{n-1}, \dots, x_0, y_{m-1}, \dots, y_0)`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import Concat</span>
<span class="sd">        &gt;&gt;&gt; Concat(Constant(0x12, 8), Constant(0x345, 12))</span>
<span class="sd">        0x12345</span>
<span class="sd">        &gt;&gt;&gt; Concat(Variable(&quot;x&quot;, 8), Variable(&quot;y&quot;, 8))</span>
<span class="sd">        x :: y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;::&quot;</span>

<div class="viewcode-block" id="Concat.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Concat.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="Concat.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.Concat.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Concatenation when both operands are int.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">bin</span><span class="p">()</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">bin</span><span class="p">()[</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="bp">cls</span><span class="o">.</span><span class="n">output_width</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Concat</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Concat</span><span class="p">(</span><span class="n">Concat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Concat</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Concat</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Concat</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Extract</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Extract</span><span class="p">):</span>
            <span class="c1"># x[5:4] concat x[3:2] = x[5:2]</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Extract</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span></div></div>


<span class="c1"># Arithmetic operators</span>

<div class="viewcode-block" id="BvNeg"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvNeg">[docs]</a><span class="k">class</span> <span class="nc">BvNeg</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unary minus operation.</span>

<span class="sd">    It overrides the unary operator -. See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvNeg</span>
<span class="sd">        &gt;&gt;&gt; BvNeg(Constant(1, 8))</span>
<span class="sd">        0xff</span>
<span class="sd">        &gt;&gt;&gt; -Constant(1, 8)</span>
<span class="sd">        0xff</span>
<span class="sd">        &gt;&gt;&gt; BvNeg(Variable(&quot;x&quot;, 8))</span>
<span class="sd">        -x</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">unary_symbol</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>

<div class="viewcode-block" id="BvNeg.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvNeg.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvNeg.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvNeg.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Unary minus operation when the operand is int.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">((</span><span class="mi">2</span> <span class="o">**</span> <span class="n">width</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BvNeg</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div>
        <span class="c1"># # disabled (all op equal precedence)</span>
        <span class="c1"># elif isinstance(x, BvAdd):</span>
        <span class="c1">#     return BvAdd(BvNeg(x.args[0]), BvNeg(x.args[1]))</span>
        <span class="c1"># elif isinstance(x, (BvMul, BvDiv, BvMod)):</span>
        <span class="c1">#     return x.func(BvNeg(x.args[0]), x.args[1])</span>


<div class="viewcode-block" id="BvAdd"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvAdd">[docs]</a><span class="k">class</span> <span class="nc">BvAdd</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Modular addition operation.</span>

<span class="sd">    It overrides the operator + and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvAdd</span>
<span class="sd">        &gt;&gt;&gt; BvAdd(Constant(1, 8), Constant(2, 8))</span>
<span class="sd">        0x03</span>
<span class="sd">        &gt;&gt;&gt; BvAdd(Constant(1, 8), 2)</span>
<span class="sd">        0x03</span>
<span class="sd">        &gt;&gt;&gt; Constant(1, 8) + 2</span>
<span class="sd">        0x03</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) + Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x + y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>

<div class="viewcode-block" id="BvAdd.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvAdd.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvAdd.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvAdd.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvAdd.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvAdd.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Modular addition when both operands are integers.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">BvNeg</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BvSub</span><span class="p">):</span>  <span class="c1"># (x0 - x1=y) + y</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">BvSub</span><span class="p">):</span>  <span class="c1"># x + (y0 - y1=x)</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BvNeg</span><span class="p">):</span>  <span class="c1"># (-x) + y = y - x</span>
            <span class="k">return</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">BvNeg</span><span class="p">):</span>  <span class="c1"># x + (-y) = x - y</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_simplify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># simplify if x and BvNeg(x) appear in a flattened addition</span>
        <span class="n">compatible_terms</span> <span class="o">=</span> <span class="p">[</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">BvNeg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binary_symmetric_simplification</span><span class="p">(</span><span class="n">compatible_terms</span><span class="p">)</span></div>


<div class="viewcode-block" id="BvSub"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvSub">[docs]</a><span class="k">class</span> <span class="nc">BvSub</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Modular subtraction operation.</span>

<span class="sd">    It overrides the operator - and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvSub</span>
<span class="sd">        &gt;&gt;&gt; BvSub(Constant(1, 8), Constant(2, 8))</span>
<span class="sd">        0xff</span>
<span class="sd">        &gt;&gt;&gt; BvSub(Constant(1, 8), 2)</span>
<span class="sd">        0xff</span>
<span class="sd">        &gt;&gt;&gt; Constant(1, 8) - 2</span>
<span class="sd">        0xff</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) - Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x - y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>

<div class="viewcode-block" id="BvSub.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvSub.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvSub.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvSub.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvSub.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvSub.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Modular subtraction when both operands are integers.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">BvNeg</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">BvAdd</span><span class="p">):</span>  <span class="c1"># (x0 + x1) - y, y in [x0, x1]</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">BvAdd</span><span class="p">):</span>  <span class="c1"># x - (y0 + y1), x in [y0, y1]</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BvNeg</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BvNeg</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">BvNeg</span><span class="p">):</span>  <span class="c1"># x - (-y) = x + y</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="BvMul"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvMul">[docs]</a><span class="k">class</span> <span class="nc">BvMul</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Modular multiplication operation.</span>

<span class="sd">    It overrides the operator * and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvMul</span>
<span class="sd">        &gt;&gt;&gt; BvMul(Constant(4, 8), Constant(3, 8))</span>
<span class="sd">        0x0c</span>
<span class="sd">        &gt;&gt;&gt; BvMul(Constant(4, 8), 3)</span>
<span class="sd">        0x0c</span>
<span class="sd">        &gt;&gt;&gt; Constant(4, 8) * 3</span>
<span class="sd">        0x0c</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) * Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x * y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>

<div class="viewcode-block" id="BvMul.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvMul.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvMul.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvMul.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvMul.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvMul.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Modular multiplication when both operands are int.&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span></div></div>


<div class="viewcode-block" id="BvUdiv"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUdiv">[docs]</a><span class="k">class</span> <span class="nc">BvUdiv</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unsigned and truncated division operation.</span>

<span class="sd">    It overrides the operator / and provides Automatic Constant Conversion.</span>
<span class="sd">    See `PrimaryOperation` for more information.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvUdiv</span>
<span class="sd">        &gt;&gt;&gt; BvUdiv(Constant(0x0c, 8), Constant(3, 8))</span>
<span class="sd">        0x04</span>
<span class="sd">        &gt;&gt;&gt; BvUdiv(Constant(0x0c, 8), 3)</span>
<span class="sd">        0x04</span>
<span class="sd">        &gt;&gt;&gt; Constant(0x0c, 8) / 3</span>
<span class="sd">        0x04</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) / Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x / y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span>

<div class="viewcode-block" id="BvUdiv.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUdiv.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvUdiv.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUdiv.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvUdiv.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUdiv.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Division operation (truncated) when both operands are int.&quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">//</span> <span class="n">y</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">zero</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">one</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span></div></div>


<div class="viewcode-block" id="BvUrem"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUrem">[docs]</a><span class="k">class</span> <span class="nc">BvUrem</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unsigned remainder (modulus) operation.</span>

<span class="sd">    Usage:</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvUrem</span>
<span class="sd">        &gt;&gt;&gt; BvUrem(Constant(0x0d, 8), Constant(3, 8))</span>
<span class="sd">        0x01</span>
<span class="sd">        &gt;&gt;&gt; BvUrem(Constant(0x0d, 8), 3)</span>
<span class="sd">        0x01</span>
<span class="sd">        &gt;&gt;&gt; Constant(0x0d, 8) % 3</span>
<span class="sd">        0x01</span>
<span class="sd">        &gt;&gt;&gt; Variable(&quot;x&quot;, 8) % Variable(&quot;y&quot;, 8)</span>
<span class="sd">        x % y</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_simple</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">infix_symbol</span> <span class="o">=</span> <span class="s2">&quot;%&quot;</span>

<div class="viewcode-block" id="BvUrem.condition"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUrem.condition">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvUrem.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUrem.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvUrem.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvUrem.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">doit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Remainder operation when both operands are int.&quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span>

        <span class="n">zero</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">zero</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">doit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">zero</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="n">one</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">zero</span></div></div>


<div class="viewcode-block" id="BvIdentity"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvIdentity">[docs]</a><span class="k">class</span> <span class="nc">BvIdentity</span><span class="p">(</span><span class="n">PrimaryOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The identity operation.</span>

<span class="sd">    Return the same value when the input is constant and</span>
<span class="sd">    a `BvIdentity` object when the input is symbolic:</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import BvIdentity</span>
<span class="sd">        &gt;&gt;&gt; BvIdentity(Constant(0x1, 4))</span>
<span class="sd">        0x1</span>
<span class="sd">        &gt;&gt;&gt; BvIdentity(Variable(&quot;x&quot;, 8))</span>
<span class="sd">        Id(x)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># &#39;Identity&#39; is already taken by SymPy</span>

    <span class="n">arity</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">is_symmetric</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">alt_name</span> <span class="o">=</span> <span class="s2">&quot;Id&quot;</span>

<div class="viewcode-block" id="BvIdentity.output_width"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvIdentity.output_width">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">output_width</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="BvIdentity.eval"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.BvIdentity.eval">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span></div></div>


<span class="c1"># Shortcuts</span>

<div class="viewcode-block" id="zero_extend"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.zero_extend">[docs]</a><span class="k">def</span> <span class="nf">zero_extend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extend with zeroes preserving the unsigned value.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import zero_extend</span>
<span class="sd">        &gt;&gt;&gt; zero_extend(Constant(0x12, 8), 4)</span>
<span class="sd">        0x012</span>
<span class="sd">        &gt;&gt;&gt; zero_extend(Variable(&quot;x&quot;, 8), 4)</span>
<span class="sd">        0x0 :: x</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">Concat</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">+</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="repeat"><a class="viewcode-back" href="../../../cascada.bitvector.operation.html#cascada.bitvector.operation.repeat">[docs]</a><span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Concatenate a bit-vector with itself a given number of times.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import repeat</span>
<span class="sd">        &gt;&gt;&gt; repeat(Constant(0x1, 4), 4)</span>
<span class="sd">        0x1111</span>
<span class="sd">        &gt;&gt;&gt; repeat(Variable(&quot;x&quot;, 8), 4)</span>
<span class="sd">        x :: x :: x :: x</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">Concat</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

    <span class="k">assert</span> <span class="n">output</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">i</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span>

    <span class="k">return</span> <span class="n">output</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Adrián Ranea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>