<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cascada.linear.characteristic &mdash; CASCADA 1.0.rc0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> CASCADA
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">CASCADA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../adding_primitive.html">Adding a primitive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primitives_implemented.html">Primitives implemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cascada.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CASCADA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>cascada.linear.characteristic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cascada.linear.characteristic</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Manipulate non-symbolic linear characteristics.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">decimal</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">ssa</span> <span class="k">as</span> <span class="n">cascada_ssa</span>
<span class="kn">from</span> <span class="nn">cascada.linear</span> <span class="kn">import</span> <span class="n">chmodel</span> <span class="k">as</span> <span class="n">cascada_chmodel</span>
<span class="kn">from</span> <span class="nn">cascada.linear</span> <span class="kn">import</span> <span class="n">opmodel</span> <span class="k">as</span> <span class="n">cascada_opmodel</span>

<span class="kn">from</span> <span class="nn">cascada</span> <span class="kn">import</span> <span class="n">abstractproperty</span>


<span class="nb">zip</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">zip</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">EmpiricalWeightData</span> <span class="o">=</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">characteristic</span><span class="o">.</span><span class="n">EmpiricalWeightData</span>


<div class="viewcode-block" id="Characteristic"><a class="viewcode-back" href="../../../cascada.linear.characteristic.html#cascada.linear.characteristic.Characteristic">[docs]</a><span class="k">class</span> <span class="nc">Characteristic</span><span class="p">(</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">characteristic</span><span class="o">.</span><span class="n">Characteristic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent linear characteristics over bit-vector functions.</span>

<span class="sd">    Internally, this class is a subclass of</span>
<span class="sd">    `abstractproperty.characteristic.Characteristic`,</span>
<span class="sd">    where the `Property` is a `LinearMask` type.</span>

<span class="sd">    As mentioned in `abstractproperty.characteristic.Characteristic`,</span>
<span class="sd">    the characteristic probability is defined as the product of the propagation</span>
<span class="sd">    probability (absolute correlation) of the `LinearMask` pairs (linear approximations)</span>
<span class="sd">    :math:`(\Delta_{x_{i}} \mapsto \Delta_{x_{i+1}})` over :math:`f_i`.</span>
<span class="sd">    If :math:`f` has external variables, the characteristic probability</span>
<span class="sd">    approximates the absolute correlation of the input-output mask pair</span>
<span class="sd">    of the characteristic averaged over the set of all values of the external variables.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import RotateLeft, RotateRight</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.mask import LinearMask, LinearMask</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.chmodel import ChModel</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.characteristic import Characteristic</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">        &gt;&gt;&gt; Speck32_KS.set_num_rounds(2)</span>
<span class="sd">        &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, LinearMask, [&quot;mk0&quot;, &quot;mk1&quot;, &quot;mk2&quot;])</span>
<span class="sd">        &gt;&gt;&gt; zm = core.Constant(0, width=16)</span>
<span class="sd">        &gt;&gt;&gt; mk0 = RotateLeft(Constant(1, width=16), 8)  # mk0 &gt;&gt;&gt; 7 == 0b0···010</span>
<span class="sd">        &gt;&gt;&gt; mx5 = RotateRight(mk0, 7)  # ~ mk0 &gt;&gt;&gt; 7 == 0b0···010</span>
<span class="sd">        &gt;&gt;&gt; mx3__1 = RotateRight(Constant(1, width=16), 1)  # mx3__1 &lt;&lt;&lt; 2 == 0b0···010</span>
<span class="sd">        &gt;&gt;&gt; mx3_out = core.Constant(0x8002, 16)</span>
<span class="sd">        &gt;&gt;&gt; assign_outmask_list = [zm, zm, zm, zm, mx5, mx3__1, mx5, mx5, zm, mx3_out, mx5]</span>
<span class="sd">        &gt;&gt;&gt; ch = Characteristic([mk0, zm, zm], [zm, mx3_out, mx5], assign_outmask_list, ch_model)</span>
<span class="sd">        &gt;&gt;&gt; ch  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        Characteristic(ch_weight=1, assignment_weights=[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],</span>
<span class="sd">            input_mask=[0x0100, 0x0000, 0x0000], output_mask=[0x0000, 0x8002, 0x0002],</span>
<span class="sd">            assign_outmask_list=[0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x8000, 0x0002, 0x0002, 0x0000, 0x8002, 0x0002])</span>
<span class="sd">        &gt;&gt;&gt; list(zip(ch.assignment_weights, ch.tuple_assign_outmask2op_model))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [(Decimal(&#39;0&#39;), (LinearMask(0x0000), LinearModelFreeBranch(LinearMask(0x0000)))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0000), LinearModelFreeBranch(LinearMask(0x0000)))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0000), LinearModelBvAdd([LinearMask(0x0000), LinearMask(0x0000)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0000), LinearModelBvXor([LinearMask(0x0000), LinearMask(0x0000)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0002), LinearModelFreeBranch(LinearMask(0x0000)))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x8000), LinearModelFreeBranch(LinearMask(0x0000)))),</span>
<span class="sd">         (Decimal(&#39;1&#39;), (LinearMask(0x0002), LinearModelBvAdd([LinearMask(0x0002), LinearMask(0x0002)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0002), LinearModelBvXor([LinearMask(0x0002), LinearMask(0x0002)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0000), LinearModelId(LinearMask(0x0000)))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x8002), LinearModelId(LinearMask(0x8002)))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0002), LinearModelId(LinearMask(0x0002))))]</span>

<span class="sd">    Attributes:</span>
<span class="sd">        input_mask: a list of `LinearMask` objects containing</span>
<span class="sd">            the (constant) input mask (alias of</span>
<span class="sd">            `abstractproperty.characteristic.Characteristic.input_prop`).</span>
<span class="sd">        output_mask: a list of `LinearMask` objects containing</span>
<span class="sd">            the (constant) output mask (alias of</span>
<span class="sd">            `abstractproperty.characteristic.Characteristic.output_prop`).</span>
<span class="sd">        external_masks: a list containing the (constant) `LinearMask` of</span>
<span class="sd">            the external variables of the function (alias of</span>
<span class="sd">            `abstractproperty.characteristic.Characteristic.external_props`).</span>
<span class="sd">        tuple_assign_outmask2op_model:  a tuple where each element is a pair</span>
<span class="sd">            containing: (1) the output (constant) `LinearMask` :math:`\Delta_{x_{i+1}}`</span>
<span class="sd">            of the non-trivial assignment  :math:`x_{i+1} \leftarrow f_i(x_i)`</span>
<span class="sd">            and (2) the `linear.opmodel.OpModel` of this assignment with</span>
<span class="sd">            a (constant) input `LinearMask` :math:`\Delta_{x_{i}}` (alias of</span>
<span class="sd">            `abstractproperty.characteristic.Characteristic.tuple_assign_outprop2op_model`).</span>
<span class="sd">        free_masks: a list of (symbolic) `LinearMask` objects of</span>
<span class="sd">            the `Characteristic.ch_model`, whose values do not affect the characteristic,</span>
<span class="sd">            and were replaced by constant masks in `input_mask`,</span>
<span class="sd">            `output_mask`, `external_masks` or `tuple_assign_outmask2op_model`</span>
<span class="sd">            (alias of `abstractproperty.characteristic.Characteristic.free_props`).</span>
<span class="sd">        var_mask2ct_mask: a `collections.OrderedDict` mapping each</span>
<span class="sd">            symbolic `LinearMask` in the trail to its constant mask (alias of</span>
<span class="sd">            `abstractproperty.characteristic.Characteristic.var_prop2ct_prop`).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_prop_label</span> <span class="o">=</span> <span class="s2">&quot;mask&quot;</span>  <span class="c1"># for str and vrepr</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_prop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">output_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_prop</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">external_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_props</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tuple_assign_outmask2op_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tuple_assign_outprop2op_model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_masks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_props</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">var_mask2ct_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_prop2ct_prop</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_mask</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">,</span> <span class="n">assign_outmask_list</span><span class="p">,</span>
                 <span class="n">ch_model</span><span class="p">,</span> <span class="n">external_masks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">free_masks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">empirical_ch_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empirical_data_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_valid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">input_prop</span><span class="o">=</span><span class="n">input_mask</span><span class="p">,</span> <span class="n">output_prop</span><span class="o">=</span><span class="n">output_mask</span><span class="p">,</span> <span class="n">assign_outprop_list</span><span class="o">=</span><span class="n">assign_outmask_list</span><span class="p">,</span>
            <span class="n">ch_model</span><span class="o">=</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">external_props</span><span class="o">=</span><span class="n">external_masks</span><span class="p">,</span> <span class="n">free_props</span><span class="o">=</span><span class="n">free_masks</span><span class="p">,</span>
            <span class="n">empirical_ch_weight</span><span class="o">=</span><span class="n">empirical_ch_weight</span><span class="p">,</span> <span class="n">empirical_data_list</span><span class="o">=</span><span class="n">empirical_data_list</span><span class="p">,</span> <span class="n">is_valid</span><span class="o">=</span><span class="n">is_valid</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Characteristic.vrepr"><a class="viewcode-back" href="../../../cascada.linear.characteristic.html#cascada.linear.characteristic.Characteristic.vrepr">[docs]</a>    <span class="k">def</span> <span class="nf">vrepr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_external_masks</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an executable string representation.</span>

<span class="sd">        See also `abstractproperty.characteristic.Characteristic.vrepr`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.operation import RotateLeft, RotateRight</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.chmodel import ChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, LinearMask, [&quot;mk0&quot;, &quot;mk1&quot;, &quot;mk2&quot;])</span>
<span class="sd">            &gt;&gt;&gt; zm = core.Constant(0, width=16)</span>
<span class="sd">            &gt;&gt;&gt; mk0 = RotateLeft(Constant(1, width=16), 8)  # mk0 &gt;&gt;&gt; 7 == 0b0···010</span>
<span class="sd">            &gt;&gt;&gt; mx5 = RotateRight(mk0, 7)  # ~ mk0 &gt;&gt;&gt; 7 == 0b0···010</span>
<span class="sd">            &gt;&gt;&gt; mx3__1 = RotateRight(Constant(1, width=16), 1)  # mx3__1 &lt;&lt;&lt; 2 == 0b0···010</span>
<span class="sd">            &gt;&gt;&gt; mx3_out = core.Constant(0x8002, 16)</span>
<span class="sd">            &gt;&gt;&gt; assign_outmask_list = [zm, zm, zm, zm, mx5, mx3__1, mx5, mx5, zm, mx3_out, mx5]</span>
<span class="sd">            &gt;&gt;&gt; ch = Characteristic([mk0, zm, zm], [zm, mx3_out, mx5], assign_outmask_list, ch_model)</span>
<span class="sd">            &gt;&gt;&gt; ch.vrepr()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            &quot;Characteristic(input_mask=[Constant(0x0100, width=16), Constant(0x0000, width=16), Constant(0x0000, width=16)],</span>
<span class="sd">                output_mask=[Constant(0x0000, width=16), Constant(0x8002, width=16), Constant(0x0002, width=16)],</span>
<span class="sd">                assign_outmask_list=[Constant(0x0000, width=16), Constant(0x0000, width=16), Constant(0x0000, width=16),</span>
<span class="sd">                    Constant(0x0000, width=16), Constant(0x0002, width=16), Constant(0x8000, width=16), Constant(0x0002, width=16),</span>
<span class="sd">                    Constant(0x0002, width=16), Constant(0x0000, width=16), Constant(0x8002, width=16), Constant(0x0002, width=16)],</span>
<span class="sd">                ch_model=ChModel(func=SpeckKeySchedule.set_num_rounds_and_return(2), mask_type=LinearMask,</span>
<span class="sd">                    input_mask_names=[&#39;mk0&#39;, &#39;mk1&#39;, &#39;mk2&#39;], prefix=&#39;mx&#39;))&quot;</span>
<span class="sd">            &gt;&gt;&gt; ch.srepr()</span>
<span class="sd">            &#39;Ch(w=1, id=0100 0000 0000, od=0000 8002 0002)&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">vrepr</span><span class="p">(</span><span class="n">ignore_external_masks</span><span class="p">)</span></div>

<div class="viewcode-block" id="Characteristic.split"><a class="viewcode-back" href="../../../cascada.linear.characteristic.html#cascada.linear.characteristic.Characteristic.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_separators</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Split into multiple `Characteristic` objects given the list of mask separators.</span>

<span class="sd">        See also `abstractproperty.characteristic.Characteristic.split`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.operation import RotateLeft, RotateRight</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.chmodel import ChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.characteristic import Characteristic</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, LinearMask, [&quot;mk0&quot;, &quot;mk1&quot;, &quot;mk2&quot;])</span>
<span class="sd">            &gt;&gt;&gt; tuple(ch_model.ssa.assignments.items())  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            ((mx0, mk1 &gt;&gt;&gt; 7), (mk2__0, Id(mk2)), (mk2__1, Id(mk2)), (mk2__2, Id(mk2)),</span>
<span class="sd">                (mx1, mx0 + mk2__0), (mx2, mk2__1 &lt;&lt;&lt; 2), (mx3, mx2 ^ mx1),</span>
<span class="sd">            (mx4, mk0 &gt;&gt;&gt; 7), (mx3__0, Id(mx3)), (mx3__1, Id(mx3)), (mx3__2, Id(mx3)),</span>
<span class="sd">                (mx5, mx4 + mx3__0), (mx6, mx5 ^ 0x0001), (mx7, mx3__1 &lt;&lt;&lt; 2), (mx8, mx7 ^ mx6),</span>
<span class="sd">            (mk2_out, Id(mk2__2)), (mx3_out, Id(mx3__2)), (mx8_out, Id(mx8)))</span>
<span class="sd">            &gt;&gt;&gt; mask_separators = [ (LinearMask(Variable(&quot;mx2&quot;, width=16)), LinearMask(Variable(&quot;mx3&quot;, width=16))), ]</span>
<span class="sd">            &gt;&gt;&gt; zm = core.Constant(0, width=16)</span>
<span class="sd">            &gt;&gt;&gt; mk0 = RotateLeft(Constant(1, width=16), 8)  # mk0 &gt;&gt;&gt; 7 == 0b0···010</span>
<span class="sd">            &gt;&gt;&gt; mx5 = RotateRight(mk0, 7)  # ~ mk0 &gt;&gt;&gt; 7 == 0b0···010</span>
<span class="sd">            &gt;&gt;&gt; mx3__1 = RotateRight(Constant(1, width=16), 1)  # mx3__1 &lt;&lt;&lt; 2 == 0b0···010</span>
<span class="sd">            &gt;&gt;&gt; mx3_out = core.Constant(0x8002, 16)</span>
<span class="sd">            &gt;&gt;&gt; assign_outmask_list = [zm, zm, zm, zm, mx5, mx3__1, mx5, mx5, zm, mx3_out, mx5]</span>
<span class="sd">            &gt;&gt;&gt; ch = Characteristic([mk0, zm, zm], [zm, mx3_out, mx5], assign_outmask_list, ch_model)</span>
<span class="sd">            &gt;&gt;&gt; for ch in ch.split(mask_separators): print(ch)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            Characteristic(ch_weight=0, assignment_weights=[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">                input_mask=[0x0100, 0x0000, 0x0000],</span>
<span class="sd">                output_mask=[0x0100, 0x0000, 0x0000],</span>
<span class="sd">                assign_outmask_list=[0x0000, 0x0000, 0x0000, 0x0000, 0x0100, 0x0000, 0x0000])</span>
<span class="sd">            Characteristic(ch_weight=1, assignment_weights=[0, 0, 1, 0, 0, 0, 0],</span>
<span class="sd">                input_mask=[0x0100, 0x0000, 0x0000],</span>
<span class="sd">                output_mask=[0x0000, 0x8002, 0x0002],</span>
<span class="sd">                assign_outmask_list=[0x0002, 0x8000, 0x0002, 0x0002, 0x0000, 0x8002, 0x0002])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">mask_separators</span><span class="p">)</span></div>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_sample_outprop_opmodel</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">mask_type</span><span class="p">,</span> <span class="n">ct_op_model</span><span class="p">,</span> <span class="n">outmask_width</span><span class="p">,</span> <span class="n">get_random_bv</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">outmask_width</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;random does not support characteristics with masks with more than 8 bits&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct_op_model</span><span class="p">,</span> <span class="n">cascada_opmodel</span><span class="o">.</span><span class="n">LinearModelBvXor</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ct_op_model</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ct_op_model</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ct_op_model</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_sample_outprop_opmodel</span><span class="p">(</span><span class="n">mask_type</span><span class="p">,</span> <span class="n">ct_op_model</span><span class="p">,</span> <span class="n">outmask_width</span><span class="p">,</span> <span class="n">get_random_bv</span><span class="p">)</span>
        <span class="c1"># elif isinstance(ct_op_model, cascada_opmodel.LinearModelBvAdd) and outmask_width &gt;= 8:</span>
        <span class="c1">#     # LinearModelBvAdd for more than 8-bit too slow</span>
        <span class="c1">#     from cascada.smt.types import environment, bv2pysmt, pysmt2bv</span>
        <span class="c1">#     var_prop = mask_type(core.Variable(&quot;output_mask&quot;, outmask_width))</span>
        <span class="c1">#     with context.Simplification(False), context.Validation(False):</span>
        <span class="c1">#         # explicit=True to ensure only one variable in pysmt_model</span>
        <span class="c1">#         bv_expr = ct_op_model.validity_constraint(var_prop, explicit=True)</span>
        <span class="c1">#         env = environment.reset_env()</span>
        <span class="c1">#         pysmt_expr = bv2pysmt(bv_expr, boolean=True, env=env)</span>
        <span class="c1">#         pysmt_model = env.factory.get_model(pysmt_expr)</span>
        <span class="c1">#         if pysmt_model is None:</span>
        <span class="c1">#             return None</span>
        <span class="c1">#         for _, pysmt_val in pysmt_model:</span>
        <span class="c1">#             bv_val = pysmt2bv(pysmt_val)</span>
        <span class="c1">#             break</span>
        <span class="c1">#     return mask_type(bv_val)</span>

<div class="viewcode-block" id="Characteristic.random"><a class="viewcode-back" href="../../../cascada.linear.characteristic.html#cascada.linear.characteristic.Characteristic.random">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ch_model</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">external_masks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a random `Characteristic` with given `linear.chmodel.ChModel`.</span>

<span class="sd">        See also `abstractproperty.characteristic.Characteristic.random`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.chmodel import ChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.characteristic import Characteristic</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.ssa import BvFunction</span>
<span class="sd">            &gt;&gt;&gt; class MyFoo(BvFunction):</span>
<span class="sd">            ...     input_widths, output_widths = [4, 4], [4, 4]</span>
<span class="sd">            ...     @classmethod</span>
<span class="sd">            ...     def eval(cls, a, b):  return a + b, a</span>
<span class="sd">            &gt;&gt;&gt; ch_model = ChModel(MyFoo, LinearMask, [&quot;ma&quot;, &quot;mb&quot;])</span>
<span class="sd">            &gt;&gt;&gt; Characteristic.random(ch_model, 0)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            Characteristic(ch_weight=2, assignment_weights=[0, 2, 0, 0],</span>
<span class="sd">                input_mask=[0x2, 0x6], output_mask=[0x4, 0x5],</span>
<span class="sd">                assign_outmask_list=[0x7, 0x4, 0x4, 0x5])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">external_masks</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_num_right_inputs2weight</span><span class="p">(</span><span class="n">num_right_inputs</span><span class="p">,</span> <span class="n">num_input_samples</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_right_inputs</span> <span class="o">==</span> <span class="n">num_input_samples</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inner_pr</span> <span class="o">=</span> <span class="n">num_right_inputs</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="n">num_input_samples</span><span class="p">)</span>
            <span class="n">correlation</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">inner_pr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">copy_abs</span><span class="p">()</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="o">-</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">log2_decimal</span><span class="p">(</span><span class="n">correlation</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">weight</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">_get_empirical_ch_weights_C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_input_samples</span><span class="p">,</span> <span class="n">num_external_samples</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">num_parallel_processes</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">get_sampled_inputs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of empirical weights (one for each ``num_external_samples``)</span>
<span class="sd">        by compiling and executing C code.</span>

<span class="sd">        See also `differential.characteristic.Characteristic._get_empirical_ch_weights_C`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">uuid</span>
        <span class="kn">from</span> <span class="nn">cascada.bitvector.printing</span> <span class="kn">import</span> <span class="n">BvCCodePrinter</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">verbose</span> <span class="ow">and</span> <span class="n">get_sampled_inputs</span><span class="p">)</span>

        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">num_input_samples</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_masks</span><span class="p">:</span>
            <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">num_external_samples</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_masks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">num_external_samples</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">num_input_samples</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;max num_input_samples supported is 2**64 - 1&quot;</span><span class="p">)</span>

        <span class="n">width2C_type</span> <span class="o">=</span> <span class="n">BvCCodePrinter</span><span class="o">.</span><span class="n">_width2C_type</span>
        <span class="n">get_and_mask_C_code</span> <span class="o">=</span> <span class="n">BvCCodePrinter</span><span class="o">.</span><span class="n">_get_and_mask_C_code</span>

        <span class="n">ctype_num_right_inputs</span> <span class="o">=</span> <span class="n">width2C_type</span><span class="p">(</span><span class="n">num_input_samples</span><span class="o">.</span><span class="n">bit_length</span><span class="p">())</span>

        <span class="c1"># 1 - Build the C code</span>

        <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ctype_num_right_inputs</span><span class="si">}</span><span class="s2"> get_num_right_inputs(uint64_t seed);&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="p">,</span> <span class="s2">&quot;_unwrapped_ch_model&quot;</span><span class="p">):</span>
            <span class="c1"># avoid gcc error due to huge line statements</span>
            <span class="n">ssa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">_unwrapped_ch_model</span><span class="o">.</span><span class="n">ssa</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ssa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">ssa</span>
        <span class="n">eval_ssa_code_function_name</span> <span class="o">=</span> <span class="s2">&quot;eval_ssa&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">eval_ssa_code_body</span> <span class="o">=</span> <span class="n">ssa</span><span class="o">.</span><span class="n">get_C_code</span><span class="p">(</span><span class="n">eval_ssa_code_function_name</span><span class="p">)</span>  <span class="c1"># ignore header</span>

        <span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
        <span class="kn">from</span> <span class="nn">cascada.differential</span> <span class="kn">import</span> <span class="n">characteristic</span> <span class="k">as</span> <span class="n">diff_ch_module</span>
        <span class="n">mt19937_filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">diff_ch_module</span><span class="o">.</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span> <span class="o">/</span> <span class="s2">&quot;mt19937.c&quot;</span>

        <span class="k">def</span> <span class="nf">rand</span><span class="p">(</span><span class="n">my_width</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">my_width</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">rand_str</span> <span class="o">=</span> <span class="s2">&quot;genrand64_int1&quot;</span>
            <span class="k">elif</span> <span class="n">my_width</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">rand_str</span> <span class="o">=</span> <span class="s2">&quot;genrand64_int8&quot;</span>
            <span class="k">elif</span> <span class="n">my_width</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">rand_str</span> <span class="o">=</span> <span class="s2">&quot;genrand64_int16&quot;</span>
            <span class="k">elif</span> <span class="n">my_width</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">:</span>
                <span class="n">rand_str</span> <span class="o">=</span> <span class="s2">&quot;genrand64_int32&quot;</span>
            <span class="k">elif</span> <span class="n">my_width</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">:</span>
                <span class="n">rand_str</span> <span class="o">=</span> <span class="s2">&quot;genrand64_int64&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;random bit-vectors with more than 64 bits are not supported&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">rand_str</span><span class="si">}</span><span class="s2">()</span><span class="si">{</span><span class="n">get_and_mask_C_code</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># stdint already in eval_ssa and in mt19937</span>
        <span class="n">body</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;#include &quot;</span><span class="si">{</span><span class="n">mt19937_filename</span><span class="si">}</span><span class="s1">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">eval_ssa_code_body</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">ctype_num_right_inputs</span><span class="si">}</span><span class="s2"> get_num_right_inputs(uint64_t seed)</span><span class="se">{{</span><span class="s2">&quot;</span>

        <span class="n">to_sample_all_iv</span> <span class="o">=</span> <span class="n">num_input_samples</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_mask</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_masks</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">to_sample_all_iv</span><span class="p">:</span>
            <span class="n">body</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">init_genrand64(seed);&quot;</span>

        <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="si">{</span><span class="n">ctype_num_right_inputs</span><span class="si">}</span><span class="s2"> num_right_inputs = 0U;&quot;</span>

        <span class="c1"># to_sample_all_ev cannot be used since get_num_right_inputs only returns 1 EW</span>
        <span class="k">if</span> <span class="n">ssa</span><span class="o">.</span><span class="n">external_vars</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">external_vars</span><span class="p">)):</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">ssa</span><span class="o">.</span><span class="n">external_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="si">{</span><span class="n">width2C_type</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">rand</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2">;&quot;</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">printf(&quot;</span><span class="se">\\</span><span class="s1">nexternal_vars[%u] = %x&quot;, </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">U, </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span><span class="si">}</span><span class="s1">);&#39;</span>
            <span class="n">ev_args</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ssa</span><span class="o">.</span><span class="n">external_vars</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ev_args</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># start for</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">to_sample_all_iv</span><span class="p">:</span>
            <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">for (</span><span class="si">{</span><span class="n">ctype_num_right_inputs</span><span class="si">}</span><span class="s2"> i = 0U; i &lt; </span><span class="si">{</span><span class="n">num_input_samples</span><span class="si">}</span><span class="s2">U; ++i) </span><span class="se">{{</span><span class="s2">&quot;</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">)):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">to_sample_all_iv</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span>
                <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t\t</span><span class="s2">for (</span><span class="si">{</span><span class="n">width2C_type</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">width</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> = 0U; </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2"> &lt; </span><span class="si">{</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2">U; ++</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">) </span><span class="se">{{</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t\t</span><span class="si">{</span><span class="n">width2C_type</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">rand</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2">;&quot;</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t\t</span><span class="s1">printf(&quot;</span><span class="se">\\</span><span class="s1">ninput sample i=%u | input_vars[%u] = %x&quot;, i, </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">U, </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span><span class="si">}</span><span class="s1">);&#39;</span>
        <span class="k">if</span> <span class="n">get_sampled_inputs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">)):</span>
                <span class="n">aux_prefix</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="n">aux_suffix</span> <span class="o">=</span> <span class="s2">&quot;],&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t\t</span><span class="s1">printf(&quot;</span><span class="si">{</span><span class="n">aux_prefix</span><span class="si">}</span><span class="s1">0x%x,</span><span class="si">{</span><span class="n">aux_suffix</span><span class="si">}</span><span class="s1">&quot;, </span><span class="si">{</span><span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span><span class="si">}</span><span class="s1">);&#39;</span>
        <span class="n">iv_args</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">)):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="n">ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># var passed by reference later (no need to declare them as pointers)</span>
            <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t\t</span><span class="si">{</span><span class="n">width2C_type</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">var</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span><span class="si">}</span><span class="s2">;&quot;</span>
        <span class="n">ov_args</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;&amp;&quot;</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">])</span>

        <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t\t</span><span class="si">{</span><span class="n">eval_ssa_code_function_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">iv_args</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ev_args</span><span class="si">}{</span><span class="n">ov_args</span><span class="si">}</span><span class="s2">);&quot;</span>

        <span class="c1"># parity computation</span>

        <span class="k">def</span> <span class="nf">parity_func</span><span class="p">(</span><span class="n">my_width</span><span class="p">):</span>
            <span class="c1"># __builtin_parity(x) returns the parity of x, the number of 1-bits in x modulo 2.</span>
            <span class="c1"># __builtin_parity(a &amp; b) returns &lt;a, b&gt;</span>
            <span class="k">if</span> <span class="n">my_width</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;__builtin_parity&quot;</span>
            <span class="k">elif</span> <span class="n">my_width</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;__builtin_parityl&quot;</span>
            <span class="k">elif</span> <span class="n">my_width</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;__builtin_parityll&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;parity of bit-vectors with more than 64 bits is not supported&quot;</span><span class="p">)</span>

        <span class="n">parity_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">)):</span>
            <span class="n">parity_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">)):</span>
            <span class="n">parity_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">output_vars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

        <span class="n">parity_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parity_in</span> <span class="ow">in</span> <span class="n">parity_inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parity_in</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>  <span class="c1"># i.e., mask = 0</span>
                <span class="k">assert</span> <span class="n">parity_in</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">parity_in</span><span class="o">.</span><span class="n">width</span>
                <span class="n">parity_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parity_func</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2">( (</span><span class="si">{</span><span class="n">width2C_type</span><span class="p">(</span><span class="n">width</span><span class="p">)</span><span class="si">}</span><span class="s2">)(</span><span class="si">{</span><span class="n">parity_in</span><span class="o">.</span><span class="n">crepr</span><span class="p">()</span><span class="si">}</span><span class="s2">) )&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parity_outputs</span><span class="p">:</span>
            <span class="n">parity_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;0U&quot;</span><span class="p">)</span>

        <span class="c1"># sum_parity = &lt;a,x&gt; ^ &lt;f(x), b&gt;</span>
        <span class="n">sum_parity_c</span> <span class="o">=</span> <span class="s2">&quot; ^ &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parity_outputs</span><span class="p">)</span>

        <span class="c1"># &quot;1 ^ sum_parity&quot; is equivalent to &quot;if (sum_parity == 0) num_right_inputs++&quot;</span>
        <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t\t</span><span class="s2">num_right_inputs += 1U ^ (</span><span class="si">{</span><span class="n">width2C_type</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">)(</span><span class="si">{</span><span class="n">sum_parity_c</span><span class="si">}</span><span class="s2">);&quot;</span>

        <span class="c1"># lhs = self.input_mask[0].apply(ssa.input_vars[0])</span>
        <span class="c1"># for i in range(1, len(ssa.input_vars)):</span>
        <span class="c1">#     lhs ^= self.input_mask[i].apply(ssa.input_vars[i])</span>
        <span class="c1">#</span>
        <span class="c1"># rhs = self.output_mask[0].apply(ssa.output_vars[0])</span>
        <span class="c1"># for i in range(1, len(ssa.output_vars)):</span>
        <span class="c1">#     rhs ^= self.output_mask[i].apply(ssa.output_vars[i])</span>
        <span class="c1">#</span>
        <span class="c1"># if verbose:</span>
        <span class="c1">#     for i in range(len(ssa.output_vars)):</span>
        <span class="c1">#         var = ssa.output_vars[i]</span>
        <span class="c1">#         body += f&#39;\n\t\tprintf(&quot;\\n                 | output_vars[%u] = %x&quot;, {i}U, {var.crepr()});&#39;</span>
        <span class="c1">#     body += f&#39;\n\t\tprintf(&quot;\\n                 | lhs[%u] = %x&quot;, {i}U, {lhs.crepr()});&#39;</span>
        <span class="c1">#     body += f&#39;\n\t\tprintf(&quot;\\n                 | rhs[%u] = %x&quot;, {i}U, {rhs.crepr()});&#39;</span>
        <span class="c1">#</span>
        <span class="c1"># if_condition = f&quot; ({width2C_type(lhs.width)})({lhs.crepr()}) == &quot; \</span>
        <span class="c1">#                f&quot; ({width2C_type(rhs.width)})({rhs.crepr()})&quot;</span>
        <span class="c1"># body += f&quot;\n\t\tif ( {if_condition} ){{&quot;</span>
        <span class="c1"># body += &quot;\n\t\t\tnum_right_inputs += 1U;&quot;</span>
        <span class="c1"># body += &quot;\n\t\t}&quot;</span>

        <span class="k">if</span> <span class="n">to_sample_all_iv</span><span class="p">:</span>
            <span class="n">body</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">input_vars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">body</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">}&quot;</span>

        <span class="c1"># end for</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">body</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">printf(&quot;</span><span class="se">\\</span><span class="s1">nnum_right_inputs = %u</span><span class="se">\\</span><span class="s1">n&quot;, num_right_inputs);&#39;</span>

        <span class="n">body</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">return num_right_inputs;</span><span class="se">\n</span><span class="s2">}&quot;</span>

        <span class="c1"># 2 - Run the C code</span>

        <span class="k">if</span> <span class="n">num_parallel_processes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">num_external_samples</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">pymod</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">cascada_ssa</span><span class="o">.</span><span class="n">_compile_C_code</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

            <span class="n">PRNG</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>
            <span class="n">PRNG</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

            <span class="n">aux_empirical_weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_external_samples</span><span class="p">)):</span>  <span class="c1"># num_external_samples can be 0</span>
                <span class="n">num_right_inputs</span> <span class="o">=</span> <span class="n">pymod</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">get_num_right_inputs</span><span class="p">(</span><span class="n">PRNG</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">))</span>
                <span class="n">aux_empirical_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_num_right_inputs2weight</span><span class="p">(</span><span class="n">num_right_inputs</span><span class="p">,</span> <span class="n">num_input_samples</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lib_path</span><span class="p">,</span> <span class="n">module_name</span><span class="p">,</span> <span class="n">tmpdir</span> <span class="o">=</span> <span class="n">cascada_ssa</span><span class="o">.</span><span class="n">_compile_C_code</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">return_unloaded</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

            <span class="n">num_parallel_processes</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_parallel_processes</span><span class="p">,</span> <span class="n">num_external_samples</span><span class="p">)</span>

            <span class="n">PRNG</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>
            <span class="n">PRNG</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="n">external_seeds</span> <span class="o">=</span> <span class="p">[</span><span class="n">PRNG</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="mi">64</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_external_samples</span><span class="p">)]</span>

            <span class="n">chunk</span> <span class="o">=</span> <span class="n">num_external_samples</span> <span class="o">//</span> <span class="n">num_parallel_processes</span>
            <span class="k">if</span> <span class="n">num_external_samples</span> <span class="o">%</span> <span class="n">num_parallel_processes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">extra_chunk</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">extra_chunk</span> <span class="o">=</span> <span class="n">num_external_samples</span> <span class="o">%</span> <span class="n">num_parallel_processes</span>
            <span class="k">assert</span> <span class="n">chunk</span><span class="o">*</span><span class="p">(</span><span class="n">num_parallel_processes</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">chunk</span> <span class="o">+</span> <span class="n">extra_chunk</span> <span class="o">==</span> <span class="n">num_external_samples</span>

            <span class="n">aux_empirical_weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">with</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">num_parallel_processes</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">async_results</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_parallel_processes</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">ar_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">async_results</span><span class="p">)):</span>
                    <span class="n">async_results</span><span class="p">[</span><span class="n">ar_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span>
                        <span class="n">diff_ch_module</span><span class="o">.</span><span class="n">_run_C_code_get_num_right_inputs</span><span class="p">,</span>
                        <span class="p">(</span>
                            <span class="n">external_seeds</span><span class="p">[</span><span class="n">ar_index</span><span class="o">*</span><span class="n">chunk</span><span class="p">],</span>
                            <span class="n">module_name</span><span class="p">,</span>
                            <span class="n">lib_path</span><span class="p">,</span>
                            <span class="n">chunk</span><span class="o">+</span><span class="n">extra_chunk</span> <span class="k">if</span> <span class="n">ar_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">async_results</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">chunk</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">pool</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># blocking call</span>
                <span class="k">for</span> <span class="n">ar_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">async_results</span><span class="p">)):</span>
                    <span class="c1"># type(process_list[process_index]) == AsyncResult</span>
                    <span class="c1"># and AsyncResult.get() blocks until result obtained</span>
                    <span class="n">list_num_right_inputs</span> <span class="o">=</span> <span class="n">async_results</span><span class="p">[</span><span class="n">ar_index</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                    <span class="n">aux_empirical_weights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_right_inputs2weight</span><span class="p">(</span><span class="n">nri</span><span class="p">,</span> <span class="n">num_input_samples</span><span class="p">)</span> <span class="k">for</span> <span class="n">nri</span> <span class="ow">in</span> <span class="n">list_num_right_inputs</span><span class="p">]</span>
                    <span class="p">)</span>

            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">aux_empirical_weights</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_external_samples</span>

        <span class="n">tmpdir</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">aux_empirical_weights</span>

    <span class="k">def</span> <span class="nf">_get_empirical_ch_weights_Python</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_input_samples</span><span class="p">,</span> <span class="n">num_external_samples</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">list_input_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of empirical weights (one for each ``num_external_samples``).&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">num_input_samples</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_masks</span><span class="p">:</span>
            <span class="k">assert</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">num_external_samples</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_masks</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">num_external_samples</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="n">PRNG</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>
        <span class="n">PRNG</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_random_bv</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">PRNG</span><span class="o">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">width</span><span class="p">),</span> <span class="n">width</span><span class="p">)</span>

        <span class="n">aux_empirical_weights</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">with</span> <span class="n">context</span><span class="o">.</span><span class="n">Simplification</span><span class="p">(</span><span class="kc">False</span><span class="p">),</span> <span class="n">context</span><span class="o">.</span><span class="n">Cache</span><span class="p">(</span><span class="kc">False</span><span class="p">):</span>
            <span class="n">input_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_mask</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">list_input_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_input_samples</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_input_samples</span>
                <span class="k">def</span> <span class="nf">get_next_input</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">list_input_samples</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_mask</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">p_i</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">p_i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">input_widths</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">num_input_samples</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">sum</span><span class="p">(</span><span class="n">input_widths</span><span class="p">):</span>
                <span class="c1"># input_samples == whole input space</span>
                <span class="k">def</span> <span class="nf">get_next_input</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">input_sample</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">input_widths</span><span class="p">]):</span>
                        <span class="k">yield</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">p_i</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">p_i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">input_sample</span><span class="p">,</span> <span class="n">input_widths</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">get_next_input</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_input_samples</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="p">[</span><span class="n">get_random_bv</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="k">for</span> <span class="n">mask</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_mask</span><span class="p">]</span>

            <span class="n">found_external_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">external_masks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">found_external_vars</span><span class="p">:</span>
                <span class="n">external_widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_masks</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">num_external_samples</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">sum</span><span class="p">(</span><span class="n">external_widths</span><span class="p">):</span>
                    <span class="c1"># external_samples == whole external space</span>
                    <span class="n">external_space</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">external_widths</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">external_space</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_external_samples</span><span class="p">)</span>  <span class="c1"># num_external_samples &gt; 0</span>

                <span class="k">def</span> <span class="nf">get_next_ssa_external_fixed</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">external_sample</span> <span class="ow">in</span> <span class="n">external_space</span><span class="p">:</span>
                        <span class="n">ssa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">ssa</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">v2c</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">external_sample</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ssa</span><span class="o">.</span><span class="n">external_vars</span><span class="p">:</span>
                                <span class="n">v2c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_random_bv</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i_v</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ssa</span><span class="o">.</span><span class="n">external_vars</span><span class="p">):</span>
                                <span class="n">v2c</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">external_sample</span><span class="p">[</span><span class="n">i_v</span><span class="p">],</span> <span class="n">external_widths</span><span class="p">[</span><span class="n">i_v</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">outvar</span> <span class="ow">in</span> <span class="n">ssa</span><span class="o">.</span><span class="n">assignments</span><span class="p">:</span>
                            <span class="n">ssa</span><span class="o">.</span><span class="n">assignments</span><span class="p">[</span><span class="n">outvar</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssa</span><span class="o">.</span><span class="n">assignments</span><span class="p">[</span><span class="n">outvar</span><span class="p">]</span><span class="o">.</span><span class="n">xreplace</span><span class="p">(</span><span class="n">v2c</span><span class="p">)</span>
                        <span class="n">ssa</span><span class="o">.</span><span class="n">external_vars</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="c1"># print(&quot;# new external samples&quot;)</span>
                        <span class="c1"># print(&quot;v2c:&quot;, v2c)</span>
                        <span class="c1"># print(&quot;external_masks:&quot;, self.external_masks)</span>
                        <span class="c1"># print(&quot;base ssa:&quot;, self.ch_model.ssa)</span>
                        <span class="c1"># print(&quot;ssa:&quot;, ssa)</span>
                        <span class="k">yield</span> <span class="n">ssa</span>

                <span class="n">gen_next_ssa_external_fixed</span> <span class="o">=</span> <span class="n">get_next_ssa_external_fixed</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_external_samples</span><span class="p">)):</span>  <span class="c1"># num_external_samples can be 0</span>
                <span class="n">num_right_inputs</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">if</span> <span class="n">found_external_vars</span><span class="p">:</span>
                    <span class="n">ssa</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">gen_next_ssa_external_fixed</span><span class="p">)</span>
                    <span class="c1"># print(&quot;&gt; ssa:&quot;, ssa)</span>

                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">get_next_input</span><span class="p">():</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_external_vars</span><span class="p">:</span>  <span class="c1"># func() faster than SSA.eval()</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">pt</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;expected a tuple of Constant values returned&quot;</span><span class="p">):</span>
                                <span class="c1"># func might return redundant symbolic outputs (e.g., k ^ k = 0)</span>
                                <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">ssa</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="n">e</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ct</span> <span class="o">=</span> <span class="n">ssa</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ct</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found symbolic output in ct=</span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># lhs = &lt;a,x&gt;, rhs= &lt;f(x), b&gt;</span>
                    <span class="n">lhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pt</span><span class="p">)):</span>
                        <span class="n">lhs</span> <span class="o">^=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                    <span class="n">rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ct</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ct</span><span class="p">)):</span>
                        <span class="n">rhs</span> <span class="o">^=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ct</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">lhs</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">:</span>
                        <span class="n">num_right_inputs</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># print(&quot;pt:&quot;, pt)</span>
                    <span class="c1"># print(&quot;ct:&quot;, ct)</span>
                    <span class="c1"># print(&quot;lhs:&quot;, lhs)</span>
                    <span class="c1"># print(&quot;rhs:&quot;, rhs)</span>
                    <span class="c1"># print()</span>

                <span class="n">aux_empirical_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_num_right_inputs2weight</span><span class="p">(</span><span class="n">num_right_inputs</span><span class="p">,</span> <span class="n">num_input_samples</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">aux_empirical_weights</span>

    <span class="k">def</span> <span class="nf">_get_empirical_data_complexity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_input_samples</span><span class="p">,</span> <span class="n">num_external_samples</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">num_input_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># data complexity = small_ct * c^(-2), c == ch. correlation</span>
            <span class="c1"># 2 w = 2 x -log2(c) = log2(c^(-2)) ==&gt; 2**(2 w) = c^(-2)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_weight</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">error</span><span class="p">()))</span>
            <span class="c1"># small_ct == number of input bits</span>
            <span class="n">small_ct</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">input_mask</span><span class="p">)</span>
            <span class="n">num_input_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">small_ct</span> <span class="o">*</span> <span class="n">p</span><span class="p">))</span>
        <span class="n">num_input_samples</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_input_samples</span><span class="p">,</span> <span class="mi">2</span><span class="o">**</span><span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">input_mask</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_masks</span><span class="p">:</span>
            <span class="n">num_external_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_external_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># an external sample for each external bit</span>
                <span class="n">num_external_samples</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2mask</span><span class="p">])</span>
            <span class="n">num_external_samples</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_external_samples</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">width</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_model</span><span class="o">.</span><span class="n">external_var2mask</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">num_input_samples</span><span class="p">,</span> <span class="n">num_external_samples</span>

<div class="viewcode-block" id="Characteristic.compute_empirical_ch_weight"><a class="viewcode-back" href="../../../cascada.linear.characteristic.html#cascada.linear.characteristic.Characteristic.compute_empirical_ch_weight">[docs]</a>    <span class="k">def</span> <span class="nf">compute_empirical_ch_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_input_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_external_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">split_by_max_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">split_by_rounds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">C_code</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_parallel_processes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute and store the empirical weight.</span>

<span class="sd">        The main description of this method can be read from</span>
<span class="sd">        `abstractproperty.characteristic.Characteristic.compute_empirical_ch_weight`,</span>
<span class="sd">        simply by replacing `Property` by `LinearMask` and</span>
<span class="sd">        input-output pair by hull.</span>

<span class="sd">        The basic subroutine in this case consists of computing the</span>
<span class="sd">        fraction of right inputs for ``num_input_samples`` sampled inputs.</span>
<span class="sd">        An input :math:`x` is a right input if</span>
<span class="sd">        :math:`\langle \\alpha, x \\rangle = \\langle \\beta, f(x) \\rangle`,</span>
<span class="sd">        where :math:`\\alpha` is `input_mask`, :math:`\\beta` is `output_mask`</span>
<span class="sd">        and :math:`f` is the underlying bit-vector function.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.operation import RotateLeft, RotateRight</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.mask import LinearMask, LinearMask</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.chmodel import ChModel</span>
<span class="sd">            &gt;&gt;&gt; from cascada.linear.characteristic import Characteristic</span>
<span class="sd">            &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64).key_schedule</span>
<span class="sd">            &gt;&gt;&gt; Speck32_KS.set_num_rounds(2)</span>
<span class="sd">            &gt;&gt;&gt; ch_model = ChModel(Speck32_KS, LinearMask, [&quot;mk0&quot;, &quot;mk1&quot;, &quot;mk2&quot;])</span>
<span class="sd">            &gt;&gt;&gt; zm = core.Constant(0, width=16)</span>
<span class="sd">            &gt;&gt;&gt; mk0 = RotateLeft(Constant(1, width=16), 8)  # mk0 &gt;&gt;&gt; 7 == 0b0···010</span>
<span class="sd">            &gt;&gt;&gt; mx5 = RotateRight(mk0, 7)  # ~ mk0 &gt;&gt;&gt; 7 == 0b0···010</span>
<span class="sd">            &gt;&gt;&gt; mx3__1 = RotateRight(Constant(1, width=16), 1)  # mx3__1 &lt;&lt;&lt; 2 == 0b0···010</span>
<span class="sd">            &gt;&gt;&gt; mx3_out = core.Constant(0x8002, 16)</span>
<span class="sd">            &gt;&gt;&gt; assign_outmask_list = [zm, zm, zm, zm, mx5, mx3__1, mx5, mx5, zm, mx3_out, mx5]</span>
<span class="sd">            &gt;&gt;&gt; ch = Characteristic([mk0, zm, zm], [zm, mx3_out, mx5], assign_outmask_list, ch_model)</span>
<span class="sd">            &gt;&gt;&gt; ch.compute_empirical_ch_weight(seed=0)</span>
<span class="sd">            &gt;&gt;&gt; ch.empirical_ch_weight</span>
<span class="sd">            Decimal(&#39;1.093109404391481470675941626&#39;)</span>
<span class="sd">            &gt;&gt;&gt; for data in ch.empirical_data_list: print(data)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            EmpiricalWeightData(weight_avg_aux_prs=1.093109404391481470675941626,</span>
<span class="sd">                num_aux_weights=1, num_inf_aux_weights=0, num_input_samples=192, seed=0, C_code=False)</span>
<span class="sd">            &gt;&gt;&gt; ch.compute_empirical_ch_weight(seed=0, C_code=True)</span>
<span class="sd">            &gt;&gt;&gt; ch.empirical_ch_weight</span>
<span class="sd">            Decimal(&#39;1.061400544664143309159590699&#39;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">compute_empirical_ch_weight</span><span class="p">(</span>
            <span class="n">num_input_samples</span><span class="o">=</span><span class="n">num_input_samples</span><span class="p">,</span> <span class="n">num_external_samples</span><span class="o">=</span><span class="n">num_external_samples</span><span class="p">,</span>
            <span class="n">split_by_max_weight</span><span class="o">=</span><span class="n">split_by_max_weight</span><span class="p">,</span> <span class="n">split_by_rounds</span><span class="o">=</span><span class="n">split_by_rounds</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">C_code</span><span class="o">=</span><span class="n">C_code</span><span class="p">,</span> <span class="n">num_parallel_processes</span><span class="o">=</span><span class="n">num_parallel_processes</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="EncryptionCharacteristic"><a class="viewcode-back" href="../../../cascada.linear.characteristic.html#cascada.linear.characteristic.EncryptionCharacteristic">[docs]</a><span class="k">class</span> <span class="nc">EncryptionCharacteristic</span><span class="p">(</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">characteristic</span><span class="o">.</span><span class="n">EncryptionCharacteristic</span><span class="p">,</span> <span class="n">Characteristic</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent linear characteristics over encryption functions.</span>

<span class="sd">    Given a `Cipher`, an `EncryptionCharacteristic` is a</span>
<span class="sd">    linear characteristic  (see `Characteristic`) over</span>
<span class="sd">    the `Cipher.encryption`</span>
<span class="sd">    (where the `Cipher.key_schedule` is ignored and round key masks</span>
<span class="sd">    are given as constant `LinearMask`).</span>

<span class="sd">    The propagation probability of an `EncryptionCharacteristic` is</span>
<span class="sd">    similar to the expected linear probability (ELP), but instead of</span>
<span class="sd">    multiplying the absolute correlations, the ELP multiplies the</span>
<span class="sd">    square of the correlations (see https://eprint.iacr.org/2005/212).</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.operation import RotateRight, RotateLeft</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.mask import LinearMask</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.chmodel import EncryptionChModel</span>
<span class="sd">        &gt;&gt;&gt; from cascada.linear.characteristic import EncryptionCharacteristic</span>
<span class="sd">        &gt;&gt;&gt; from cascada.primitives import speck</span>
<span class="sd">        &gt;&gt;&gt; Speck32 = speck.get_Speck_instance(speck.SpeckInstance.speck_32_64)</span>
<span class="sd">        &gt;&gt;&gt; Speck32.set_num_rounds(2)</span>
<span class="sd">        &gt;&gt;&gt; ch_model = EncryptionChModel(Speck32, LinearMask)</span>
<span class="sd">        &gt;&gt;&gt; zm = core.Constant(0, width=16)</span>
<span class="sd">        &gt;&gt;&gt; p1 = core.Constant(0x0600, width=16)</span>
<span class="sd">        &gt;&gt;&gt; c0 = core.Constant(0x60f0, width=16)</span>
<span class="sd">        &gt;&gt;&gt; c1 = core.Constant(0x60c0, width=16)</span>
<span class="sd">        &gt;&gt;&gt; k1 = core.Constant(0x0030, width=16)</span>
<span class="sd">        &gt;&gt;&gt; bv_1800 = core.Constant(0x1800, width=16)</span>
<span class="sd">        &gt;&gt;&gt; assign_outmask_list = [zm, zm, zm, bv_1800, bv_1800, k1, k1, k1, c1, c1, c0, c1]</span>
<span class="sd">        &gt;&gt;&gt; ch = EncryptionCharacteristic([zm, p1], [c0, c1], assign_outmask_list, ch_model, [zm, k1])</span>
<span class="sd">        &gt;&gt;&gt; ch  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        EncryptionCharacteristic(ch_weight=1, assignment_weights=[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],</span>
<span class="sd">            input_mask=[0x0000, 0x0600], output_mask=[0x60f0, 0x60c0], external_masks=[0x0000, 0x0030],</span>
<span class="sd">            assign_outmask_list=[0x0000, 0x0000, 0x0000, 0x1800, 0x1800, 0x0030,</span>
<span class="sd">                                 0x0030, 0x0030, 0x60c0, 0x60c0, 0x60f0, 0x60c0])</span>
<span class="sd">        &gt;&gt;&gt; list(zip(ch.assignment_weights, ch.tuple_assign_outmask2op_model))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [(Decimal(&#39;0&#39;), (LinearMask(0x0000), LinearModelFreeBranch(LinearMask(0x0600)))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0000), LinearModelBvAdd([LinearMask(0x0000), LinearMask(0x0000)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0000), LinearModelBvXor([LinearMask(0x0000), LinearMask(0x0000)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x1800), LinearModelFreeBranch(LinearMask(0x0000)))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x1800), LinearModelBvXor([LinearMask(0x1800), LinearMask(0x1800)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0030), LinearModelFreeBranch(LinearMask(0x1800)))),</span>
<span class="sd">         (Decimal(&#39;1&#39;), (LinearMask(0x0030), LinearModelBvAdd([LinearMask(0x0030), LinearMask(0x0030)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x0030), LinearModelBvXor([LinearMask(0x0030), LinearMask(0x0030)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x60c0), LinearModelFreeBranch(LinearMask(0x0030)))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x60c0), LinearModelBvXor([LinearMask(0x60c0), LinearMask(0x60c0)]))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x60f0), LinearModelId(LinearMask(0x60f0)))),</span>
<span class="sd">         (Decimal(&#39;0&#39;), (LinearMask(0x60c0), LinearModelId(LinearMask(0x60c0))))]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_mask</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">,</span> <span class="n">assign_outmask_list</span><span class="p">,</span> <span class="n">ch_model</span><span class="p">,</span> <span class="n">external_masks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">free_masks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empirical_ch_weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empirical_data_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_valid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ch_model</span><span class="p">,</span> <span class="n">cascada_chmodel</span><span class="o">.</span><span class="n">EncryptionChModel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ch_model</span><span class="o">.</span><span class="n">ssa</span><span class="o">.</span><span class="n">external_vars</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">external_masks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">input_mask</span><span class="p">,</span> <span class="n">output_mask</span><span class="p">,</span> <span class="n">assign_outmask_list</span><span class="p">,</span> <span class="n">ch_model</span><span class="p">,</span> <span class="n">external_props</span><span class="o">=</span><span class="n">external_masks</span><span class="p">,</span> <span class="n">free_props</span><span class="o">=</span><span class="n">free_masks</span><span class="p">,</span>
            <span class="n">empirical_ch_weight</span><span class="o">=</span><span class="n">empirical_ch_weight</span><span class="p">,</span> <span class="n">empirical_data_list</span><span class="o">=</span><span class="n">empirical_data_list</span><span class="p">,</span> <span class="n">is_valid</span><span class="o">=</span><span class="n">is_valid</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Adrián Ranea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>