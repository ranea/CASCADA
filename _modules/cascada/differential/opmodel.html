<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cascada.differential.opmodel &mdash; CASCADA 1.0.rc0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> CASCADA
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">CASCADA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primitives_implemented.html">Primitives implemented</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cascada.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">CASCADA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>cascada.differential.opmodel</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cascada.differential.opmodel</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Manipulate differential models of bit-vector operations.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">fractions</span>
<span class="kn">import</span> <span class="nn">decimal</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">operation</span>
<span class="kn">from</span> <span class="nn">cascada.bitvector</span> <span class="kn">import</span> <span class="n">secondaryop</span>

<span class="kn">from</span> <span class="nn">cascada</span> <span class="kn">import</span> <span class="n">abstractproperty</span>

<span class="kn">from</span> <span class="nn">cascada.differential</span> <span class="kn">import</span> <span class="n">difference</span>


<span class="nb">zip</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">zip</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">log2_decimal</span> <span class="o">=</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">log2_decimal</span>
<span class="n">make_partial_op_model</span> <span class="o">=</span> <span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">make_partial_op_model</span>


<div class="viewcode-block" id="OpModel"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.OpModel">[docs]</a><span class="k">class</span> <span class="nc">OpModel</span><span class="p">(</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">OpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent differential models of bit-vector operations.</span>

<span class="sd">    A (bit-vector) differential model of a bit-vector `Operation` :math:`f`</span>
<span class="sd">    is a set of bit-vector constraints that models the differential</span>
<span class="sd">    probability (DP) of :math:`f`. See `Difference`.</span>

<span class="sd">    Internally, this class is a subclass of `abstractproperty.opmodel.OpModel`,</span>
<span class="sd">    where the `Property` is a `Difference` type, the pair of input and output</span>
<span class="sd">    properties (differences) :math:`(\\alpha, \\beta)` is called</span>
<span class="sd">    a differential, and the propagation probability is the differential</span>
<span class="sd">    probability.</span>

<span class="sd">    A differential model is defined for a type of `Difference`,</span>
<span class="sd">    such as `XorDiff` or `RXDiff`.</span>

<span class="sd">    This class is not meant to be instantiated but to provide a base</span>
<span class="sd">    class for creating differential models.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        diff_type: the type of `Difference` (alias of</span>
<span class="sd">            `abstractproperty.opmodel.OpModel.prop_type`).</span>
<span class="sd">        input_diff: a list containing the `Difference` of each bit-vector</span>
<span class="sd">            operand (alias of `abstractproperty.opmodel.OpModel.input_prop`).</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        New differential models of bit-vector operations can be easily tested</span>
<span class="sd">        within ``cascada.differential.tests.test_opmodel.TestOpModelsSmallWidth`.</span>

<span class="sd">        The maximum weight of a differential with n-bit input is n</span>
<span class="sd">            DP = # { x  : ... } / 2^{n}</span>
<span class="sd">            weight = -log2(DP) = - (log2(#x) - n) = n - log2(#x)</span>
<span class="sd">            min(log2(#x)) = 0, max(weight) = n</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff_type</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">prop_type</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="c1"># @property decorator does not support initial values like</span>
        <span class="c1"># class(...): diff_type = ...</span>
        <span class="c1"># that is why @property is applied over prop_type</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">diff_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">input_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_prop</span>

<div class="viewcode-block" id="OpModel.eval_derivative"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.OpModel.eval_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">eval_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the derivative of the underlying operation at the point :math:`x`.</span>

<span class="sd">        Given a `Difference` operation :math:`-`  and its inverse :math:`+`,</span>
<span class="sd">        the derivative of an `Operation` :math:`f` at the input difference</span>
<span class="sd">        :math:`\\alpha` is defined as :math:`f_{\\alpha} (x) = f(x + \\alpha) - f(x)`.</span>

<span class="sd">        Return:</span>
<span class="sd">            `Difference`: the `Difference` :math:`f(x + \\alpha) - f(x)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Term</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">f_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">a_i</span><span class="o">.</span><span class="n">get_pair_element</span><span class="p">(</span><span class="n">x_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">x_i</span><span class="p">,</span> <span class="n">a_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">)]</span>
        <span class="n">f_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">diff_type</span><span class="o">.</span><span class="n">from_pair</span><span class="p">(</span><span class="n">f_x</span><span class="p">,</span> <span class="n">f_y</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PartialOpModel"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.PartialOpModel">[docs]</a><span class="k">class</span> <span class="nc">PartialOpModel</span><span class="p">(</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">PartialOpModel</span><span class="p">,</span> <span class="n">OpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent `differential.opmodel.OpModel` of `PartialOperation`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAddCt, RXModelBvShlCt, make_partial_op_model</span>
<span class="sd">        &gt;&gt;&gt; make_partial_op_model(XorModelBvAddCt, tuple([None, Constant(1, 4)])).__name__</span>
<span class="sd">        &#39;XorModelBvAddCt_{·, 0x1}&#39;</span>
<span class="sd">        &gt;&gt;&gt; make_partial_op_model(RXModelBvShlCt, tuple([None, Constant(1, 4)])).__name__</span>
<span class="sd">        &#39;RXModelBvShlCt_{·, 0x1}&#39;</span>

<span class="sd">    See also `abstractproperty.opmodel.PartialOpModel`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<span class="c1"># --------------------------</span>
<span class="c1"># ----- XorDiff models -----</span>
<span class="c1"># --------------------------</span>


<div class="viewcode-block" id="XorModelId"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelId">[docs]</a><span class="k">class</span> <span class="nc">XorModelId</span><span class="p">(</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">ModelIdentity</span><span class="p">,</span> <span class="n">OpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `XorDiff` `differential.opmodel.OpModel` of `BvIdentity`.</span>

<span class="sd">    See also `ModelIdentity`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelId</span>
<span class="sd">        &gt;&gt;&gt; alpha, beta = XorDiff(Variable(&quot;a&quot;, 4)), XorDiff(Variable(&quot;b&quot;, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = XorModelId(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        XorModelId(XorDiff(Variable(&#39;a&#39;, width=4)))</span>
<span class="sd">        &gt;&gt;&gt; f.validity_constraint(beta)</span>
<span class="sd">        a == b</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(Id(a))</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (0, 1, 0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span></div>


<div class="viewcode-block" id="XorModelBvAdd"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd">[docs]</a><span class="k">class</span> <span class="nc">XorModelBvAdd</span><span class="p">(</span><span class="n">OpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `XorDiff` `differential.opmodel.OpModel` of `BvAdd`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAdd</span>
<span class="sd">        &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = XorModelBvAdd(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        XorModelBvAdd([XorDiff(Constant(0b0000, width=4)), XorDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (3, 2, 0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvAdd</span>

<div class="viewcode-block" id="XorModelBvAdd.validity_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd.validity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">validity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the validity constraint for a given output `XorDiff` difference.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAdd</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f.validity_constraint(beta)</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, b = Variable(&quot;a0&quot;, 4), Variable(&quot;a1&quot;, 4), Variable(&quot;b&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(a0), XorDiff(a1)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(b)</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(beta)</span>
<span class="sd">            &gt;&gt;&gt; result</span>
<span class="sd">            ((~(a0 &lt;&lt; 0x1) ^ (a1 &lt;&lt; 0x1)) &amp; (~(a0 &lt;&lt; 0x1) ^ (b &lt;&lt; 0x1)) &amp; (a0 ^ a1 ^ b ^ (a0 &lt;&lt; 0x1))) == 0x0</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({a0: Constant(0, 4), a1: Constant(0, 4), b: Constant(0, 4)})</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; a1 = Constant(0, 4)</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(a0), XorDiff(a1)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(b)</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(beta)</span>
<span class="sd">            &gt;&gt;&gt; result</span>
<span class="sd">            (~(a0 &lt;&lt; 0x1) &amp; ~(b &lt;&lt; 0x1) &amp; (a0 ^ b)) == 0x0</span>

<span class="sd">        See `OpModel.validity_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>

        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">eq</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">eq</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">z</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">xor_shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">xor_shift</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">xor_shift</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span> <span class="o">^</span> <span class="n">z</span> <span class="o">^</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span>
            <span class="n">eq</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">,</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">,</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">xor_shift</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span>
            <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span><span class="p">))</span></div>

        <span class="c1"># # https://doi.org/10.1007/3-540-36231-2_5</span>
        <span class="c1"># dx1, dx2 = [d.val for d in self.input_diff]</span>
        <span class="c1"># dy = output_diff.val</span>
        <span class="c1"># one = core.Constant(1, dx1.width)</span>
        <span class="c1">#</span>
        <span class="c1"># impossible = ~( ((dx1^dy) &lt;&lt; one) | ((dx2^dy) &lt;&lt; one) ) &amp; (dx1^dx2^dy^(dx2&lt;&lt;one))</span>
        <span class="c1">#</span>
        <span class="c1"># return operation.BvComp(impossible, core.Constant(0, dx1.width))</span>

<div class="viewcode-block" id="XorModelBvAdd.pr_one_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd.pr_one_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">pr_one_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the probability-one constraint for a given output `XorDiff`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAdd</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; f.pr_one_constraint(XorDiff(Constant(0, 4)))</span>
<span class="sd">            0b1</span>

<span class="sd">        See `abstractproperty.opmodel.OpModel.pr_one_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_possible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">validity_constraint</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)</span>

        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span>

        <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">eq</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">eq</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">z</span><span class="p">)</span>

        <span class="c1"># not optimized</span>

        <span class="k">return</span> <span class="n">is_possible</span> <span class="o">&amp;</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span>
            <span class="p">(</span><span class="o">~</span><span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span>
            <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="XorModelBvAdd.bv_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd.bv_weight">[docs]</a>    <span class="k">def</span> <span class="nf">bv_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bit-vector weight for a given output `XorDiff`.</span>

<span class="sd">        See also `abstractproperty.opmodel.OpModel.bv_weight`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span>

        <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">eq</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">eq</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">((</span><span class="o">~</span><span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span>  <span class="c1"># ignore MSB</span></div>

        <span class="c1"># # https://doi.org/10.1007/3-540-36231-2_5</span>
        <span class="c1"># dx1, dx2 = [d.val for d in self.input_diff]</span>
        <span class="c1"># dy = output_diff.val</span>
        <span class="c1"># one = core.Constant(1, dx1.width)</span>
        <span class="c1">#</span>
        <span class="c1"># w = ((dx1^dy) &lt;&lt; one) | ((dx2^dy) &lt;&lt; one)</span>
        <span class="c1">#</span>
        <span class="c1"># return secondaryop.PopCount(w)</span>

<div class="viewcode-block" id="XorModelBvAdd.weight_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd.weight_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">weight_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weight constraint for a given output `XorDiff` and weight `Variable`.</span>

<span class="sd">        For the modular addition, the probability of a valid differential</span>
<span class="sd">        is :math:`2^{-i}` for some :math:`i`, and the weight (-log2)</span>
<span class="sd">        is defined as the exponent :math:`i`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAdd</span>
<span class="sd">            &gt;&gt;&gt; n = 4</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, n)), XorDiff(Constant(0, n))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; w = Variable(&quot;w&quot;, f.weight_width())</span>
<span class="sd">            &gt;&gt;&gt; f.weight_constraint(XorDiff(Constant(0, n)), w)</span>
<span class="sd">            w == 0b00</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, b = Variable(&quot;a0&quot;, n), Variable(&quot;a1&quot;, n), Variable(&quot;b&quot;, n)</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(a0), XorDiff(a1)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; result = f.weight_constraint(XorDiff(b), w)</span>
<span class="sd">            &gt;&gt;&gt; result</span>
<span class="sd">            w == PopCount(~((~a0 ^ a1) &amp; (~a0 ^ b))[2:])</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({a0: Constant(0, n), a1: Constant(0, n), b: Constant(0, n)})</span>
<span class="sd">            w == 0b00</span>

<span class="sd">        See `OpModel.weight_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">weight_constraint</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">)</span></div>

<div class="viewcode-block" id="XorModelBvAdd.max_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd.max_weight">[docs]</a>    <span class="k">def</span> <span class="nf">max_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># MSB is ignored</span>
        <span class="k">return</span> <span class="n">width</span>  <span class="c1"># as an integer</span></div>

<div class="viewcode-block" id="XorModelBvAdd.weight_width"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd.weight_width">[docs]</a>    <span class="k">def</span> <span class="nf">weight_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># due to n-2</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span></div>

<div class="viewcode-block" id="XorModelBvAdd.decimal_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd.decimal_weight">[docs]</a>    <span class="k">def</span> <span class="nf">decimal_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_preconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)))</span>  <span class="c1"># num_frac_bits = 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_postconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">dw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dw</span></div>

<div class="viewcode-block" id="XorModelBvAdd.num_frac_bits"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd.num_frac_bits">[docs]</a>    <span class="k">def</span> <span class="nf">num_frac_bits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="XorModelBvAdd.error"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAdd.error">[docs]</a>    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="XorModelBvSub"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvSub">[docs]</a><span class="k">class</span> <span class="nc">XorModelBvSub</span><span class="p">(</span><span class="n">XorModelBvAdd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `XorDiff` `differential.opmodel.OpModel` of `BvSub`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvSub</span>
<span class="sd">        &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = XorModelBvSub(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        XorModelBvSub([XorDiff(Constant(0b0000, width=4)), XorDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (3, 2, 0, 0)</span>

<span class="sd">    The differential model of the modular substraction is the same as `XorModelBvAdd`</span>
<span class="sd">    since ``~(x - y) == ~x + y`` (and `BvNot` preserves differences).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvSub</span></div>


<div class="viewcode-block" id="XorModelBvOr"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr">[docs]</a><span class="k">class</span> <span class="nc">XorModelBvOr</span><span class="p">(</span><span class="n">OpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `XorDiff` `differential.opmodel.OpModel` of `BvOr`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvOr</span>
<span class="sd">        &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = XorModelBvOr(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        XorModelBvOr([XorDiff(Constant(0b0000, width=4)), XorDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (4, 3, 0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvOr</span>

<div class="viewcode-block" id="XorModelBvOr.validity_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr.validity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">validity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the validity constraint for a given output `XorDiff` difference.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvOr</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvOr(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f.validity_constraint(beta)</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, b = Variable(&quot;a0&quot;, 4), Variable(&quot;a1&quot;, 4), Variable(&quot;b&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(a0), XorDiff(a1)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvOr(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(b)</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(beta)</span>
<span class="sd">            &gt;&gt;&gt; result</span>
<span class="sd">            (~a0 &amp; ~a1 &amp; b) == 0x0</span>

<span class="sd">        See `OpModel.validity_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">dx</span><span class="o">.</span><span class="n">width</span>

        <span class="c1"># only bad case: (dx, dy) = (0, 0) -&gt; dz = (1)</span>
        <span class="n">bad_case</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">dx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">dy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">dz</span>

        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">bad_case</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="XorModelBvOr.pr_one_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr.pr_one_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">pr_one_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the probability-one constraint for a given output `XorDiff`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvOr</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvOr(alpha)</span>
<span class="sd">            &gt;&gt;&gt; f.pr_one_constraint(XorDiff(Constant(0, 4)))</span>
<span class="sd">            0b1</span>

<span class="sd">        See `abstractproperty.opmodel.OpModel.pr_one_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">dz</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">dx</span><span class="o">.</span><span class="n">width</span>

        <span class="c1"># (dx, dy) = (0, 0) -&gt; dz =(0)</span>
        <span class="n">pr1_case</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">dx</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">dy</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">dz</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">pr1_case</span><span class="p">,</span> <span class="o">~</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="XorModelBvOr.bv_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr.bv_weight">[docs]</a>    <span class="k">def</span> <span class="nf">bv_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span><span class="n">dx</span> <span class="o">|</span> <span class="n">dy</span><span class="p">)</span></div>

<div class="viewcode-block" id="XorModelBvOr.weight_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr.weight_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">weight_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weight constraint for a given output `XorDiff` and weight `Variable`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvOr</span>
<span class="sd">            &gt;&gt;&gt; n = 4</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, n)), XorDiff(Constant(0, n))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvOr(alpha)</span>
<span class="sd">            &gt;&gt;&gt; w = Variable(&quot;w&quot;, f.weight_width())</span>
<span class="sd">            &gt;&gt;&gt; f.weight_constraint(XorDiff(Constant(0, n)), w)</span>
<span class="sd">            w == 0b000</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, b = Variable(&quot;a0&quot;, n), Variable(&quot;a1&quot;, n), Variable(&quot;b&quot;, n)</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(a0), XorDiff(a1)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvOr(alpha)</span>
<span class="sd">            &gt;&gt;&gt; result = f.weight_constraint(XorDiff(b), w)</span>
<span class="sd">            &gt;&gt;&gt; result  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            w == PopCount(a0 | a1)</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({a0: Constant(0, n), a1: Constant(0, n), b: Constant(0, n)})</span>
<span class="sd">            w == 0b000</span>

<span class="sd">        See `OpModel.weight_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">weight_constraint</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">)</span></div>

<div class="viewcode-block" id="XorModelBvOr.max_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr.max_weight">[docs]</a>    <span class="k">def</span> <span class="nf">max_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dx</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="XorModelBvOr.weight_width"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr.weight_width">[docs]</a>    <span class="k">def</span> <span class="nf">weight_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span></div>

<div class="viewcode-block" id="XorModelBvOr.decimal_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr.decimal_weight">[docs]</a>    <span class="k">def</span> <span class="nf">decimal_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_preconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_postconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">dw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dw</span></div>

<div class="viewcode-block" id="XorModelBvOr.num_frac_bits"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr.num_frac_bits">[docs]</a>    <span class="k">def</span> <span class="nf">num_frac_bits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="XorModelBvOr.error"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvOr.error">[docs]</a>    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="XorModelBvAnd"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAnd">[docs]</a><span class="k">class</span> <span class="nc">XorModelBvAnd</span><span class="p">(</span><span class="n">XorModelBvOr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `XorDiff` `differential.opmodel.OpModel` of `BvAnd`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAnd</span>
<span class="sd">        &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = XorModelBvAnd(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        XorModelBvAnd([XorDiff(Constant(0b0000, width=4)), XorDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (4, 3, 0, 0)</span>

<span class="sd">    The differential model of BvAnd` is the same as `XorModelBvOr`</span>
<span class="sd">    since ``~(x &amp; y) == ~x | ~y`` (and `BvNot` preserves differences).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvAnd</span></div>


<div class="viewcode-block" id="XorModelBvIf"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf">[docs]</a><span class="k">class</span> <span class="nc">XorModelBvIf</span><span class="p">(</span><span class="n">OpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `XorDiff` `differential.opmodel.OpModel` of `BvIf`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvIf</span>
<span class="sd">        &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = XorModelBvIf(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        XorModelBvIf([XorDiff(Constant(0b0000, width=4)), XorDiff(Constant(0b0000, width=4)), XorDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (4, 3, 0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">BvIf</span>

<div class="viewcode-block" id="XorModelBvIf.validity_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf.validity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">validity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the validity constraint for a given output `XorDiff` difference.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvIf</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvIf(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f.validity_constraint(beta)</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, a2, b = Variable(&quot;a0&quot;, 4), Variable(&quot;a1&quot;, 4), Variable(&quot;a2&quot;, 4), Variable(&quot;b&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(a0), XorDiff(a1), XorDiff(a2)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvIf(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(b)</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(beta)</span>
<span class="sd">            &gt;&gt;&gt; result</span>
<span class="sd">            (~a0 &amp; (~a1 ^ a2) &amp; (a1 ^ b)) == 0x0</span>

<span class="sd">        See `OpModel.validity_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span>

        <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">~</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span>

        <span class="n">bad_case</span> <span class="o">=</span> <span class="o">~</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">eq</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">eq</span><span class="p">(</span><span class="o">~</span><span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">bad_case</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="XorModelBvIf.pr_one_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf.pr_one_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">pr_one_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the probability-one constraint for a given output `XorDiff`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvIf</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvIf(alpha)</span>
<span class="sd">            &gt;&gt;&gt; f.pr_one_constraint(XorDiff(Constant(0, 4)))</span>
<span class="sd">            0b1</span>

<span class="sd">        See `abstractproperty.opmodel.OpModel.pr_one_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span>

        <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">z</span><span class="p">)</span>

        <span class="n">pr1_case</span> <span class="o">=</span> <span class="o">~</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">eq</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">pr1_case</span><span class="p">,</span> <span class="o">~</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="XorModelBvIf.bv_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf.bv_weight">[docs]</a>    <span class="k">def</span> <span class="nf">bv_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">~</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span>

        <span class="n">pr1</span> <span class="o">=</span> <span class="o">~</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">eq</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span><span class="o">~</span><span class="n">pr1</span><span class="p">)</span></div>

<div class="viewcode-block" id="XorModelBvIf.weight_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf.weight_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">weight_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weight constraint for a given output `XorDiff` and weight `Variable`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvIf</span>
<span class="sd">            &gt;&gt;&gt; n = 4</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvIf(alpha)</span>
<span class="sd">            &gt;&gt;&gt; w = Variable(&quot;w&quot;, f.weight_width())</span>
<span class="sd">            &gt;&gt;&gt; f.weight_constraint(XorDiff(Constant(0, n)), w)</span>
<span class="sd">            w == 0b000</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, a2, b = Variable(&quot;a0&quot;, 4), Variable(&quot;a1&quot;, 4), Variable(&quot;a2&quot;, 4), Variable(&quot;b&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(a0), XorDiff(a1), XorDiff(a2)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvIf(alpha)</span>
<span class="sd">            &gt;&gt;&gt; result = f.weight_constraint(XorDiff(b), w)</span>
<span class="sd">            &gt;&gt;&gt; result  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            w == PopCount(~(~a0 &amp; (~a1 ^ a2)))</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({a0: Constant(0, n), a1: Constant(0, n), a2: Constant(0, n), b: Constant(0, n)})</span>
<span class="sd">            w == 0b000</span>


<span class="sd">        See `OpModel.weight_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">weight_constraint</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">)</span></div>

<div class="viewcode-block" id="XorModelBvIf.max_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf.max_weight">[docs]</a>    <span class="k">def</span> <span class="nf">max_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="XorModelBvIf.weight_width"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf.weight_width">[docs]</a>    <span class="k">def</span> <span class="nf">weight_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span></div>

<div class="viewcode-block" id="XorModelBvIf.decimal_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf.decimal_weight">[docs]</a>    <span class="k">def</span> <span class="nf">decimal_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_preconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_postconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">dw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dw</span></div>

<div class="viewcode-block" id="XorModelBvIf.num_frac_bits"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf.num_frac_bits">[docs]</a>    <span class="k">def</span> <span class="nf">num_frac_bits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="XorModelBvIf.error"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvIf.error">[docs]</a>    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="XorModelBvMaj"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj">[docs]</a><span class="k">class</span> <span class="nc">XorModelBvMaj</span><span class="p">(</span><span class="n">OpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `XorDiff` `differential.opmodel.OpModel` of `BvMaj`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvMaj</span>
<span class="sd">        &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = XorModelBvMaj(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        XorModelBvMaj([XorDiff(Constant(0b0000, width=4)), XorDiff(Constant(0b0000, width=4)), XorDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (4, 3, 0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">BvMaj</span>

<div class="viewcode-block" id="XorModelBvMaj.validity_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj.validity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">validity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the validity constraint for a given output `XorDiff` difference.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvMaj</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvMaj(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f.validity_constraint(beta)</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, a2, b = Variable(&quot;a0&quot;, 4), Variable(&quot;a1&quot;, 4), Variable(&quot;a2&quot;, 4), Variable(&quot;b&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(a0), XorDiff(a1), XorDiff(a2)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvMaj(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(b)</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(beta)</span>
<span class="sd">            &gt;&gt;&gt; result</span>
<span class="sd">            ((~a0 ^ a1) &amp; (~a0 ^ a2) &amp; (a0 ^ b)) == 0x0</span>

<span class="sd">        See `OpModel.validity_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span>

        <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">z</span><span class="p">)</span>

        <span class="n">bad_case</span> <span class="o">=</span> <span class="n">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">^</span> <span class="n">w</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">bad_case</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="XorModelBvMaj.pr_one_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj.pr_one_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">pr_one_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the probability-one constraint for a given output `XorDiff`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvMaj</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvMaj(alpha)</span>
<span class="sd">            &gt;&gt;&gt; f.pr_one_constraint(XorDiff(Constant(0, 4)))</span>
<span class="sd">            0b1</span>

<span class="sd">        See `abstractproperty.opmodel.OpModel.pr_one_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span>

        <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">z</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">w</span><span class="p">)</span>

        <span class="n">pr1_case</span> <span class="o">=</span> <span class="n">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">pr1_case</span><span class="p">,</span> <span class="o">~</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span></div>

<div class="viewcode-block" id="XorModelBvMaj.bv_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj.bv_weight">[docs]</a>    <span class="k">def</span> <span class="nf">bv_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">^</span> <span class="n">z</span><span class="p">)</span>

        <span class="n">pr1</span> <span class="o">=</span> <span class="n">eq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span><span class="o">~</span><span class="n">pr1</span><span class="p">)</span></div>

<div class="viewcode-block" id="XorModelBvMaj.weight_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj.weight_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">weight_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weight constraint for a given output `XorDiff` and weight `Variable`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvMaj</span>
<span class="sd">            &gt;&gt;&gt; n = 4</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4)), XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvMaj(alpha)</span>
<span class="sd">            &gt;&gt;&gt; w = Variable(&quot;w&quot;, f.weight_width())</span>
<span class="sd">            &gt;&gt;&gt; f.weight_constraint(XorDiff(Constant(0, n)), w)</span>
<span class="sd">            w == 0b000</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, a2, b = Variable(&quot;a0&quot;, 4), Variable(&quot;a1&quot;, 4), Variable(&quot;a2&quot;, 4), Variable(&quot;b&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(a0), XorDiff(a1), XorDiff(a2)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvMaj(alpha)</span>
<span class="sd">            &gt;&gt;&gt; result = f.weight_constraint(XorDiff(b), w)</span>
<span class="sd">            &gt;&gt;&gt; result  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            w == PopCount(~((~a0 ^ a1) &amp; (~a0 ^ a2)))</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({a0: Constant(0, n), a1: Constant(0, n), a2: Constant(0, n), b: Constant(0, n)})</span>
<span class="sd">            w == 0b000</span>


<span class="sd">        See `OpModel.weight_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">weight_constraint</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">)</span></div>

<div class="viewcode-block" id="XorModelBvMaj.max_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj.max_weight">[docs]</a>    <span class="k">def</span> <span class="nf">max_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span></div>

<div class="viewcode-block" id="XorModelBvMaj.weight_width"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj.weight_width">[docs]</a>    <span class="k">def</span> <span class="nf">weight_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span></div>

<div class="viewcode-block" id="XorModelBvMaj.decimal_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj.decimal_weight">[docs]</a>    <span class="k">def</span> <span class="nf">decimal_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_preconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_postconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">dw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dw</span></div>

<div class="viewcode-block" id="XorModelBvMaj.num_frac_bits"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj.num_frac_bits">[docs]</a>    <span class="k">def</span> <span class="nf">num_frac_bits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="XorModelBvMaj.error"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvMaj.error">[docs]</a>    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="XorModelBvAddCt"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt">[docs]</a><span class="k">class</span> <span class="nc">XorModelBvAddCt</span><span class="p">(</span><span class="n">PartialOpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `XorDiff` `PartialOpModel` of modular addition by a constant.</span>

<span class="sd">    This class is not meant to be instantiated but to provide a base</span>
<span class="sd">    class for subclasses generated through `make_partial_op_model`.</span>

<span class="sd">    The class attribute ``precision`` suggests how many fraction bits</span>
<span class="sd">    are used in the bit-vector weight (the actual number of fraction</span>
<span class="sd">    bits is controlled by the property `effective_precision`).</span>
<span class="sd">    The default value of ``precision`` is ``3``,</span>
<span class="sd">    and lower values lead to simpler formulas with higher errors.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAddCt, make_partial_op_model</span>
<span class="sd">        &gt;&gt;&gt; XorModelBvAdd_1 = make_partial_op_model(XorModelBvAddCt, (None, Constant(1, 4)))</span>
<span class="sd">        &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = XorModelBvAdd_1(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        make_partial_op_model(XorModelBvAddCt, (None, Constant(0b0001, width=4)))(XorDiff(Constant(0b0000, width=4)))</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (6, 4, Decimal(&#39;0.08607133205593431&#39;), 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span>
    <span class="n">base_op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvAdd</span>
    <span class="c1"># op is a set through make_partial_op_model</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The constant operand of the modular addition.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">constant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="n">constant</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">constant</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_index_first_one</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">index_first_one</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">index_first_one</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">index_first_one</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_effective_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_first_one</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">effective_precision</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The actual precision (number of fraction bits) used.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># 2 found empirically</span>

    <span class="c1"># noinspection PyPep8Naming</span>
    <span class="k">def</span> <span class="nf">_validity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span>

        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">def</span> <span class="nf">carry</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="c1"># carry[i] = Maj(x[i-1], y[i-1], carry[i-1])</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">^</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span>

        <span class="c1"># # S_0 well defined</span>
        <span class="n">case11_</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span>  <span class="c1"># i-bit is True if S_i = 11*</span>
        <span class="n">case00_</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span>  <span class="c1"># i-bit is True if S_i = 00*</span>
        <span class="n">case__1</span> <span class="o">=</span> <span class="n">u</span> <span class="o">^</span> <span class="n">v</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">one</span>  <span class="c1"># i-bit holds a[i-1]</span>

        <span class="n">local_eq_a</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">a</span> <span class="o">^</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span>  <span class="c1"># i-bit is True if a[i-1] == a[i-2]</span>
        <span class="n">case00_prev</span> <span class="o">=</span> <span class="n">case00_</span> <span class="o">&lt;&lt;</span> <span class="n">one</span>  <span class="c1"># i-bit is True if S_{i-1} = 00*</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">carry</span><span class="p">(</span><span class="n">local_eq_a</span> <span class="o">&amp;</span> <span class="n">case00_</span><span class="p">,</span> <span class="p">(</span><span class="o">~</span><span class="n">case00_prev</span><span class="p">))</span>

        <span class="n">case001</span> <span class="o">=</span> <span class="n">case00_</span> <span class="o">&amp;</span> <span class="n">case__1</span>
        <span class="n">bad_case11_</span> <span class="o">=</span> <span class="n">case11_</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">case__1</span> <span class="o">^</span> <span class="n">local_eq_a</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">|</span> <span class="o">~</span><span class="n">case00_prev</span><span class="p">)</span>

        <span class="n">bad_events</span> <span class="o">=</span> <span class="p">(</span><span class="n">case001</span> <span class="o">|</span> <span class="n">bad_case11_</span><span class="p">)</span>
        <span class="n">is_valid</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">bad_events</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bad_events</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ~~ &quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;u:           &quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;v:           &quot;</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a:           &quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;case11_:     &quot;</span><span class="p">,</span> <span class="n">case11_</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;case00_:     &quot;</span><span class="p">,</span> <span class="n">case00_</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;case__1:     &quot;</span><span class="p">,</span> <span class="n">case__1</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;case001:     &quot;</span><span class="p">,</span> <span class="n">case001</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;case00_prev: &quot;</span><span class="p">,</span> <span class="n">case00_prev</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;local_eq_a:  &quot;</span><span class="p">,</span> <span class="n">local_eq_a</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;c:           &quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bad_case11_: &quot;</span><span class="p">,</span> <span class="n">bad_case11_</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;bad_events:  &quot;</span><span class="p">,</span> <span class="n">bad_events</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;is_valid    :&quot;</span><span class="p">,</span> <span class="n">is_valid</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">is_valid</span>

<div class="viewcode-block" id="XorModelBvAddCt.validity_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt.validity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">validity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the validity constraint for a given output `XorDiff` difference.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAddCt, make_partial_op_model</span>
<span class="sd">            &gt;&gt;&gt; XorModelBvAdd_1 = make_partial_op_model(XorModelBvAddCt, (None, Constant(1, 4)))</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd_1(alpha)</span>
<span class="sd">            &gt;&gt;&gt; f.validity_constraint(XorDiff(Constant(0, 4)))</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; u, v = Variable(&quot;u&quot;, 4), Variable(&quot;v&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd_1(XorDiff(u))</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(XorDiff(v))</span>
<span class="sd">            &gt;&gt;&gt; result  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            ((~(u &lt;&lt; 0x1) &amp; ~(v &lt;&lt; 0x1) &amp; (u ^ v)) | ((u &lt;&lt; 0x1) &amp; (v &lt;&lt; 0x1) &amp; ~(u ^ v ^ 0x9) &amp;</span>
<span class="sd">                ((((0x9 &amp; ~(u &lt;&lt; 0x1) &amp; ~(v &lt;&lt; 0x1)) + ~((~(u &lt;&lt; 0x1) &amp; ~(v &lt;&lt; 0x1)) &lt;&lt; 0x1)) ^ (0x9 &amp; ~(u &lt;&lt; 0x1) &amp;</span>
<span class="sd">                ~(v &lt;&lt; 0x1)) ^ ~((~(u &lt;&lt; 0x1) &amp; ~(v &lt;&lt; 0x1)) &lt;&lt; 0x1)) | ~((~(u &lt;&lt; 0x1) &amp; ~(v &lt;&lt; 0x1)) &lt;&lt; 0x1)))) == 0x0</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({u: Constant(0, 4), v: Constant(0, 4)})</span>
<span class="sd">            0b1</span>

<span class="sd">        See `OpModel.validity_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span>

        <span class="n">effective_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span>
        <span class="n">index_one</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_first_one</span>

        <span class="k">if</span> <span class="n">effective_width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">effective_width</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">index_one</span><span class="p">:],</span> <span class="n">v</span><span class="p">[</span><span class="n">index_one</span><span class="p">:])</span> <span class="o">&amp;</span> \
                   <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="o">~</span><span class="n">u</span><span class="p">[</span><span class="n">index_one</span><span class="p">]</span> <span class="o">^</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">index_one</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">index_one</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index_one</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">index_one</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">v</span><span class="p">[</span><span class="n">index_one</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">(</span><span class="n">u</span><span class="p">[:</span><span class="n">index_one</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">(</span><span class="n">v</span><span class="p">[:</span><span class="n">index_one</span><span class="p">])</span>
            <span class="c1"># reduced_model = type(self)([u], a[:index_one])</span>
            <span class="n">reduced_model</span> <span class="o">=</span> <span class="n">make_partial_op_model</span><span class="p">(</span><span class="n">XorModelBvAddCt</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">[:</span><span class="n">index_one</span><span class="p">]))</span>
            <span class="n">reduced_model</span> <span class="o">=</span> <span class="n">reduced_model</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">reduced_model</span><span class="o">.</span><span class="n">_validity_constraint</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_pr_one_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">all_ones</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">~</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>

        <span class="n">case00_</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span>  <span class="c1"># i-bit is True if S_i = 00*</span>
        <span class="n">case__1</span> <span class="o">=</span> <span class="n">u</span> <span class="o">^</span> <span class="n">v</span>
        <span class="n">case000</span> <span class="o">=</span> <span class="n">case00_</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">case__1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">case000</span><span class="p">,</span> <span class="n">all_ones</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<div class="viewcode-block" id="XorModelBvAddCt.pr_one_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt.pr_one_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">pr_one_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the probability-one constraint for a given output `XorDiff`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAddCt, make_partial_op_model</span>
<span class="sd">            &gt;&gt;&gt; XorModelBvAdd_1 = make_partial_op_model(XorModelBvAddCt, (None, Constant(1, 4)))</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd_1(alpha)</span>
<span class="sd">            &gt;&gt;&gt; f.pr_one_constraint(XorDiff(Constant(0, 4)))</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; u, v = Variable(&quot;u&quot;, 4), Variable(&quot;v&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd_1(XorDiff(u))</span>
<span class="sd">            &gt;&gt;&gt; result = f.pr_one_constraint(XorDiff(v))</span>
<span class="sd">            &gt;&gt;&gt; result</span>
<span class="sd">            (~(u &lt;&lt; 0x1) &amp; ~(v &lt;&lt; 0x1) &amp; ~(u ^ v)) == 0xf</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({u: Constant(0, 4), v: Constant(0, 4)})</span>
<span class="sd">            0b1</span>

<span class="sd">        See `abstractproperty.opmodel.OpModel.pr_one_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span>

        <span class="n">effective_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span>
        <span class="n">index_one</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_first_one</span>

        <span class="k">if</span> <span class="n">effective_width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">effective_width</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">index_one</span><span class="p">:],</span> <span class="n">v</span><span class="p">[</span><span class="n">index_one</span><span class="p">:])</span> <span class="o">&amp;</span> \
                   <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="o">~</span><span class="n">u</span><span class="p">[</span><span class="n">index_one</span><span class="p">]</span> <span class="o">^</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">index_one</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">index_one</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index_one</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">index_one</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">v</span><span class="p">[</span><span class="n">index_one</span><span class="o">-</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">(</span><span class="n">u</span><span class="p">[:</span><span class="n">index_one</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">(</span><span class="n">v</span><span class="p">[:</span><span class="n">index_one</span><span class="p">])</span>
            <span class="c1"># reduced_model = type(self)([u], a[:index_one])</span>
            <span class="n">reduced_model</span> <span class="o">=</span> <span class="n">make_partial_op_model</span><span class="p">(</span><span class="n">XorModelBvAddCt</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">[:</span><span class="n">index_one</span><span class="p">]))</span>
            <span class="n">reduced_model</span> <span class="o">=</span> <span class="n">reduced_model</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">reduced_model</span><span class="o">.</span><span class="n">_pr_one_constraint</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>

    <span class="c1"># noinspection SpellCheckingInspection</span>
<div class="viewcode-block" id="XorModelBvAddCt.weight_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt.weight_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">weight_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weight constraint for a given output `XorDiff` and weight `Variable`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.printing import BvWrapPrinter</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAddCt, make_partial_op_model</span>
<span class="sd">            &gt;&gt;&gt; width = 4</span>
<span class="sd">            &gt;&gt;&gt; XorModelBvAdd_1 = make_partial_op_model(XorModelBvAddCt, (None, Constant(1, width)))</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(0, width))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd_1(alpha)</span>
<span class="sd">            &gt;&gt;&gt; w = Variable(&quot;w&quot;, f.weight_width())</span>
<span class="sd">            &gt;&gt;&gt; f.weight_constraint(XorDiff(Constant(0, width)), w)</span>
<span class="sd">            0x0 == w</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Variable(&quot;u&quot;, width))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd_1(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = XorDiff(Variable(&quot;v&quot;, width))</span>
<span class="sd">            &gt;&gt;&gt; weight_constraint = f.weight_constraint(beta, w, prefix=&quot;w_tmp&quot;)</span>
<span class="sd">            &gt;&gt;&gt; BvWrapPrinter.use_symbols, BvWrapPrinter.new_line_right_parenthesis = True, False</span>
<span class="sd">            &gt;&gt;&gt; print(BvWrapPrinter().doprint(weight_constraint))</span>
<span class="sd">            &amp;(&amp;(&amp;(&amp;(&amp;(==(-(::(PopCountDiff(((u ^ v) &lt;&lt; 0x1) | (((~u &amp; ~v) &lt;&lt; 0x1) &amp; ~w_tmp_0lz),</span>
<span class="sd">                                           ^(^(w_tmp_1rev + 0x1 + (w_tmp_4rev &amp; w_tmp_1rev),</span>
<span class="sd">                                               w_tmp_1rev + 0x1),</span>
<span class="sd">                                             w_tmp_4rev &amp; w_tmp_1rev)),</span>
<span class="sd">                              0b0),</span>
<span class="sd">                           ::(0b0,</span>
<span class="sd">                              PopCount(&amp;(&amp;(w_tmp_4rev,</span>
<span class="sd">                                           ^(^(w_tmp_1rev + 0x1 + (w_tmp_4rev &amp; w_tmp_1rev),</span>
<span class="sd">                                               w_tmp_1rev + 0x1),</span>
<span class="sd">                                             w_tmp_4rev &amp; w_tmp_1rev)),</span>
<span class="sd">                                         ~(&lt;&lt;(^(^(w_tmp_1rev + 0x1 + (w_tmp_4rev &amp; w_tmp_1rev),</span>
<span class="sd">                                                  w_tmp_1rev + 0x1),</span>
<span class="sd">                                                w_tmp_4rev &amp; w_tmp_1rev),</span>
<span class="sd">                                              0x1)))))),</span>
<span class="sd">                         w),</span>
<span class="sd">                      w_tmp_0lz == LeadingZeros(~((~u &amp; ~v) &lt;&lt; 0x1))),</span>
<span class="sd">                    w_tmp_1rev == Reverse((~u &amp; ~v) &lt;&lt; 0x1)),</span>
<span class="sd">                  ==(w_tmp_2rev,</span>
<span class="sd">                     Reverse((~(0x2 ^ u ^ v) &gt;&gt; 0x1) &amp; ((~u &amp; ~v) &lt;&lt; 0x1) &amp; ~(((~u &amp; ~v) &lt;&lt; 0x1) &gt;&gt; 0x1)))),</span>
<span class="sd">                w_tmp_3rev == Reverse((w_tmp_1rev + w_tmp_2rev) ^ w_tmp_1rev ^ w_tmp_2rev)),</span>
<span class="sd">              ==(w_tmp_4rev,</span>
<span class="sd">                 Reverse(|(-((~(0x2 ^ u ^ v) &gt;&gt; 0x1) &amp; ((~u &amp; ~v) &lt;&lt; 0x1) &amp; ~(((~u &amp; ~v) &lt;&lt; 0x1) &gt;&gt; 0x1),</span>
<span class="sd">                             &amp;(+(0x2 &amp; ~((~u &amp; ~v) &lt;&lt; 0x1) &amp; (((~u &amp; ~v) &lt;&lt; 0x1) &gt;&gt; 0x1),</span>
<span class="sd">                                 0x1 &amp; (((~u &amp; ~v) &lt;&lt; 0x1) &gt;&gt; 0x1)),</span>
<span class="sd">                               |(w_tmp_3rev,</span>
<span class="sd">                                 (~(0x2 ^ u ^ v) &gt;&gt; 0x1) &amp; ((~u &amp; ~v) &lt;&lt; 0x1) &amp; ~(((~u &amp; ~v) &lt;&lt; 0x1) &gt;&gt; 0x1)))),</span>
<span class="sd">                           &amp;(+(0x2 &amp; ~((~u &amp; ~v) &lt;&lt; 0x1) &amp; (((~u &amp; ~v) &lt;&lt; 0x1) &gt;&gt; 0x1),</span>
<span class="sd">                               0x1 &amp; (((~u &amp; ~v) &lt;&lt; 0x1) &gt;&gt; 0x1)),</span>
<span class="sd">                             ~(|(w_tmp_3rev,</span>
<span class="sd">                                 (~(0x2 ^ u ^ v) &gt;&gt; 0x1) &amp; ((~u &amp; ~v) &lt;&lt; 0x1) &amp; ~(((~u &amp; ~v) &lt;&lt; 0x1) &gt;&gt; 0x1))))))))</span>
<span class="sd">            &gt;&gt;&gt; weight_constraint = f.weight_constraint(beta, w, prefix=&quot;w_tmp&quot;)</span>
<span class="sd">            &gt;&gt;&gt; r = {Variable(&quot;u&quot;, width): Constant(0, width), Variable(&quot;v&quot;, width): Constant(0, width)}</span>
<span class="sd">            &gt;&gt;&gt; print(BvWrapPrinter().doprint(weight_constraint.xreplace(r)))</span>
<span class="sd">            &amp;(&amp;(&amp;(&amp;(&amp;(==(-(::(PopCountDiff(0xe &amp; ~w_tmp_0lz,</span>
<span class="sd">                                           ^(^(w_tmp_1rev + 0x1 + (w_tmp_4rev &amp; w_tmp_1rev),</span>
<span class="sd">                                               w_tmp_1rev + 0x1),</span>
<span class="sd">                                             w_tmp_4rev &amp; w_tmp_1rev)),</span>
<span class="sd">                              0b0),</span>
<span class="sd">                           ::(0b0,</span>
<span class="sd">                              PopCount(&amp;(&amp;(w_tmp_4rev,</span>
<span class="sd">                                           ^(^(w_tmp_1rev + 0x1 + (w_tmp_4rev &amp; w_tmp_1rev),</span>
<span class="sd">                                               w_tmp_1rev + 0x1),</span>
<span class="sd">                                             w_tmp_4rev &amp; w_tmp_1rev)),</span>
<span class="sd">                                         ~(&lt;&lt;(^(^(w_tmp_1rev + 0x1 + (w_tmp_4rev &amp; w_tmp_1rev),</span>
<span class="sd">                                                  w_tmp_1rev + 0x1),</span>
<span class="sd">                                                w_tmp_4rev &amp; w_tmp_1rev),</span>
<span class="sd">                                              0x1)))))),</span>
<span class="sd">                         w),</span>
<span class="sd">                      w_tmp_0lz == 0xe),</span>
<span class="sd">                    w_tmp_1rev == 0x7),</span>
<span class="sd">                  w_tmp_2rev == 0x0),</span>
<span class="sd">                w_tmp_3rev == Reverse((w_tmp_1rev + w_tmp_2rev) ^ w_tmp_1rev ^ w_tmp_2rev)),</span>
<span class="sd">              w_tmp_4rev == Reverse(-(0x1 &amp; w_tmp_3rev) | (0x1 &amp; ~w_tmp_3rev)))</span>
<span class="sd">            &gt;&gt;&gt; BvWrapPrinter.use_symbols, BvWrapPrinter.new_line_right_parenthesis = False, True</span>

<span class="sd">        See `OpModel.weight_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span>

        <span class="n">effective_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span>
        <span class="n">index_one</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_first_one</span>

        <span class="k">if</span> <span class="n">effective_width</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">bv_weight</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">extra_constraints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">(</span><span class="n">u</span><span class="p">[:</span><span class="n">index_one</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">(</span><span class="n">v</span><span class="p">[:</span><span class="n">index_one</span><span class="p">])</span>
            <span class="c1"># reduced_model = type(self)([u], a[:index_one])</span>
            <span class="n">reduced_model</span> <span class="o">=</span> <span class="n">make_partial_op_model</span><span class="p">(</span><span class="n">XorModelBvAddCt</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">a</span><span class="p">[:</span><span class="n">index_one</span><span class="p">]))</span>
            <span class="n">reduced_model</span> <span class="o">=</span> <span class="n">reduced_model</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">bv_weight</span><span class="p">,</span> <span class="n">extra_constraints</span> <span class="o">=</span> <span class="n">reduced_model</span><span class="o">.</span><span class="n">_bvweight_and_extra_constraints</span><span class="p">(</span>
                <span class="n">v</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>

        <span class="n">weight_constraint</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">bv_weight</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">extra_constraints</span><span class="p">:</span>
            <span class="n">weight_constraint</span> <span class="o">&amp;=</span> <span class="n">c</span>

        <span class="k">return</span> <span class="n">weight_constraint</span></div>

<div class="viewcode-block" id="XorModelBvAddCt.external_vars_weight_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt.external_vars_weight_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">external_vars_weight_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_constraint</span><span class="p">(</span>
            <span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">constraint</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">weight_variable</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_bvweight_and_extra_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">version</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span>
        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">assert</span> <span class="n">version</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># 0-reference, 1-w/o extra reverse, 2-s_000 and no HW2 in fr</span>

        <span class="n">are_ct_differences</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">are_ct_differences</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">blake2b</span><span class="p">(</span><span class="n">digest_size</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
            <span class="n">h</span><span class="o">.</span><span class="n">update</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span> <span class="o">+</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">vrepr</span><span class="p">())</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;_tmp&quot;</span> <span class="o">+</span> <span class="n">h</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_i_auxvar</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">extra_constraints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">rev</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">are_ct_differences</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">Reverse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">rev&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i_auxvar</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_i_auxvar</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">extra_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">Reverse</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
                <span class="k">return</span> <span class="n">aux</span>

        <span class="k">def</span> <span class="nf">lz</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">are_ct_differences</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">LeadingZeros</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">aux</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">lz&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i_auxvar</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_i_auxvar</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">extra_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">LeadingZeros</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
                <span class="k">return</span> <span class="n">aux</span>

        <span class="k">def</span> <span class="nf">carry</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">^</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span>

        <span class="k">def</span> <span class="nf">rev_carry</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">rev</span><span class="p">(</span><span class="n">carry</span><span class="p">(</span><span class="n">rev</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">rev</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">version</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">s00_old</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">u</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span>  <span class="c1"># i-bit is True if S_{i} = 00*</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s00_old</span> <span class="o">=</span> <span class="p">((</span><span class="o">~</span><span class="n">u</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">v</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">one</span>
        <span class="n">s00_</span> <span class="o">=</span> <span class="n">s00_old</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">lz</span><span class="p">(</span><span class="o">~</span><span class="n">s00_old</span><span class="p">))</span>  <span class="c1"># if x is 001*...*, then lz(x) = 1100...0</span>

        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">e_i1</span> <span class="o">=</span> <span class="n">s00_</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span> <span class="p">(</span><span class="n">s00_</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">))</span>  <span class="c1"># e_{i-1}</span>
            <span class="n">e_ili</span> <span class="o">=</span> <span class="o">~</span><span class="n">s00_</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s00_</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)</span>  <span class="c1"># e_{i-l_i}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">e_i1</span> <span class="o">=</span> <span class="n">s00_old</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span> <span class="p">(</span><span class="n">s00_old</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">))</span>  <span class="c1"># e_{i-1}</span>
            <span class="n">e_ili</span> <span class="o">=</span> <span class="o">~</span><span class="n">s00_old</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s00_old</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)</span>  <span class="c1"># e_{i-l_i}</span>

        <span class="n">q</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">u</span> <span class="o">^</span> <span class="n">v</span><span class="p">))</span>  <span class="c1"># q[i] = ~(a[i-1]^u[i]^v[i])</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">((</span><span class="n">q</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">e_i1</span><span class="p">)</span>  <span class="c1"># q[i-1, i-3] = (a[i-1]^u[i]^v[i], 0, 0)</span>

        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">e_ili</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s00_</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">e_ili</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s00_old</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">rev_carry</span><span class="p">(</span><span class="n">s00_</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rev_s00_old</span> <span class="o">=</span> <span class="n">rev</span><span class="p">(</span><span class="n">s00_old</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">rev</span><span class="p">(</span><span class="n">carry</span><span class="p">(</span><span class="n">rev_s00_old</span><span class="p">,</span> <span class="n">rev</span><span class="p">(</span><span class="n">q</span><span class="p">)))</span> <span class="o">|</span> <span class="n">q</span>

        <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="n">d</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">s</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">d</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">&lt;&lt;</span> <span class="n">one</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">rev_carry</span><span class="p">(</span><span class="n">s00_</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">,</span> <span class="n">w</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">s00_</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rev_w</span> <span class="o">=</span> <span class="n">rev</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">one</span>
            <span class="n">rev_h</span> <span class="o">=</span> <span class="n">carry</span><span class="p">((</span><span class="n">rev_s00_old</span> <span class="o">+</span> <span class="n">one</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">,</span> <span class="n">rev_w</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev</span><span class="p">(</span><span class="n">s00_</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rev_w</span> <span class="o">=</span> <span class="n">rev</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">rev_h</span> <span class="o">=</span> <span class="n">carry</span><span class="p">(</span><span class="n">rev_s00_old</span> <span class="o">+</span> <span class="n">one</span><span class="p">,</span> <span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_s00_old</span><span class="p">)</span>

        <span class="n">sbnegb</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">^</span> <span class="n">v</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">one</span>  <span class="c1"># i-bit is True if S_{i} = (b, \neg b, *)</span>

        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">int</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCountDiff</span><span class="p">(</span><span class="n">sbnegb</span> <span class="o">|</span> <span class="n">s00_</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>   <span class="c1"># or hw(sbminb_) + (hw(s00_) - hw(h))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">int</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCountDiff</span><span class="p">(</span><span class="n">sbnegb</span> <span class="o">|</span> <span class="n">s00_</span><span class="p">,</span> <span class="n">rev_h</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">smart_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="c1"># ignores overflow</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">zero_extend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">operation</span><span class="o">.</span><span class="n">zero_extend</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">smart_sub</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="c1"># ignores overflow</span>
            <span class="c1"># cannot be replaced by smart_add(x, -y)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">zero_extend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">operation</span><span class="o">.</span><span class="n">zero_extend</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_precision</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">int_frac</span> <span class="o">=</span> <span class="nb">int</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">int</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">f1</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span><span class="n">w</span> <span class="o">&amp;</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)))</span>  <span class="c1"># each one adds 2^(-1)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f1</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span><span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)))</span>
            <span class="n">int_frac</span> <span class="o">=</span> <span class="n">smart_sub</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">f1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">two</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">three</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">four</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">f12</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCountSum2</span><span class="p">(</span>
                    <span class="n">w</span> <span class="o">&amp;</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)),</span>
                    <span class="n">w</span> <span class="o">&amp;</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="p">((</span><span class="o">~</span><span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">two</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">))</span>
                <span class="p">)</span>  <span class="c1"># each one adds 2^(-2), that&#39;s why ~(h &gt;&gt; one) need to be counted twice</span>
            <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">f12</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCountSum2</span><span class="p">(</span>
                    <span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)),</span>
                    <span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span> <span class="o">&amp;</span> <span class="p">((</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">two</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f12</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span>
                    <span class="c1"># ( ( rev_w &amp; rev_h &amp; (~(rev_h &lt;&lt; one)) ) &gt;&gt; one ) |</span>
                    <span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">rev_h</span><span class="p">)</span>  <span class="p">)</span> <span class="o">|</span>
                    <span class="p">(</span><span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span> <span class="o">&amp;</span> <span class="p">((</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">two</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)))</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">int</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">int_frac</span> <span class="o">=</span> <span class="n">smart_sub</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">f12</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># f3 cannot be included in f12, since ~(h &gt;&gt; one) would need to be counted 4 times</span>
                <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f3</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span><span class="n">w</span> <span class="o">&amp;</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">two</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">three</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f3</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span><span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">two</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">three</span><span class="p">)))</span>
                <span class="nb">int</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
                <span class="n">f12</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">f12</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">int_frac</span> <span class="o">=</span> <span class="n">smart_sub</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">smart_add</span><span class="p">(</span><span class="n">f12</span><span class="p">,</span> <span class="n">f3</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f34</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCountSum2</span><span class="p">(</span>
                        <span class="n">w</span> <span class="o">&amp;</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">two</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">three</span><span class="p">)),</span>
                        <span class="n">w</span> <span class="o">&amp;</span> <span class="n">h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">two</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="o">~</span><span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">three</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">four</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">h</span> <span class="o">&gt;&gt;</span> <span class="n">three</span><span class="p">)))</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">f34</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCountSum2</span><span class="p">(</span>
                        <span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">two</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">three</span><span class="p">)),</span>
                        <span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">two</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">three</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">four</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">three</span><span class="p">)))</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f34</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span>
                        <span class="c1"># ( (rev_w &amp; rev_h &amp; (rev_h &lt;&lt; one) &amp; (rev_h &lt;&lt; two) &amp; (~(rev_h &lt;&lt; three))) &gt;&gt; one ) |</span>
                        <span class="p">(</span> <span class="p">((</span><span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">rev_h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">two</span><span class="p">)))</span> <span class="o">|</span>
                        <span class="p">(</span><span class="n">rev_w</span> <span class="o">&amp;</span> <span class="n">rev_h</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">two</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">three</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">four</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">rev_h</span> <span class="o">&lt;&lt;</span> <span class="n">three</span><span class="p">))))</span>
                    <span class="p">)</span>
                <span class="nb">int</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
                <span class="n">f12</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">Concat</span><span class="p">(</span><span class="n">f12</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">int_frac</span> <span class="o">=</span> <span class="n">smart_sub</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">smart_add</span><span class="p">(</span><span class="n">f12</span><span class="p">,</span> <span class="n">f34</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;precision must be between 0 and 4&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2"> ~~ &quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;u:            &quot;</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;v:            &quot;</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a:            &quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;s00_:         &quot;</span><span class="p">,</span> <span class="n">s00_</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;e_i1:         &quot;</span><span class="p">,</span> <span class="n">e_i1</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;e_ili1:       &quot;</span><span class="p">,</span> <span class="n">e_ili</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;q:            &quot;</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;s:            &quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;d:            &quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;w:            &quot;</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;h:            &quot;</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rev_w:        &quot;</span><span class="p">,</span> <span class="n">rev_w</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;rev_h:        &quot;</span><span class="p">,</span> <span class="n">rev_h</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sbnegb:       &quot;</span><span class="p">,</span> <span class="n">sbnegb</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;int:          &quot;</span><span class="p">,</span> <span class="nb">int</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f1:           &quot;</span><span class="p">,</span> <span class="n">f1</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f12:          &quot;</span><span class="p">,</span> <span class="n">f12</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f3:           &quot;</span><span class="p">,</span> <span class="n">f3</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
                <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;f34:          &quot;</span><span class="p">,</span> <span class="n">f34</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;int_frac:     &quot;</span><span class="p">,</span> <span class="n">int_frac</span><span class="o">.</span><span class="n">bin</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">int_frac</span><span class="p">,</span> <span class="n">extra_constraints</span>

<div class="viewcode-block" id="XorModelBvAddCt.max_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt.max_weight">[docs]</a>    <span class="k">def</span> <span class="nf">max_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">effective_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span>

        <span class="k">if</span> <span class="n">effective_width</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">effective_width</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_precision</span><span class="p">)</span></div>

<div class="viewcode-block" id="XorModelBvAddCt.weight_width"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt.weight_width">[docs]</a>    <span class="k">def</span> <span class="nf">weight_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">effective_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span>
        <span class="n">index_one</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_first_one</span>

        <span class="k">if</span> <span class="n">effective_width</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="p">[:</span><span class="n">index_one</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">u</span><span class="o">.</span><span class="n">width</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_precision</span></div>

<div class="viewcode-block" id="XorModelBvAddCt.decimal_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt.decimal_weight">[docs]</a>    <span class="k">def</span> <span class="nf">decimal_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `decimal.Decimal` weight for a given constant output `XorDiff`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAddCt, make_partial_op_model</span>
<span class="sd">            &gt;&gt;&gt; XorModelBvAdd_1 = make_partial_op_model(XorModelBvAddCt, (None, Constant(1, 4)))</span>
<span class="sd">            &gt;&gt;&gt; alpha = XorDiff(Constant(4, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = XorModelBvAdd_1(alpha)</span>
<span class="sd">            &gt;&gt;&gt; w = Variable(&quot;w&quot;, f.weight_width())</span>
<span class="sd">            &gt;&gt;&gt; f.weight_constraint(XorDiff(Constant(4, 4)), w), f&quot;w to be divided by 2^{f.num_frac_bits()}&quot;</span>
<span class="sd">            (0x1 == w, &#39;w to be divided by 2^1&#39;)</span>
<span class="sd">            &gt;&gt;&gt; f.decimal_weight(XorDiff(Constant(4, 4)))</span>
<span class="sd">            Decimal(&#39;0.4150374992788438185462610560&#39;)</span>

<span class="sd">        See also `abstractproperty.opmodel.OpModel.decimal_weight`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_preconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)</span>

        <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ct</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">width</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">probability2weight</span><span class="p">(</span><span class="n">pr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">elif</span> <span class="n">pr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># avoid 0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">fractions</span><span class="o">.</span><span class="n">Fraction</span><span class="p">):</span>
                    <span class="n">pr</span> <span class="o">=</span> <span class="n">pr</span><span class="o">.</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="n">pr</span><span class="o">.</span><span class="n">denominator</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pr</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="n">pr</span><span class="p">)</span>
                <span class="n">my_w</span> <span class="o">=-</span> <span class="n">log2_decimal</span><span class="p">(</span><span class="n">pr</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">my_w</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="n">my_w</span>

        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">probability2weight</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">probability</span> <span class="o">=</span> <span class="n">fractions</span><span class="o">.</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">fractions</span><span class="o">.</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">fractions</span><span class="o">.</span><span class="n">Fraction</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">probability2weight</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">probability</span> <span class="o">*=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">))</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">probability</span> <span class="o">*=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">delta</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">fractions</span><span class="o">.</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">probability</span> <span class="o">*=</span> <span class="n">fractions</span><span class="o">.</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">probability</span> <span class="o">*=</span> <span class="n">fractions</span><span class="o">.</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]:</span>
                <span class="n">probability</span> <span class="o">*=</span> <span class="n">fractions</span><span class="o">.</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">if</span> <span class="p">[</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">probability</span> <span class="o">*=</span> <span class="n">fractions</span><span class="o">.</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dw</span> <span class="o">=</span> <span class="n">probability2weight</span><span class="p">(</span><span class="n">probability</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_postconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">dw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dw</span></div>

<div class="viewcode-block" id="XorModelBvAddCt.num_frac_bits"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt.num_frac_bits">[docs]</a>    <span class="k">def</span> <span class="nf">num_frac_bits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_precision</span></div>

    <span class="c1"># noinspection SpellCheckingInspection</span>
    <span class="nd">@classmethod</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">_len2error</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ct_width</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a dictionary mapping difference lengths to their maximum error.</span>

<span class="sd">            &gt;&gt;&gt; # docstring for debugging purposes</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAddCt, make_partial_op_model</span>
<span class="sd">            &gt;&gt;&gt; XorModelBvAdd_1 = make_partial_op_model(XorModelBvAddCt, (None, Constant(1, 4)))</span>
<span class="sd">            &gt;&gt;&gt; _ = XorModelBvAddCt._len2error(8, 4, True)</span>
<span class="sd">            chainlen2biterror: {3: Decimal(&#39;0.03&#39;)}</span>
<span class="sd">            worst_chainlen: 3</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             &gt; difflen: 4</span>
<span class="sd">             &gt; decompositions: [[3]]</span>
<span class="sd">             &gt; worst_decomp: [3]</span>
<span class="sd">             &gt; difflen2differror[4]: 0.08607133205593431</span>
<span class="sd">             &gt; difflen: 5</span>
<span class="sd">             &gt; decompositions: [[3]]</span>
<span class="sd">             &gt; worst_decomp: [3]</span>
<span class="sd">             &gt; difflen2differror[5]: 0.08607133205593431</span>
<span class="sd">             &gt; difflen: 7</span>
<span class="sd">             &gt; decompositions: [[3, 3], [3]]</span>
<span class="sd">             &gt; worst_decomp: [3, 3]</span>
<span class="sd">             &gt; difflen2differror[7]: 0.17214266411186862</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            prime_lens: [3]</span>
<span class="sd">            difflen2differror: [0, 0, 0, Decimal(&#39;0.09&#39;), Decimal(&#39;0.09&#39;), Decimal(&#39;0.09&#39;), Decimal(&#39;0.17&#39;), Decimal(&#39;0.17&#39;)]</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &gt;&gt;&gt; [round(d, 2) for d in XorModelBvAddCt._len2error(8, 0)]</span>
<span class="sd">            [0, 0, 0, Decimal(&#39;1.00&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;2.00&#39;), Decimal(&#39;2.00&#39;)]</span>
<span class="sd">            &gt;&gt;&gt; [round(d, 2) for d in XorModelBvAddCt._len2error(8, 1)]</span>
<span class="sd">            [0, 0, 0, Decimal(&#39;0.09&#39;), Decimal(&#39;0.58&#39;), Decimal(&#39;0.58&#39;), Decimal(&#39;0.58&#39;), Decimal(&#39;0.67&#39;)]</span>
<span class="sd">            &gt;&gt;&gt; [round(d, 2) for d in XorModelBvAddCt._len2error(8, 2)]</span>
<span class="sd">            [0, 0, 0, Decimal(&#39;0.09&#39;), Decimal(&#39;0.09&#39;), Decimal(&#39;0.33&#39;), Decimal(&#39;0.33&#39;), Decimal(&#39;0.33&#39;)]</span>
<span class="sd">            &gt;&gt;&gt; [round(d, 2) for d in XorModelBvAddCt._len2error(8, 3)]</span>
<span class="sd">            [0, 0, 0, Decimal(&#39;0.09&#39;), Decimal(&#39;0.09&#39;), Decimal(&#39;0.09&#39;), Decimal(&#39;0.21&#39;), Decimal(&#39;0.21&#39;)]</span>
<span class="sd">            &gt;&gt;&gt; [round(d, 2) for d in XorModelBvAddCt._len2error(8, 4)]</span>
<span class="sd">            [0, 0, 0, Decimal(&#39;0.09&#39;), Decimal(&#39;0.09&#39;), Decimal(&#39;0.09&#39;), Decimal(&#39;0.17&#39;), Decimal(&#39;0.17&#39;)]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ct_width</span>

        <span class="k">assert</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">32</span>

        <span class="k">def</span> <span class="nf">get_chainlen2biterror</span><span class="p">():</span>
            <span class="k">def</span> <span class="nf">bit_error</span><span class="p">(</span><span class="n">chainlen</span><span class="p">):</span>
                <span class="c1"># given a chain of length l_i,</span>
                <span class="c1"># if pi != 2^{-i}, then p_i &lt;= 2^{l_i - 1} - 1</span>
                <span class="c1"># and there are (at most) l_i - 2 bits right to the leftmost active bit.</span>
                <span class="c1"># (e.g. l_i = 4, p_i &lt;= 7 = 0b111, two &quot;fraction bits&quot;)</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">precision</span>

                <span class="k">if</span> <span class="n">chainlen</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
                    <span class="c1"># bound = 1 - (1 + ln(ln(2))) / ln(2) = 0.086...</span>
                    <span class="c1"># is the error when all fraction bits are sued</span>
                    <span class="k">return</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;0.08607133205593431&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">chainlen</span>

                <span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="n">t_i</span> <span class="o">*</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">t_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="p">)]</span>  <span class="c1"># t[i] = t_i * 2**(-k)</span>
                <span class="n">chainerror</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">log2_decimal</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">t_i</span> <span class="o">+</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="p">))</span> <span class="o">-</span> <span class="n">t_i</span> <span class="k">for</span> <span class="n">t_i</span> <span class="ow">in</span> <span class="n">t</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">chainerror</span> <span class="o">/</span> <span class="n">chainlen</span>

            <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">worst_chainlen</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">worst_chainlen_error</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">chainlen</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="c1"># chainlen = l_i</span>
                <span class="n">chainerror</span> <span class="o">=</span> <span class="n">bit_error</span><span class="p">(</span><span class="n">chainlen</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">chainerror</span> <span class="o">&gt;</span> <span class="n">worst_chainlen_error</span><span class="p">:</span>
                    <span class="n">worst_chainlen_error</span> <span class="o">=</span> <span class="n">chainerror</span>
                    <span class="n">worst_chainlen</span> <span class="o">=</span> <span class="n">chainlen</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">chainlen</span> <span class="o">//</span> <span class="n">worst_chainlen</span><span class="p">)</span> <span class="o">*</span> <span class="n">worst_chainlen</span><span class="p">)</span> <span class="o">*</span> <span class="n">worst_chainlen_error</span> <span class="o">&gt;=</span> <span class="n">chainlen</span> <span class="o">*</span> <span class="n">chainerror</span><span class="p">:</span>
                        <span class="c1"># assume chainlen = worst_chainlen * k</span>
                        <span class="c1"># if error(worst_chainlen) * k) &gt;= error(chainlen), we ignore chainleb</span>
                        <span class="k">continue</span>

                <span class="n">d</span><span class="p">[</span><span class="n">chainlen</span><span class="p">]</span> <span class="o">=</span> <span class="n">chainerror</span>

            <span class="k">return</span> <span class="n">d</span>

        <span class="n">chainlen2biterror</span> <span class="o">=</span> <span class="n">get_chainlen2biterror</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chainlen2biterror</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">][:</span><span class="n">n</span><span class="p">]</span>

        <span class="n">worst_chainlen</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">chainlen2biterror</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">error_chainlen</span><span class="p">(</span><span class="n">chainlen</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">chainlen2biterror</span><span class="p">[</span><span class="n">chainlen</span><span class="p">]</span> <span class="o">*</span> <span class="n">chainlen</span>

        <span class="k">def</span> <span class="nf">error_decomposition</span><span class="p">(</span><span class="n">decomposition</span><span class="p">):</span>
            <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">chainlen</span> <span class="ow">in</span> <span class="n">decomposition</span><span class="p">:</span>
                <span class="n">error</span> <span class="o">+=</span> <span class="n">error_chainlen</span><span class="p">(</span><span class="n">chainlen</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">error</span>

        <span class="c1"># a prime length correspond to a single chain of maximum error</span>
        <span class="c1"># (decomposing the chain in sub-chains do not increase the error)</span>
        <span class="n">prime_lens</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">worst_chainlen</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">prime_lens</span><span class="p">:</span>
            <span class="n">prime_lens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">worst_chainlen</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">get_decompositions</span><span class="p">(</span><span class="n">diff_len</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">diff_len</span> <span class="ow">in</span> <span class="n">prime_lens</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[[</span><span class="n">diff_len</span><span class="p">]]</span>  <span class="c1"># trivial decomposition</span>

            <span class="n">diff_decompositions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">prime_lens</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">diff_len</span><span class="p">:</span>
                    <span class="n">m_decompositions</span> <span class="o">=</span> <span class="n">get_decompositions</span><span class="p">(</span><span class="n">diff_len</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">decomp</span> <span class="ow">in</span> <span class="n">m_decompositions</span><span class="p">:</span>
                        <span class="n">diff_decompositions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">m</span><span class="p">]</span> <span class="o">+</span> <span class="n">decomp</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">diff_decompositions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">m</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">diff_decompositions</span>

        <span class="n">difflen2differror</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="n">difflen2differror</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error_chainlen</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;chainlen2biterror:&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">chainlen2biterror</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;worst_chainlen:&quot;</span><span class="p">,</span> <span class="n">worst_chainlen</span><span class="p">)</span>
            <span class="c1"># print(&quot;maxchain:&quot;, maxchain)</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">difflen</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">difflen</span> <span class="o">%</span> <span class="n">worst_chainlen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">difflen2differror</span><span class="p">[</span><span class="n">difflen</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">difflen</span> <span class="o">//</span> <span class="n">worst_chainlen</span><span class="p">)</span> <span class="o">*</span> <span class="n">error_chainlen</span><span class="p">(</span><span class="n">worst_chainlen</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">decompositions</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="n">difflen</span> <span class="ow">in</span> <span class="n">chainlen2biterror</span><span class="p">:</span>
                <span class="n">decompositions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">difflen</span><span class="p">])</span>

            <span class="n">decompositions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">get_decompositions</span><span class="p">(</span><span class="n">difflen</span><span class="p">))</span>
            <span class="n">worst_decomp</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">decompositions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">error_decomposition</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">worst_decomp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">difflen</span><span class="p">:</span>
                <span class="n">prime_lens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">difflen</span><span class="p">)</span>

            <span class="c1"># noinspection PyTypeChecker</span>
            <span class="n">difflen2differror</span><span class="p">[</span><span class="n">difflen</span><span class="p">]</span> <span class="o">=</span> <span class="n">error_decomposition</span><span class="p">(</span><span class="n">worst_decomp</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &gt; difflen:&quot;</span><span class="p">,</span> <span class="n">difflen</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &gt; decompositions:&quot;</span><span class="p">,</span> <span class="n">decompositions</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &gt; worst_decomp:&quot;</span><span class="p">,</span> <span class="n">worst_decomp</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; &gt; difflen2differror[</span><span class="si">{}</span><span class="s2">]: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">difflen</span><span class="p">,</span> <span class="n">difflen2differror</span><span class="p">[</span><span class="n">difflen</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">prime_lens:&quot;</span><span class="p">,</span> <span class="n">prime_lens</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;difflen2differror:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">difflen2differror</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">difflen2differror</span>

<div class="viewcode-block" id="XorModelBvAddCt.error"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvAddCt.error">[docs]</a>    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum difference between `OpModel.weight_constraint` and the exact weight.</span>

<span class="sd">            &gt;&gt;&gt; # docstring for debugging purposes</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvAddCt, make_partial_op_model</span>
<span class="sd">            &gt;&gt;&gt; old_prec = XorModelBvAddCt.precision</span>
<span class="sd">            &gt;&gt;&gt; prec2error = {}</span>
<span class="sd">            &gt;&gt;&gt; n = 8</span>
<span class="sd">            &gt;&gt;&gt; for p in range(0, 8 + 1):</span>
<span class="sd">            ...     XorModelBvAddCt.precision = p</span>
<span class="sd">            ...     XorModelBvAdd_1 = make_partial_op_model(XorModelBvAddCt, (None, Constant(1, n)))</span>
<span class="sd">            ...     alpha = XorDiff(Variable(&quot;a&quot;, n))</span>
<span class="sd">            ...     f = XorModelBvAdd_1(alpha)</span>
<span class="sd">            ...     prec2error[p] = round(f.error(), 4)</span>
<span class="sd">            &gt;&gt;&gt; XorModelBvAddCt.precision = old_prec</span>
<span class="sd">            &gt;&gt;&gt; # error depending on the precision (fractional bits)</span>
<span class="sd">            &gt;&gt;&gt; prec2error  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            {0: Decimal(&#39;2.0000&#39;), 1: Decimal(&#39;0.6710&#39;), 2: Decimal(&#39;0.3350&#39;), 3: Decimal(&#39;0.2100&#39;),</span>
<span class="sd">            4: Decimal(&#39;0.1721&#39;), 5: Decimal(&#39;0.1721&#39;), 6: Decimal(&#39;0.1721&#39;), 7: Decimal(&#39;0.1721&#39;), 8: Decimal(&#39;0.1721&#39;)}</span>

<span class="sd">        See also `abstractproperty.opmodel.OpModel.error`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">effective_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_width</span>

        <span class="n">len2error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_len2error</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ct</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">effective_precision</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">effective_width</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">len2error</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">len2error</span><span class="p">[</span><span class="n">effective_width</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="XorModelBvSubCt"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.XorModelBvSubCt">[docs]</a><span class="k">class</span> <span class="nc">XorModelBvSubCt</span><span class="p">(</span><span class="n">XorModelBvAddCt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `XorDiff` `PartialOpModel` of modular substraction by a constant.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import XorModelBvSubCt, make_partial_op_model</span>
<span class="sd">        &gt;&gt;&gt; XorModelBvSub_1 = make_partial_op_model(XorModelBvSubCt, (None, Constant(1, 4)))</span>
<span class="sd">        &gt;&gt;&gt; alpha = XorDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = XorModelBvSub_1(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        make_partial_op_model(XorModelBvSubCt, (None, Constant(0b0001, width=4)))(XorDiff(Constant(0b0000, width=4)))</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (6, 4, Decimal(&#39;0.08607133205593431&#39;), 1)</span>

<span class="sd">    The differential model of the modular substraction by a constant</span>
<span class="sd">    is the same as `XorModelBvAddCt` since ``~(x - c) = ~x + c``</span>
<span class="sd">    and `BvNot` preserves differences.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span>
    <span class="n">base_op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvSub</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_diff</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> only supports the 2nd operand fixed&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_diff</span><span class="p">)</span></div>


<span class="c1"># ---------------------</span>
<span class="c1"># ----- RX models -----</span>
<span class="c1"># ---------------------</span>


<div class="viewcode-block" id="RXModelId"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelId">[docs]</a><span class="k">class</span> <span class="nc">RXModelId</span><span class="p">(</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">ModelIdentity</span><span class="p">,</span> <span class="n">OpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `RXDiff` `differential.opmodel.OpModel` of `BvIdentity`.</span>

<span class="sd">    See also `ModelIdentity`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import RXModelId</span>
<span class="sd">        &gt;&gt;&gt; alpha, beta = RXDiff(Variable(&quot;a&quot;, 4)), RXDiff(Variable(&quot;b&quot;, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = RXModelId(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        RXModelId(RXDiff(Variable(&#39;a&#39;, width=4)))</span>
<span class="sd">        &gt;&gt;&gt; f.validity_constraint(beta)</span>
<span class="sd">        a == b</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(x).val.doit()  # f(x + alpha) - f(x)</span>
<span class="sd">        Id(a)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (0, 1, 0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span></div>


<div class="viewcode-block" id="RXModelBvAdd"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd">[docs]</a><span class="k">class</span> <span class="nc">RXModelBvAdd</span><span class="p">(</span><span class="n">OpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `RXDiff` `differential.opmodel.OpModel` of `BvAdd`.</span>

<span class="sd">    The class attribute ``precision`` sets how many fraction bits</span>
<span class="sd">    are used in the bit-vector weight. The default value of ``precision``</span>
<span class="sd">    is ``3``, and lower values lead to shorter formulas with higher errors.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvAdd</span>
<span class="sd">        &gt;&gt;&gt; alpha = RXDiff(Constant(0, 16)), RXDiff(Constant(0, 16))</span>
<span class="sd">        &gt;&gt;&gt; f = RXModelBvAdd(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        RXModelBvAdd([RXDiff(Constant(0x0000, width=16)), RXDiff(Constant(0x0000, width=16))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 16), Constant(0, 16)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        RXDiff(0x0000)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (136, 8, Decimal(&#39;1.051220727815270622166497531&#39;), 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvAdd</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># 0, 2, 3, 5, 7</span>

<div class="viewcode-block" id="RXModelBvAdd.validity_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd.validity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">validity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the validity constraint for a given output `RXDiff` difference.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvAdd</span>
<span class="sd">            &gt;&gt;&gt; alpha = RXDiff(Constant(0, 4)), RXDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = RXDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f.validity_constraint(beta)</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, b = Variable(&quot;a0&quot;, 4), Variable(&quot;a1&quot;, 4), Variable(&quot;b&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; alpha = RXDiff(a0), RXDiff(a1)</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = RXDiff(b)</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(beta)</span>
<span class="sd">            &gt;&gt;&gt; result  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            (~(((a0[:1]) ^ (a1[:1]) ^ (b[:1]) ^ (((a0[:1]) ^ (a1[:1]) ^ (b[:1])) &lt;&lt; 0b001))[:1]) |</span>
<span class="sd">            ((((a0[:1]) ^ (b[:1])) | ((a1[:1]) ^ (b[:1])))[1:])) == 0b11</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({a0: Constant(0, 4), a1: Constant(0, 4), b: Constant(0, 4)})</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; a1 = Constant(0, 4)</span>
<span class="sd">            &gt;&gt;&gt; alpha = RXDiff(a0), RXDiff(a1)</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; beta = RXDiff(b)</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(beta)</span>
<span class="sd">            &gt;&gt;&gt; result  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            (~(((a0[:1]) ^ (b[:1]) ^ (((a0[:1]) ^ (b[:1])) &lt;&lt; 0b001))[:1]) |</span>
<span class="sd">            ((((a0[:1]) ^ (b[:1])) | (b[:1]))[1:])) == 0b11</span>

<span class="sd">        See `OpModel.validity_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># (I ^ SHL)(da ^ db ^ dc)[1:] &lt;= SHL((da ^ dc) OR (db ^ dc))[1:]</span>

        <span class="c1"># one = core.Constant(1, self.input_diff[0].val.width)  # alt v1</span>

        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="c1"># da, db, dc = alpha &gt;&gt; one, beta &gt;&gt; one, gamma &gt;&gt; one  # alt v1</span>
        <span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">gamma</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># ignore LSB</span>

        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="c1"># lhs = (da ^ db ^ dc) ^ ((da ^ db ^ dc) &lt;&lt; one)  # alt v1</span>
        <span class="c1"># rhs = ((da ^ dc) | (db ^ dc)) &lt;&lt; one</span>
        <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lhs</span> <span class="o">=</span> <span class="p">((</span><span class="n">da</span> <span class="o">^</span> <span class="n">db</span> <span class="o">^</span> <span class="n">dc</span><span class="p">)</span> <span class="o">^</span> <span class="p">((</span><span class="n">da</span> <span class="o">^</span> <span class="n">db</span> <span class="o">^</span> <span class="n">dc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">))[:</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="p">(((</span><span class="n">da</span> <span class="o">^</span> <span class="n">dc</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">db</span> <span class="o">^</span> <span class="n">dc</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">one</span><span class="p">)[:</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">bitwise_implication</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">y</span>

        <span class="c1"># alt v1</span>
        <span class="c1"># n = lhs.width</span>
        <span class="c1"># return operation.BvComp(</span>
        <span class="c1">#     bitwise_implication(lhs[n - 2:1], rhs[n - 2:1]),  # ignore MSB, LSB</span>
        <span class="c1">#     ~ core.Constant(0, n - 2))</span>
        <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">bitwise_implication</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">),</span> <span class="o">~</span><span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lhs</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>  <span class="c1"># alt v1</span></div>

<div class="viewcode-block" id="RXModelBvAdd.pr_one_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd.pr_one_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">pr_one_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the probability-one constraint for a given output `RXDiff`.</span>

<span class="sd">        For `RXModelBvAdd`, any differential has probability less than 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_decimal_weight_rotational_pair_pr</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">pr_rotational_pair</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;0.5&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">log2_decimal</span><span class="p">(</span><span class="n">pr_rotational_pair</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="RXModelBvAdd.bv_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd.bv_weight">[docs]</a>    <span class="k">def</span> <span class="nf">bv_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bit-vector weight for a given output `RXDiff`.</span>

<span class="sd">        See also `abstractproperty.opmodel.OpModel.bv_weight`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># one = core.Constant(1, self.input_diff[0].val.width)  # alt v1</span>
        <span class="c1"># two = core.Constant(2, self.input_diff[0].val.width)</span>

        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">gamma</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># alt v1</span>
        <span class="c1"># da, db, dc = alpha &gt;&gt; one, beta &gt;&gt; one, gamma &gt;&gt; one  # alt v1</span>

        <span class="k">if</span> <span class="n">da</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rhs</span> <span class="o">=</span> <span class="p">((</span><span class="n">da</span> <span class="o">^</span> <span class="n">dc</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">db</span> <span class="o">^</span> <span class="n">dc</span><span class="p">))[</span><span class="n">da</span><span class="o">.</span><span class="n">width</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># equiv to shift left</span>
        <span class="c1"># rhs = ((da ^ dc) | (db ^ dc)) &lt;&lt; two  # alt v1</span>
        <span class="n">hw</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

        <span class="n">max_hw</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">width</span>
        <span class="c1"># max_hw = rhs.width - 1  # alt v1</span>

        <span class="c1"># (max_hw + 3) = maximum integer part</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">precision</span>  <span class="c1"># num fraction bits</span>
        <span class="n">max_ct_part</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># see below ct_part  (without fraction bits)</span>
        <span class="n">weight_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_hw</span> <span class="o">+</span> <span class="n">max_ct_part</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">+</span> <span class="n">k</span>

        <span class="c1"># let lhs = LSB(lhs) = da ^ db ^ dc</span>
        <span class="c1">#     rhs = LSB(rhs) = 0</span>
        <span class="c1"># case A (w=1.415): lhs =&gt; rhs</span>
        <span class="c1"># case B (w=3):     lhs ^ 1 =&gt; rhs</span>

        <span class="c1"># 1.415 = -log2(pr propagation of a rotational pair with offset 1)</span>
        <span class="c1">#   this Pr is (1 + 2^(1−n) + 2^(-1) + 2^(−n))/4.</span>
        <span class="c1">#   (source Rotational Cryptanalysis in the Presence of Constants)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">width</span>
        <span class="n">w_rotational_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decimal_weight_rotational_pair_pr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># take k fraction bits, remove other fraction bits and convert the result to an integer</span>
        <span class="n">w_rotational_pair</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">w_rotational_pair</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">bitwise_implication</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">y</span>

        <span class="n">ct_part_extend</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">Ite</span><span class="p">(</span>
            <span class="n">bitwise_implication</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">dc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="n">w_rotational_pair</span><span class="p">,</span> <span class="n">weight_width</span><span class="p">),</span>
            <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">weight_width</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">k</span>
        <span class="p">)</span>

        <span class="n">hw_extend</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">zero_extend</span><span class="p">(</span><span class="n">hw</span><span class="p">,</span> <span class="n">weight_width</span> <span class="o">-</span> <span class="n">hw</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">hw_extend</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="n">ct_part_extend</span></div>

<div class="viewcode-block" id="RXModelBvAdd.weight_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd.weight_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">weight_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weight constraint for a given output `RXDiff` and weight `Variable`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvAdd</span>
<span class="sd">            &gt;&gt;&gt; n = 4</span>
<span class="sd">            &gt;&gt;&gt; alpha = RXDiff(Constant(0, n)), RXDiff(Constant(0, n))</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; w = Variable(&quot;w&quot;, f.weight_width())</span>
<span class="sd">            &gt;&gt;&gt; f.weight_constraint(RXDiff(Constant(0, n)), w)</span>
<span class="sd">            w == 0b001001</span>
<span class="sd">            &gt;&gt;&gt; a0, a1, b = Variable(&quot;a0&quot;, n), Variable(&quot;a1&quot;, n), Variable(&quot;b&quot;, n)</span>
<span class="sd">            &gt;&gt;&gt; alpha = RXDiff(a0), RXDiff(a1)</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; result = f.weight_constraint(RXDiff(b), w)</span>
<span class="sd">            &gt;&gt;&gt; result  # doctest:+NORMALIZE_WHITESPACE</span>
<span class="sd">            w == (((0x0 :: PopCount((((a0[:1]) ^ (b[:1])) | ((a1[:1]) ^ (b[:1])))[1:])) &lt;&lt; 0b000011) +</span>
<span class="sd">            (Ite(~((a0[1]) ^ (a1[1]) ^ (b[1])), 0b001001, 0b011000)))</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({a0: Constant(0, n), a1: Constant(0, n), b: Constant(0, n)})</span>
<span class="sd">            w == 0b001001</span>

<span class="sd">        See `OpModel.weight_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">weight_constraint</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">)</span></div>

<div class="viewcode-block" id="RXModelBvAdd.max_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd.max_weight">[docs]</a>    <span class="k">def</span> <span class="nf">max_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># can be obtained from (hw_extend &lt;&lt; k) + ct_part_extend</span>
        <span class="n">alpha_da_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">max_hw</span> <span class="o">=</span> <span class="n">alpha_da_width</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_hw</span> <span class="o">=</span> <span class="n">alpha_da_width</span> <span class="o">-</span> <span class="mi">2</span>  <span class="c1"># alpha[:1] and [da.width-2:]</span>
        <span class="n">max_ct_part</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">precision</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">max_hw</span> <span class="o">+</span> <span class="n">max_ct_part</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">k</span></div>

<div class="viewcode-block" id="RXModelBvAdd.weight_width"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd.weight_width">[docs]</a>    <span class="k">def</span> <span class="nf">weight_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># can be obtained from the variable weight_width in bv_weight</span>
        <span class="n">alpha_da_width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">max_hw</span> <span class="o">=</span> <span class="n">alpha_da_width</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_hw</span> <span class="o">=</span> <span class="n">alpha_da_width</span> <span class="o">-</span> <span class="mi">2</span>  <span class="c1"># alpha[:1] and [da.width-2:]</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">precision</span>
        <span class="n">max_ct_part</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">weight_width</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_hw</span> <span class="o">+</span> <span class="n">max_ct_part</span><span class="p">)</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">+</span> <span class="n">k</span>
        <span class="k">return</span> <span class="n">weight_width</span></div>

<div class="viewcode-block" id="RXModelBvAdd.decimal_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd.decimal_weight">[docs]</a>    <span class="k">def</span> <span class="nf">decimal_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the `decimal.Decimal` weight for a given constant output `RXDiff`.</span>

<span class="sd">        The decimal weight is not equal to the exact weight due to the</span>
<span class="sd">        approximation used for the probability of the rotational pair.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvAdd</span>
<span class="sd">            &gt;&gt;&gt; n = 4</span>
<span class="sd">            &gt;&gt;&gt; alpha = RXDiff(Constant(0, n)), RXDiff(Constant(0, n))</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvAdd(alpha)</span>
<span class="sd">            &gt;&gt;&gt; int(f.bv_weight(RXDiff(Constant(0, n)))) / 2**(f.precision)</span>
<span class="sd">            1.125</span>
<span class="sd">            &gt;&gt;&gt; f.decimal_weight(RXDiff(Constant(0, n)))</span>
<span class="sd">            Decimal(&#39;1.245112497836531455638783168&#39;)</span>

<span class="sd">        See also `abstractproperty.opmodel.OpModel.decimal_weight`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_preconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)</span>

        <span class="c1"># in this case, the decimal_weight is not always smaller than the bit-vector weight</span>
        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">val</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">dc</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">gamma</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">one</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">da</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>

        <span class="n">rhs</span> <span class="o">=</span> <span class="p">((</span><span class="n">da</span> <span class="o">^</span> <span class="n">dc</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">db</span> <span class="o">^</span> <span class="n">dc</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">one</span>
        <span class="c1"># rhs = ((da ^ dc) | (db ^ dc))[da.width-2:]  # alt v1</span>
        <span class="n">hw</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">PopCount</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">bitwise_implication</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span><span class="p">)</span> <span class="o">|</span> <span class="n">y</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">.</span><span class="n">width</span>
        <span class="n">w_rotational_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decimal_weight_rotational_pair_pr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bitwise_implication</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">^</span> <span class="n">dc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">w_rotational_pair</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="mi">3</span>

        <span class="c1"># print(&quot;\n\n ~~ &quot;)</span>
        <span class="c1"># print(&quot;self:         &quot;, self)</span>
        <span class="c1"># print(&quot;output diff:  &quot;, output_diff)</span>
        <span class="c1"># print(&quot;da:           &quot;, da.bin())</span>
        <span class="c1"># print(&quot;db:           &quot;, db.bin())</span>
        <span class="c1"># print(&quot;dc:           &quot;, dc.bin())</span>
        <span class="c1"># print(&quot;rhs:          &quot;, rhs.bin())</span>
        <span class="c1"># print(&quot;hw:           &quot;, int(hw))</span>
        <span class="c1"># print(&quot;bw_implies:   &quot;, bitwise_implication(da[0] ^ db[0] ^ dc[0], core.Constant(0, 1)).bin())</span>
        <span class="c1"># print(&quot;result:       &quot;, result)</span>
        <span class="c1"># print(&quot;\n\n&quot;)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_postconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="RXModelBvAdd.num_frac_bits"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd.num_frac_bits">[docs]</a>    <span class="k">def</span> <span class="nf">num_frac_bits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">precision</span></div>

<div class="viewcode-block" id="RXModelBvAdd.error"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAdd.error">[docs]</a>    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_error_decimal2exact</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the maximum difference between `OpModel.weight_constraint` and the exact weight.</span>

<span class="sd">            &gt;&gt;&gt; # docstring for debugging purposes</span>
<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvAdd</span>
<span class="sd">            &gt;&gt;&gt; old_prec = RXModelBvAdd.precision</span>
<span class="sd">            &gt;&gt;&gt; prec2error = {}</span>
<span class="sd">            &gt;&gt;&gt; n = 16</span>
<span class="sd">            &gt;&gt;&gt; for p in range(0, 8 + 1):</span>
<span class="sd">            ...     RXModelBvAdd.precision = p</span>
<span class="sd">            ...     alpha = RXDiff(Variable(&quot;a&quot;, n)), RXDiff(Variable(&quot;b&quot;, n))</span>
<span class="sd">            ...     f = RXModelBvAdd(alpha)</span>
<span class="sd">            ...     prec2error[p] = round(float(f.error()), 4)</span>
<span class="sd">            &gt;&gt;&gt; RXModelBvAdd.precision = old_prec</span>
<span class="sd">            &gt;&gt;&gt; prec2error  # error depending on the precision (fractional bits)</span>
<span class="sd">            {0: 1.4262, 1: 1.4262, 2: 1.1762, 3: 1.0512, 4: 1.0512, 5: 1.02, 6: 1.02, 7: 1.0122, 8: 1.0122}</span>

<span class="sd">        See also `abstractproperty.opmodel.OpModel.error`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">width</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">precision</span>

        <span class="n">w_rotational_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decimal_weight_rotational_pair_pr</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="n">w_rotational_pair_approx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">w_rotational_pair</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="p">))</span> <span class="o">/</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># w_rotational_pair_approx &lt; w_rotational_pair</span>
        <span class="k">assert</span> <span class="n">w_rotational_pair_approx</span> <span class="o">&lt;</span> <span class="n">w_rotational_pair</span>
        <span class="n">bv2decimalerror</span> <span class="o">=</span> <span class="n">w_rotational_pair</span> <span class="o">-</span> <span class="n">w_rotational_pair_approx</span>

        <span class="k">if</span> <span class="n">ignore_error_decimal2exact</span><span class="p">:</span>
            <span class="n">decimal2exact_error</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># found empirically with test_opmodel.py</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">decimal2exact_error</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1.584962500721156181453738944&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">decimal2exact_error</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1.321928094887362347870319428&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="c1"># found for n=4 with 10000 examples</span>
                <span class="n">decimal2exact_error</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1.169925001442312362907477888&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># found for n=8 with 10000 examples</span>
                <span class="n">decimal2exact_error</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="s2">&quot;1.011227255423254120337880584&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bv2decimalerror</span> <span class="o">+</span> <span class="n">decimal2exact_error</span></div></div>


<div class="viewcode-block" id="RXModelBvSub"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvSub">[docs]</a><span class="k">class</span> <span class="nc">RXModelBvSub</span><span class="p">(</span><span class="n">RXModelBvAdd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `RXDiff` `differential.opmodel.OpModel` of `BvSub`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvSub</span>
<span class="sd">        &gt;&gt;&gt; alpha = RXDiff(Constant(0, 16)), RXDiff(Constant(0, 16))</span>
<span class="sd">        &gt;&gt;&gt; f = RXModelBvSub(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        RXModelBvSub([RXDiff(Constant(0x0000, width=16)), RXDiff(Constant(0x0000, width=16))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 16), Constant(0, 16)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        RXDiff(0x0000)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (136, 8, Decimal(&#39;1.051220727815270622166497531&#39;), 3)</span>

<span class="sd">    The differential model of the modular substraction is the same as `RXModelBvAdd`</span>
<span class="sd">    since ``~(x - y) == ~x + y`` (and `BvNot` preserves RX-differences).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvSub</span></div>


<div class="viewcode-block" id="RXModelBvOr"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvOr">[docs]</a><span class="k">class</span> <span class="nc">RXModelBvOr</span><span class="p">(</span><span class="n">XorModelBvOr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `RXDiff` `differential.opmodel.OpModel` of `BvOr`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvOr</span>
<span class="sd">        &gt;&gt;&gt; alpha = RXDiff(Constant(0, 4)), RXDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = RXModelBvOr(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        RXModelBvOr([RXDiff(Constant(0b0000, width=4)), RXDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        RXDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (4, 3, 0, 0)</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        For any bitwise operation, (w.l.o.g, unary op f(x))</span>
<span class="sd">        ``Pr( RXDiff(d) propagates through f to RXDiff(d&#39;) ) =</span>
<span class="sd">        Pr( Diff(d) propagates through f to Diff(d&#39;) )``, where</span>
<span class="sd">        ``RXDiff(d) = RXDiff.from_pair(x, RotateLeft(x, 1) ^ d)``</span>

<span class="sd">        This comes from</span>
<span class="sd">        ``Pr[((x &amp; y) &lt;&lt;&lt; 1) ^ beta = ((x &lt;&lt;&lt; 1) ^ alpha1) &amp; ((y &lt;&lt;&lt; 1) ^ alpha2)] =</span>
<span class="sd">        Pr[(x &amp; y) ^ beta = (x ^ alpha1) &amp; (y ^ alpha2)]``, where</span>
<span class="sd">        ``alpha=d`` is the input diff and beta=d&#39; the output diff</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvOr</span></div>


<div class="viewcode-block" id="RXModelBvAnd"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvAnd">[docs]</a><span class="k">class</span> <span class="nc">RXModelBvAnd</span><span class="p">(</span><span class="n">RXModelBvOr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `RXDiff` `differential.opmodel.OpModel` of `BvAnd`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvAnd</span>
<span class="sd">        &gt;&gt;&gt; alpha = RXDiff(Constant(0, 4)), RXDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = RXModelBvAnd(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        RXModelBvAnd([RXDiff(Constant(0b0000, width=4)), RXDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        RXDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (4, 3, 0, 0)</span>

<span class="sd">    The differential model of `BvAnd` is the same as `RXModelBvOr`</span>
<span class="sd">    since ``~(x &amp; y) == ~x | ~y`` (and `BvNot` preserves differences).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvAnd</span></div>


<div class="viewcode-block" id="RXModelBvIf"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvIf">[docs]</a><span class="k">class</span> <span class="nc">RXModelBvIf</span><span class="p">(</span><span class="n">XorModelBvIf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `RXDiff` `differential.opmodel.OpModel` of `BvIf`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvIf</span>
<span class="sd">        &gt;&gt;&gt; alpha = RXDiff(Constant(0, 4)), RXDiff(Constant(0, 4)), RXDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = RXModelBvIf(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        RXModelBvIf([RXDiff(Constant(0b0000, width=4)), RXDiff(Constant(0b0000, width=4)), RXDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        RXDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (4, 3, 0, 0)</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        See `RXModelBvOr`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">BvIf</span></div>


<div class="viewcode-block" id="RXModelBvMaj"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvMaj">[docs]</a><span class="k">class</span> <span class="nc">RXModelBvMaj</span><span class="p">(</span><span class="n">XorModelBvMaj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `RXDiff` `differential.opmodel.OpModel` of `BvMaj`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvMaj</span>
<span class="sd">        &gt;&gt;&gt; alpha = RXDiff(Constant(0, 4)), RXDiff(Constant(0, 4)), RXDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = RXModelBvMaj(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        RXModelBvMaj([RXDiff(Constant(0b0000, width=4)), RXDiff(Constant(0b0000, width=4)), RXDiff(Constant(0b0000, width=4))])</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4), Constant(0, 4), Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(*x)  # f(x + alpha) - f(x)</span>
<span class="sd">        RXDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (4, 3, 0, 0)</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        See `RXModelBvOr`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">secondaryop</span><span class="o">.</span><span class="n">BvMaj</span></div>


<div class="viewcode-block" id="RXModelBvShlCt"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt">[docs]</a><span class="k">class</span> <span class="nc">RXModelBvShlCt</span><span class="p">(</span><span class="n">PartialOpModel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `RXDiff` `PartialOpModel` of left shift by a constant.</span>

<span class="sd">    This class is not meant to be instantiated but to provide a base</span>
<span class="sd">    class for subclasses generated through `make_partial_op_model`.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvShlCt, make_partial_op_model</span>
<span class="sd">        &gt;&gt;&gt; RXModelBvShlCte_1 = make_partial_op_model(RXModelBvShlCt, (None, Constant(1, 4)))</span>
<span class="sd">        &gt;&gt;&gt; alpha = RXDiff(Constant(0, 4))</span>
<span class="sd">        &gt;&gt;&gt; f = RXModelBvShlCte_1(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        make_partial_op_model(RXModelBvShlCt, (None, Constant(0b0001, width=4)))(RXDiff(Constant(0b0000, width=4)))</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 4)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(x)  # f(x + alpha) - f(x)</span>
<span class="sd">        RXDiff(0x0)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (2, 2, 0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">diff_type</span> <span class="o">=</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span>
    <span class="n">base_op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvShl</span>
    <span class="c1"># op is a set through make_partial_op_model</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_diff</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> need to be given to make_partial_op_model&quot;</span>
                             <span class="sa">f</span><span class="s2">&quot; to get the OpModel for the particular fixed operand&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> only supports the 2nd operand fixed&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">input_diff</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The constant operand.&quot;&quot;&quot;</span>
        <span class="n">my_ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">fixed_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">my_ct</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">my_ct</span> <span class="o">&lt;</span> <span class="n">my_ct</span><span class="o">.</span><span class="n">width</span>
        <span class="k">return</span> <span class="n">my_ct</span>

<div class="viewcode-block" id="RXModelBvShlCt.validity_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt.validity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">validity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the validity constraint for a given output `RXDiff` difference.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvShlCt, make_partial_op_model</span>
<span class="sd">            &gt;&gt;&gt; RXModelBvShlCte_1 = make_partial_op_model(RXModelBvShlCt, (None, Constant(1, 4)))</span>
<span class="sd">            &gt;&gt;&gt; alpha = RXDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvShlCte_1(alpha)</span>
<span class="sd">            &gt;&gt;&gt; f.validity_constraint(RXDiff(Constant(0, 4)))</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; u, v = Variable(&quot;u&quot;, 4), Variable(&quot;v&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvShlCte_1(RXDiff(u))</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(RXDiff(v))</span>
<span class="sd">            &gt;&gt;&gt; result  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            (v[:2]) == (u &lt;&lt; 0x1[:2])</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({u: Constant(0, 4), v: Constant(0, 4)})</span>
<span class="sd">            0b1</span>

<span class="sd">        See `OpModel.validity_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># consider a pair (x, (x &lt;&lt;&lt; 1) ^ d) with RXDiff d</span>
        <span class="c1"># if the operation &lt;&lt;_s is applied to the pair we obtain:</span>
        <span class="c1">#   x              |-&gt; x &lt;&lt; s</span>
        <span class="c1">#   (x &lt;&lt;&lt; 1) ^ d  |-&gt; ((x &lt;&lt;&lt; 1) &lt;&lt; s) ^ (d &lt;&lt; s)</span>
        <span class="c1"># and the output RXDiff beta of these two last term is</span>
        <span class="c1">#   beta = RXDiff(·, ·) = ((x &lt;&lt; s) &lt;&lt;&lt; 1) ^ ((x &lt;&lt;&lt; 1) &lt;&lt; s) ^ (d &lt;&lt; s)</span>
        <span class="c1"># it is easy to see that</span>
        <span class="c1">#   ((x &lt;&lt; s) &lt;&lt;&lt; 1) ^ ((x &lt;&lt;&lt; 1) &lt;&lt; s) = 0 ··· 0 x_{s-1} 0 ··· 0 x_{n-1}</span>
        <span class="c1"># where there are (s-1) zeros in the right part, that is,</span>
        <span class="c1"># the non-zero bits are in position 0 and position s; thus,</span>
        <span class="c1">#   beta = (0 ··· 0 x_{s-1} 0 ··· 0 x_{n-1}) ^ (d &lt;&lt; s)</span>
        <span class="c1"># meaning that beta is equal to (d &lt;&lt; s) except in position 0 and s</span>
        <span class="c1"># where it can take arbitrary values</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
        <span class="n">d_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># d &lt;&lt; s</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ct</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">width</span>

        <span class="n">true_bv</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># no zeros on the right side</span>
            <span class="c1"># beta[:n] out of range</span>
            <span class="k">return</span> <span class="n">true_bv</span> <span class="k">if</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="k">else</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">beta</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_s</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># no zeros on the left side</span>
            <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_s</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">true_bv</span> <span class="k">if</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="k">else</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">beta</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_s</span><span class="p">[:</span><span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">beta</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_s</span><span class="p">[</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">aux</span></div>

<div class="viewcode-block" id="RXModelBvShlCt.pr_one_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt.pr_one_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">pr_one_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the probability-one constraint for a given output `RXDiff`.</span>

<span class="sd">        For `RXModelBvShlCt`, any differential has probability less than 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="RXModelBvShlCt.bv_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt.bv_weight">[docs]</a>    <span class="k">def</span> <span class="nf">bv_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bit-vector weight for a given output `RXDiff`.</span>

<span class="sd">        For `RXModelBvShlCt`, any valid differential has weight 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if the RX differential over &lt;&lt;_s has non-zero probability,</span>
        <span class="c1"># then its weight is 2*t where t = min(1, s, n - 1, n - s) = 1</span>
        <span class="c1"># (weight is independent of output difference)</span>
        <span class="c1"># Source: P.Sokołowski, &quot;Design and Analysis of Cryptographic Hash Functions&quot;</span>
        <span class="c1"># (page 35) https:// hdl.handle.net / 10593 / 19267</span>
        <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="RXModelBvShlCt.weight_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt.weight_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">weight_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the weight constraint for a given output `RXDiff` and weight `Variable`.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvShlCt, make_partial_op_model</span>
<span class="sd">            &gt;&gt;&gt; width = 4</span>
<span class="sd">            &gt;&gt;&gt; RXModelBvShlCte_1 = make_partial_op_model(RXModelBvShlCt, (None, Constant(1, width)))</span>
<span class="sd">            &gt;&gt;&gt; alpha = RXDiff(Variable(&quot;u&quot;, width))</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvShlCte_1(alpha)</span>
<span class="sd">            &gt;&gt;&gt; w = Variable(&quot;w&quot;, f.weight_width())</span>
<span class="sd">            &gt;&gt;&gt; beta = RXDiff(Variable(&quot;v&quot;, width))</span>
<span class="sd">            &gt;&gt;&gt; f.weight_constraint(beta, w)</span>
<span class="sd">            w == 0b10</span>

<span class="sd">        See `OpModel.weight_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">weight_constraint</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">weight_variable</span><span class="p">)</span></div>

<div class="viewcode-block" id="RXModelBvShlCt.max_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt.max_weight">[docs]</a>    <span class="k">def</span> <span class="nf">max_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="RXModelBvShlCt.weight_width"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt.weight_width">[docs]</a>    <span class="k">def</span> <span class="nf">weight_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="RXModelBvShlCt.decimal_weight"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt.decimal_weight">[docs]</a>    <span class="k">def</span> <span class="nf">decimal_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_preconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)</span>
        <span class="n">dw</span> <span class="o">=</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bv_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_postconditions_decimal_weight</span><span class="p">(</span><span class="n">output_diff</span><span class="p">,</span> <span class="n">dw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dw</span></div>

<div class="viewcode-block" id="RXModelBvShlCt.num_frac_bits"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt.num_frac_bits">[docs]</a>    <span class="k">def</span> <span class="nf">num_frac_bits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="RXModelBvShlCt.error"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvShlCt.error">[docs]</a>    <span class="k">def</span> <span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="RXModelBvLshrCt"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvLshrCt">[docs]</a><span class="k">class</span> <span class="nc">RXModelBvLshrCt</span><span class="p">(</span><span class="n">RXModelBvShlCt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represent the `RXDiff` `PartialOpModel` of right shift by a constant.</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvLshrCt, make_partial_op_model</span>
<span class="sd">        &gt;&gt;&gt; RXModelBvLshrCte_1 = make_partial_op_model(RXModelBvLshrCt, (None, Constant(1, 8)))</span>
<span class="sd">        &gt;&gt;&gt; alpha = RXDiff(Constant(0, 8))</span>
<span class="sd">        &gt;&gt;&gt; f = RXModelBvLshrCte_1(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        make_partial_op_model(RXModelBvLshrCt, (None, Constant(0b00000001, width=8)))(RXDiff(Constant(0b00000000, width=8)))</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 8)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(x)  # f(x + alpha) - f(x)</span>
<span class="sd">        RXDiff(0x00)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (2, 2, 0, 0)</span>

<span class="sd">    .. Implementation details:</span>

<span class="sd">        See `RXModelBvShlCt`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">base_op</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvLshr</span>

<div class="viewcode-block" id="RXModelBvLshrCt.validity_constraint"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.RXModelBvLshrCt.validity_constraint">[docs]</a>    <span class="k">def</span> <span class="nf">validity_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_diff</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the validity constraint for a given output `RXDiff` difference.</span>

<span class="sd">            &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">            &gt;&gt;&gt; from cascada.differential.opmodel import RXModelBvLshrCt, make_partial_op_model</span>
<span class="sd">            &gt;&gt;&gt; RXModelBvLshrCte_1 = make_partial_op_model(RXModelBvLshrCt, (None, Constant(1, 4)))</span>
<span class="sd">            &gt;&gt;&gt; alpha = RXDiff(Constant(0, 4))</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvLshrCte_1(alpha)</span>
<span class="sd">            &gt;&gt;&gt; f.validity_constraint(RXDiff(Constant(0, 4)))</span>
<span class="sd">            0b1</span>
<span class="sd">            &gt;&gt;&gt; u, v = Variable(&quot;u&quot;, 4), Variable(&quot;v&quot;, 4)</span>
<span class="sd">            &gt;&gt;&gt; f = RXModelBvLshrCte_1(RXDiff(u))</span>
<span class="sd">            &gt;&gt;&gt; result = f.validity_constraint(RXDiff(v))</span>
<span class="sd">            &gt;&gt;&gt; result  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            (v[2:1]) == (u &gt;&gt; 0x1[2:1])</span>
<span class="sd">            &gt;&gt;&gt; result.xreplace({u: Constant(0, 4), v: Constant(0, 4)})</span>
<span class="sd">            0b1</span>

<span class="sd">        See `OpModel.validity_constraint` for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># consider a pair (x, (x &lt;&lt;&lt; 1) ^ d) with RXDiff d</span>
        <span class="c1"># if the operation &gt;&gt;_s is applied to the pair we obtain:</span>
        <span class="c1">#   x              |-&gt; x &gt;&gt; s</span>
        <span class="c1">#   (x &lt;&lt;&lt; 1) ^ d  |-&gt; ((x &lt;&lt;&lt; 1) &gt;&gt; s) ^ (d &gt;&gt; s)</span>
        <span class="c1"># and the output RXDiff beta of these two last term is</span>
        <span class="c1">#   beta = RXDiff(·, ·) = ((x &gt;&gt; s) &lt;&lt;&lt; 1) ^ ((x &lt;&lt;&lt; 1) &gt;&gt; s) ^ (d &gt;&gt; s)</span>
        <span class="c1"># it is easy to see that for</span>
        <span class="c1">#   ((x &gt;&gt; s) &lt;&lt;&lt; 1) ^ ((x &lt;&lt;&lt; 1) &gt;&gt; s)</span>
        <span class="c1"># the non-zero bits are in position 0 and position n-s; thus,</span>
        <span class="c1"># beta is equal to (d &gt;&gt; s) except in position 0 and n-s</span>
        <span class="c1"># where it can take arbitrary values</span>

        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">val</span>
        <span class="n">d_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">op</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  <span class="c1"># d &lt;&lt; s</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">output_diff</span><span class="o">.</span><span class="n">val</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ct</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">width</span>

        <span class="n">true_bv</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># similar to RXModelBvShlCt but replacing s by n-s</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># beta[:(n-s)+1] out of range</span>
            <span class="k">return</span> <span class="n">true_bv</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="k">else</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">beta</span><span class="p">[:(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_s</span><span class="p">[:(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">beta</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_s</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">true_bv</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">n</span> <span class="k">else</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">beta</span><span class="p">[:(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_s</span><span class="p">[:(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">BvComp</span><span class="p">(</span><span class="n">beta</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">],</span> <span class="n">d_s</span><span class="p">[(</span><span class="n">n</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">aux</span></div></div>


<span class="c1"># --------------------------</span>


<div class="viewcode-block" id="get_weak_model"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.get_weak_model">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># temporary hack to create singletons</span>
<span class="k">def</span> <span class="nf">get_weak_model</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">diff_type</span><span class="p">,</span> <span class="n">nonzero2nonzero_weight</span><span class="p">,</span> <span class="n">zero2zero_weight</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">zero2nonzero_weight</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">nonzero2zero_weight</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the weak model of the given bit-vector operation ``op``.</span>

<span class="sd">    Given the `Operation` ``op``, return the</span>
<span class="sd">    `WeakModel` of ``op`` for the `Difference` type ``diff_type``</span>
<span class="sd">    with given class attributes ``nonzero2nonzero_weight``,</span>
<span class="sd">    ``zero2zero_weight``,</span>
<span class="sd">    ``zero2nonzero_weight``, ``nonzero2zero_weight`` and</span>
<span class="sd">    ``precision`` (see `WeakModel`).</span>

<span class="sd">    The returned model is a subclass of `WeakModel` and `OpModel`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        To link the returned model ``MyModel`` to ``op``</span>
<span class="sd">        such that ``MyModel`` is used in ``propagate``,</span>
<span class="sd">        set the ``xor_model`` or ``rx_model`` attribute of ``op``</span>
<span class="sd">        to ``MyModel`` (e.g., ``op.xor_model = MyModel``).</span>
<span class="sd">        See also  `differential.difference.XorDiff.propagate`</span>
<span class="sd">        or `differential.difference.RXDiff.propagate`.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.secondaryop import LutOperation</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import get_weak_model</span>
<span class="sd">        &gt;&gt;&gt; class MyLut(LutOperation): pass  # a 2-bit function</span>
<span class="sd">        &gt;&gt;&gt; XorWeakModelMyLut = get_weak_model(MyLut, XorDiff, decimal.Decimal(1.5), precision=1)</span>
<span class="sd">        &gt;&gt;&gt; alpha, beta = XorDiff(Variable(&quot;a&quot;, 2)), XorDiff(Variable(&quot;b&quot;, 2))</span>
<span class="sd">        &gt;&gt;&gt; f = XorWeakModelMyLut(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        XorWeakModelMyLut(XorDiff(Variable(&#39;a&#39;, width=2)))</span>
<span class="sd">        &gt;&gt;&gt; f.validity_constraint(beta)</span>
<span class="sd">        (((a == 0b00) &amp; (b == 0b00)) == 0b1) | ((~(a == 0b00) &amp; ~(b == 0b00)) == 0b1)</span>
<span class="sd">        &gt;&gt;&gt; f.bv_weight(beta)</span>
<span class="sd">        Ite(((a == 0b00) &amp; (b == 0b00)) == 0b1, 0b00, 0b11)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (3, 2, 0, 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">Operation</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;Xor&quot;</span>
        <span class="k">assert</span> <span class="n">zero2zero_weight</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c1"># for XOR differentials with Pr. 1, an input property propagates to a unique output property</span>
        <span class="k">assert</span> <span class="n">zero2nonzero_weight</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">elif</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;RX&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid diff_type </span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">_op</span><span class="p">,</span> <span class="n">_diff_type</span> <span class="o">=</span> <span class="n">op</span><span class="p">,</span> <span class="n">diff_type</span>
    <span class="n">_zero2zero_weight</span> <span class="o">=</span> <span class="n">zero2zero_weight</span>
    <span class="n">_nonzero2nonzero_weight</span> <span class="o">=</span> <span class="n">nonzero2nonzero_weight</span>
    <span class="n">_zero2nonzero_weight</span><span class="p">,</span> <span class="n">_nonzero2zero_weight</span> <span class="o">=</span> <span class="n">zero2nonzero_weight</span><span class="p">,</span> <span class="n">nonzero2zero_weight</span>
    <span class="n">_precision</span> <span class="o">=</span> <span class="n">precision</span>

    <span class="k">class</span> <span class="nc">MyWeakModel</span><span class="p">(</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">WeakModel</span><span class="p">,</span> <span class="n">OpModel</span><span class="p">):</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">diff_type</span> <span class="o">=</span> <span class="n">_op</span><span class="p">,</span> <span class="n">_diff_type</span>
        <span class="n">zero2zero_weight</span> <span class="o">=</span> <span class="n">_zero2zero_weight</span>
        <span class="n">nonzero2nonzero_weight</span> <span class="o">=</span> <span class="n">_nonzero2nonzero_weight</span>
        <span class="n">zero2nonzero_weight</span> <span class="o">=</span> <span class="n">_zero2nonzero_weight</span>
        <span class="n">nonzero2zero_weight</span> <span class="o">=</span> <span class="n">_nonzero2zero_weight</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="n">_precision</span>

        <span class="c1"># def error(self):  # maximum weight of a differential with n-bit input is n</span>
        <span class="c1">#     return sum(p.val.width for p in self.input_prop)</span>

    <span class="n">MyWeakModel</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">WeakModel</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}{</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">MyWeakModel</span></div>


<div class="viewcode-block" id="get_branch_number_model"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.get_branch_number_model">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_branch_number_model</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">diff_type</span><span class="p">,</span> <span class="n">output_widths</span><span class="p">,</span> <span class="n">branch_number</span><span class="p">,</span> <span class="n">nonzero2nonzero_weight</span><span class="p">,</span> <span class="n">zero2zero_weight</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">zero2nonzero_weight</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">nonzero2zero_weight</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the branch-number model of the given bit-vector operation ``op``.</span>

<span class="sd">    Given the `Operation` ``op``, return the `BranchNumberModel`</span>
<span class="sd">    of ``op`` for the `Difference` type ``diff_type`` with given class</span>
<span class="sd">    attributes ``output_widths`` (given as a `tuple`),</span>
<span class="sd">    `branch_number`, ``nonzero2nonzero_weight``,</span>
<span class="sd">    ``zero2zero_weight``, ``zero2nonzero_weight``,</span>
<span class="sd">    ``nonzero2zero_weight`` and ``precision`` (see `BranchNumberModel`).</span>

<span class="sd">    The returned model is a subclass of `BranchNumberModel` and `OpModel`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        To link the returned model ``MyModel`` to ``op``</span>
<span class="sd">        such that ``MyModel`` is used in ``propagate``,</span>
<span class="sd">        set the ``xor_model`` or ``rx_model`` attribute of ``op``</span>
<span class="sd">        to ``MyModel`` (e.g., ``op.xor_model = MyModel``).</span>
<span class="sd">        See also  `differential.difference.XorDiff.propagate`</span>
<span class="sd">        or `differential.difference.RXDiff.propagate`.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.secondaryop import MatrixOperation</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.printing import BvWrapPrinter</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import get_branch_number_model</span>
<span class="sd">        &gt;&gt;&gt; class MyMatrix(MatrixOperation): pass  # a (3, 2) binary matrix</span>
<span class="sd">        &gt;&gt;&gt; RXBranchNumberModelMyMatrix = get_branch_number_model(</span>
<span class="sd">        ...     MyMatrix, RXDiff, (1, 1, 1), 3, nonzero2nonzero_weight=math.inf,</span>
<span class="sd">        ...     zero2zero_weight=math.inf, zero2nonzero_weight=0, nonzero2zero_weight=0)</span>
<span class="sd">        &gt;&gt;&gt; alpha, beta = RXDiff(Variable(&quot;a&quot;, 2)), RXDiff(Variable(&quot;b&quot;, 3))</span>
<span class="sd">        &gt;&gt;&gt; f = RXBranchNumberModelMyMatrix(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        RXBranchNumberModelMyMatrix(RXDiff(Variable(&#39;a&#39;, width=2)))</span>
<span class="sd">        &gt;&gt;&gt; print(BvWrapPrinter().doprint(f.validity_constraint(beta)))</span>
<span class="sd">        BvAnd((((a == 0b00) &amp; ~(b == 0b000)) == 0b1) | ((~(a == 0b00) &amp; (b == 0b000)) == 0b1),</span>
<span class="sd">              ((0b00 :: ~(a == 0b00)) + (0b00 :: (b[0])) + (0b00 :: (b[1])) + (0b00 :: (b[2]))) &gt;= 0b011</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; f.bv_weight(beta)</span>
<span class="sd">        0b0</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (1, 1, 0, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">Operation</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;Xor&quot;</span>
        <span class="k">assert</span> <span class="n">zero2zero_weight</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c1"># for XOR differentials with Pr. 1, an input property propagates to a unique output property</span>
        <span class="k">assert</span> <span class="n">zero2nonzero_weight</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">elif</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;RX&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid diff_type </span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">_op</span><span class="p">,</span> <span class="n">_diff_type</span> <span class="o">=</span> <span class="n">op</span><span class="p">,</span> <span class="n">diff_type</span>
    <span class="n">_branch_number</span><span class="p">,</span> <span class="n">_output_widths</span> <span class="o">=</span> <span class="n">branch_number</span><span class="p">,</span> <span class="n">output_widths</span>
    <span class="n">_zero2zero_weight</span> <span class="o">=</span> <span class="n">zero2zero_weight</span>
    <span class="n">_nonzero2nonzero_weight</span> <span class="o">=</span> <span class="n">nonzero2nonzero_weight</span>
    <span class="n">_zero2nonzero_weight</span><span class="p">,</span> <span class="n">_nonzero2zero_weight</span> <span class="o">=</span> <span class="n">zero2nonzero_weight</span><span class="p">,</span> <span class="n">nonzero2zero_weight</span>
    <span class="n">_precision</span> <span class="o">=</span> <span class="n">precision</span>

    <span class="k">class</span> <span class="nc">MyBranchNumberModel</span><span class="p">(</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">BranchNumberModel</span><span class="p">,</span> <span class="n">OpModel</span><span class="p">):</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">diff_type</span><span class="o">=</span> <span class="n">_op</span><span class="p">,</span> <span class="n">_diff_type</span>
        <span class="n">branch_number</span><span class="p">,</span> <span class="n">output_widths</span> <span class="o">=</span> <span class="n">_branch_number</span><span class="p">,</span> <span class="n">_output_widths</span>
        <span class="n">zero2zero_weight</span> <span class="o">=</span> <span class="n">_zero2zero_weight</span>
        <span class="n">nonzero2nonzero_weight</span> <span class="o">=</span> <span class="n">_nonzero2nonzero_weight</span>
        <span class="n">zero2nonzero_weight</span> <span class="o">=</span> <span class="n">_zero2nonzero_weight</span>
        <span class="n">nonzero2zero_weight</span> <span class="o">=</span> <span class="n">_nonzero2zero_weight</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="n">_precision</span>

    <span class="n">MyBranchNumberModel</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">BranchNumberModel</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}{</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">MyBranchNumberModel</span></div>


<div class="viewcode-block" id="get_wdt_model"><a class="viewcode-back" href="../../../cascada.differential.opmodel.html#cascada.differential.opmodel.get_wdt_model">[docs]</a><span class="nd">@functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_wdt_model</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">diff_type</span><span class="p">,</span> <span class="n">weight_distribution_table</span><span class="p">,</span> <span class="n">loop_rows_then_columns</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the WDT-based model of the given bit-vector operation ``op``.</span>

<span class="sd">    Given the `Operation` ``op``, return the `WDTModel`</span>
<span class="sd">    of ``op`` for the `Difference` type ``diff_type`` with given class</span>
<span class="sd">    attributes ``weight_distribution_table``</span>
<span class="sd">    (i.e., the Difference Distribution Table (DDT) given as a `tuple` of `tuple`</span>
<span class="sd">    of differential weights),</span>
<span class="sd">    ``loop_rows_then_columns`` and  ``precision`` (see `WDTModel`).</span>

<span class="sd">    The returned model is a subclass of `WDTModel` and `OpModel`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        To link the returned model ``MyModel`` to ``op``</span>
<span class="sd">        such that ``MyModel`` is used in ``propagate``,</span>
<span class="sd">        set the ``xor_model`` or ``rx_model`` attribute of ``op``</span>
<span class="sd">        to ``MyModel`` (e.g., ``op.xor_model = MyModel``).</span>
<span class="sd">        See also  `differential.difference.XorDiff.propagate`</span>
<span class="sd">        or `differential.difference.RXDiff.propagate`.</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; # example of a XOR WDTModel for a 3-bit permutation</span>
<span class="sd">        &gt;&gt;&gt; from decimal import Decimal</span>
<span class="sd">        &gt;&gt;&gt; from math import inf</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.core import Constant, Variable</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.secondaryop import LutOperation</span>
<span class="sd">        &gt;&gt;&gt; from cascada.bitvector.printing import BvWrapPrinter</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import XorDiff</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.opmodel import log2_decimal, get_wdt_model</span>
<span class="sd">        &gt;&gt;&gt; # 3-bit permutation with 4 different weights</span>
<span class="sd">        &gt;&gt;&gt; class Sbox3b(LutOperation): lut = [Constant(i, 3) for i in (0, 1, 2, 3, 4, 6, 7, 5)]</span>
<span class="sd">        &gt;&gt;&gt; ddt = [(8, 0, 0, 0, 0, 0, 0, 0), (0, 4, 4, 0, 0, 0, 0, 0), (0, 0, 4, 4, 0, 0, 0, 0), (0, 4, 0, 4, 0, 0, 0, 0),</span>
<span class="sd">        ...        (0, 0, 0, 0, 2, 2, 2, 2), (0, 0, 0, 0, 2, 2, 2, 2), (0, 0, 0, 0, 2, 2, 2, 2), (0, 0, 0, 0, 2, 2, 2, 2)]</span>
<span class="sd">        &gt;&gt;&gt; num_inputs = Decimal(2**3)</span>
<span class="sd">        &gt;&gt;&gt; wdt = tuple([tuple(inf if x == 0 else -log2_decimal(x/num_inputs) for x in row) for row in ddt])</span>
<span class="sd">        &gt;&gt;&gt; XorWDTModelSbox3b = get_wdt_model(Sbox3b, XorDiff, wdt)</span>
<span class="sd">        &gt;&gt;&gt; alpha, beta = XorDiff(Variable(&quot;a&quot;, 3)), XorDiff(Variable(&quot;b&quot;, 3))</span>
<span class="sd">        &gt;&gt;&gt; f = XorWDTModelSbox3b(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        XorWDTModelSbox3b(XorDiff(Variable(&#39;a&#39;, width=3)))</span>
<span class="sd">        &gt;&gt;&gt; BvWrapPrinter.new_line_right_parenthesis = False</span>
<span class="sd">        &gt;&gt;&gt; print(BvWrapPrinter().doprint(f.validity_constraint(beta)))</span>
<span class="sd">        Ite(a == 0b011,</span>
<span class="sd">            (b == 0b001) | (b == 0b011),</span>
<span class="sd">            Ite(a == 0b010,</span>
<span class="sd">                (b == 0b010) | (b == 0b011),</span>
<span class="sd">                Ite(a == 0b001,</span>
<span class="sd">                    (b == 0b001) | (b == 0b010),</span>
<span class="sd">                    Ite(a == 0b000, b == 0b000, (b == 0b100) | (b == 0b101) | (b == 0b110) | (b == 0b111)))))</span>
<span class="sd">        &gt;&gt;&gt; f.pr_one_constraint(beta)</span>
<span class="sd">        Ite(a == 0b000, b == 0b000, 0b0)</span>
<span class="sd">        &gt;&gt;&gt; f.bv_weight(beta)</span>
<span class="sd">        Ite((a == 0b001) | (a == 0b010) | (a == 0b011), 0b01, Ite(a == 0b000, 0b00, 0b10))</span>
<span class="sd">        &gt;&gt;&gt; BvWrapPrinter.new_line_right_parenthesis = True</span>
<span class="sd">        &gt;&gt;&gt; x = Constant(0, 3)</span>
<span class="sd">        &gt;&gt;&gt; f.eval_derivative(x)  # f(x + alpha) - f(x)</span>
<span class="sd">        XorDiff(Sbox3b(a))</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (2, 2, 0, 0)</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; # example of a RX WDTModel for a (3,2)-bit function where 0 -&gt; 0 and !=0 -&gt; !=0</span>
<span class="sd">        &gt;&gt;&gt; from cascada.differential.difference import RXDiff</span>
<span class="sd">        &gt;&gt;&gt; class Lut3to2b(LutOperation): lut = [Constant(0, 3) for i in reversed(range(2 ** 2))]</span>
<span class="sd">        &gt;&gt;&gt; w = decimal.Decimal(&quot;0.25&quot;)</span>
<span class="sd">        &gt;&gt;&gt; wdt = tuple([(0, inf, inf, inf)] + [(inf, w, w, w)]*7)</span>
<span class="sd">        &gt;&gt;&gt; RXWDTModelLut3to2b = get_wdt_model(Lut3to2b, RXDiff, wdt, precision=2)</span>
<span class="sd">        &gt;&gt;&gt; alpha, beta = RXDiff(Variable(&quot;a&quot;, 3)), RXDiff(Variable(&quot;b&quot;, 2))</span>
<span class="sd">        &gt;&gt;&gt; f = RXWDTModelLut3to2b(alpha)</span>
<span class="sd">        &gt;&gt;&gt; print(f.vrepr())</span>
<span class="sd">        RXWDTModelLut3to2b(RXDiff(Variable(&#39;a&#39;, width=3)))</span>
<span class="sd">        &gt;&gt;&gt; f.validity_constraint(beta)</span>
<span class="sd">        Ite(a == 0b000, b == 0b00, ~(b == 0b00))</span>
<span class="sd">        &gt;&gt;&gt; f.pr_one_constraint(beta)</span>
<span class="sd">        Ite(a == 0b000, b == 0b00, 0b0)</span>
<span class="sd">        &gt;&gt;&gt; f.bv_weight(beta)</span>
<span class="sd">        Ite(a == 0b000, 0b0, 0b1)</span>
<span class="sd">        &gt;&gt;&gt; f.max_weight(), f.weight_width(), f.error(), f.num_frac_bits()</span>
<span class="sd">        (1, 1, 0, 2)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">Operation</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;Xor&quot;</span>
    <span class="k">elif</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="n">difference</span><span class="o">.</span><span class="n">RXDiff</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;RX&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid diff_type </span><span class="si">{</span><span class="n">diff_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">weight_distribution_table</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">w</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">row</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;weight_distribution_table contains a row with only math.inf values&quot;</span>
            <span class="k">if</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">weight_distribution_table</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;weight_distribution_table[0][0] != 0&quot;</span>
        <span class="k">if</span> <span class="n">diff_type</span> <span class="o">==</span> <span class="n">difference</span><span class="o">.</span><span class="n">XorDiff</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">_op</span><span class="p">,</span> <span class="n">_diff_type</span> <span class="o">=</span> <span class="n">op</span><span class="p">,</span> <span class="n">diff_type</span>
    <span class="n">_weight_distribution_table</span> <span class="o">=</span> <span class="n">weight_distribution_table</span><span class="p">[:]</span>
    <span class="n">_loop_rows_then_columns</span> <span class="o">=</span> <span class="n">loop_rows_then_columns</span>
    <span class="n">_precision</span> <span class="o">=</span> <span class="n">precision</span>

    <span class="k">class</span> <span class="nc">MyWDTModel</span><span class="p">(</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">WDTModel</span><span class="p">,</span> <span class="n">OpModel</span><span class="p">):</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">diff_type</span> <span class="o">=</span> <span class="n">_op</span><span class="p">,</span> <span class="n">_diff_type</span>
        <span class="n">weight_distribution_table</span> <span class="o">=</span> <span class="n">_weight_distribution_table</span>
        <span class="n">loop_rows_then_columns</span> <span class="o">=</span> <span class="n">_loop_rows_then_columns</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="n">_precision</span>

    <span class="n">MyWDTModel</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">abstractproperty</span><span class="o">.</span><span class="n">opmodel</span><span class="o">.</span><span class="n">WDTModel</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}{</span><span class="n">op</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">MyWDTModel</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Adrián Ranea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>