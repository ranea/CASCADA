<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cascada.bitvector.operation module &mdash; CASCADA 1.0.rc0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="cascada.bitvector.printing module" href="cascada.bitvector.printing.html" />
    <link rel="prev" title="cascada.bitvector.secondaryop module" href="cascada.bitvector.secondaryop.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> CASCADA
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">CASCADA</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="primitives_implemented.html">Primitives implemented</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="cascada.html">API reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="cascada.bitvector.html">cascada.bitvector module</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="cascada.bitvector.context.html">cascada.bitvector.context module</a></li>
<li class="toctree-l3"><a class="reference internal" href="cascada.bitvector.core.html">cascada.bitvector.core module</a></li>
<li class="toctree-l3"><a class="reference internal" href="cascada.bitvector.secondaryop.html">cascada.bitvector.secondaryop module</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">cascada.bitvector.operation module</a></li>
<li class="toctree-l3"><a class="reference internal" href="cascada.bitvector.printing.html">cascada.bitvector.printing module</a></li>
<li class="toctree-l3"><a class="reference internal" href="cascada.bitvector.ssa.html">cascada.bitvector.ssa module</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cascada.primitives.html">cascada.primitives module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cascada.abstractproperty.html">cascada.abstractproperty module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cascada.differential.html">cascada.differential module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cascada.linear.html">cascada.linear module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cascada.algebraic.html">cascada.algebraic module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cascada.smt.html">cascada.smt module</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">CASCADA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="cascada.html">API reference</a> &raquo;</li>
          <li><a href="cascada.bitvector.html">cascada.bitvector module</a> &raquo;</li>
      <li>cascada.bitvector.operation module</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/cascada.bitvector.operation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-cascada.bitvector.operation">
<span id="cascada-bitvector-operation-module"></span><h1>cascada.bitvector.operation module<a class="headerlink" href="#module-cascada.bitvector.operation" title="Permalink to this headline"></a></h1>
<p>Provide the common bit-vector operators.</p>
<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">Operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Operation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="cascada.bitvector.core.html#cascada.bitvector.core.Term" title="cascada.bitvector.core.Term"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.core.Term</span></code></a></p>
<p>Represent bit-vector operations.</p>
<p>A bit-vector operation is a mathematical function that takes some bit-vector
operands (i.e. <a class="reference internal" href="cascada.bitvector.core.html#cascada.bitvector.core.Term" title="cascada.bitvector.core.Term"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Term</span></code></a>) and some scalar operands (i.e. <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.10)"><code class="xref any docutils literal notranslate"><span class="pre">int</span></code></a>),
and returns a single bit-vector term. Often, <em>operator</em> is used to
denote the Python class representing the mathematical function (without operands)
and <em>operation</em> is used to denote the application of an operator to some operands.</p>
<p>A particular operator (a subclass of <a class="reference internal" href="#cascada.bitvector.operation.Operation" title="cascada.bitvector.operation.Operation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Operation</span></code></a>) can be evaluated
by instantiating an object with the operands as the object arguments.
The instantiation internally calls the method <a class="reference internal" href="#cascada.bitvector.operation.Operation.eval" title="cascada.bitvector.operation.Operation.eval"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">eval</span></code></a>, containing the logic
of the operator. This behaviour is similar as those of the SymPy classes
<a class="reference external" href="https://docs.sympy.org/latest/modules/core.html?highlight=add#sympy.core.add.Add">Add</a>
or <a class="reference external" href="https://docs.sympy.org/latest/modules/core.html?highlight=mul#sympy.core.mul.Mul">Mul</a>.</p>
<p>Unless the <a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.Simplification" title="cascada.bitvector.context.Simplification"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Simplification</span></code></a> context is disabled (enabled by default),
many of the operations automatically simplify complex expressions
by applying basic rules from <a class="reference external" href="https://en.wikipedia.org/wiki/Bitwise_operation#Boolean_algebra">Boolean algebra</a>.
Moreoever, operations are also affected by other context managers
such as <a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.Cache" title="cascada.bitvector.context.Cache"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Cache</span></code></a>, <a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.PrimaryOperationEvaluation" title="cascada.bitvector.context.PrimaryOperationEvaluation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperationEvaluation</span></code></a>, <a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.SecondaryOperationEvaluation" title="cascada.bitvector.context.SecondaryOperationEvaluation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SecondaryOperationEvaluation</span></code></a>,
<a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.Validation" title="cascada.bitvector.context.Validation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Validation</span></code></a> or <a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.Memoization" title="cascada.bitvector.context.Memoization"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Memoization</span></code></a>.</p>
<p>This class is not meant to be instantiated but to provide a base
class for the two types of operations: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a>
and <a class="reference internal" href="#cascada.bitvector.operation.SecondaryOperation" title="cascada.bitvector.operation.SecondaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SecondaryOperation</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>New bit-vector operations can be defined by subclassing <a class="reference internal" href="#cascada.bitvector.operation.SecondaryOperation" title="cascada.bitvector.operation.SecondaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SecondaryOperation</span></code></a>
(see <a class="reference internal" href="cascada.bitvector.secondaryop.html#cascada.bitvector.secondaryop.BvMaj" title="cascada.bitvector.secondaryop.BvMaj"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvMaj</span></code></a> as example). It is also possible to define new bit-vector
operations by subclassing <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a>, but this is not recommended.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.arity">
<span class="sig-name descname"><span class="pre">arity</span></span><a class="headerlink" href="#cascada.bitvector.operation.Operation.arity" title="Permalink to this definition"></a></dt>
<dd><p>a pair of number specifying the number of bit-vector operands
(at least one) and scalar operands, respectively.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.is_symmetric">
<span class="sig-name descname"><span class="pre">is_symmetric</span></span><a class="headerlink" href="#cascada.bitvector.operation.Operation.is_symmetric" title="Permalink to this definition"></a></dt>
<dd><p>True if the operator is symmetric with respect to
its operands (a permutation of the inputs does not change the output).
Operators with scalar operands cannot be symmetric.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.is_simple">
<span class="sig-name descname"><span class="pre">is_simple</span></span><a class="headerlink" href="#cascada.bitvector.operation.Operation.is_simple" title="Permalink to this definition"></a></dt>
<dd><p>True if the operator is <em>simple</em>, that is, all its
operands are bit-vector of the same width. Simple operators allow
<em>Automatic Constant Conversion</em>, that is, instead of passing
all arguments as bit-vector types, it is possible to pass
arguments as plain integers.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span>
<span class="go">&#39;Constant(0b00000010, width=8)&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.operand_types">
<span class="sig-name descname"><span class="pre">operand_types</span></span><a class="headerlink" href="#cascada.bitvector.operation.Operation.operand_types" title="Permalink to this definition"></a></dt>
<dd><p>a list specifying the types of the operands (optional
if all operands are bit-vectors)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.alt_name">
<span class="sig-name descname"><span class="pre">alt_name</span></span><a class="headerlink" href="#cascada.bitvector.operation.Operation.alt_name" title="Permalink to this definition"></a></dt>
<dd><p>an alternative name used when printing (optional)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.unary_symbol">
<span class="sig-name descname"><span class="pre">unary_symbol</span></span><a class="headerlink" href="#cascada.bitvector.operation.Operation.unary_symbol" title="Permalink to this definition"></a></dt>
<dd><p>a symbol used when printing (optional)</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.infix_symbol">
<span class="sig-name descname"><span class="pre">infix_symbol</span></span><a class="headerlink" href="#cascada.bitvector.operation.Operation.infix_symbol" title="Permalink to this definition"></a></dt>
<dd><p>a symbol used when printing (optional)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Operation.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Operation.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.output_width">
<span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Operation.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Operation.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Operation.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Operation.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.formula_size">
<span class="sig-name descname"><span class="pre">formula_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Operation.formula_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Operation.formula_size" title="Permalink to this definition"></a></dt>
<dd><p>The formula size of the operation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Operation.memoization_table">
<span class="sig-name descname"><span class="pre">memoization_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">id_prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decompose_sec_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Operation.memoization_table"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Operation.memoization_table" title="Permalink to this definition"></a></dt>
<dd><p>Return a decomposition of the current operation into simple assignments.</p>
<p>Given an <a class="reference internal" href="#cascada.bitvector.operation.Operation" title="cascada.bitvector.operation.Operation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Operation</span></code></a> object <span class="math notranslate nohighlight">\(F(a_1, a_2, \dots)\)</span>, this method
decomposes it into a list of <em>simple</em> assignments
<span class="math notranslate nohighlight">\(x_{i+1} \leftarrow f_i(x_i)\)</span> such that the last output variable
<span class="math notranslate nohighlight">\(x_{n}\)</span> represents the output of <span class="math notranslate nohighlight">\(F(a_1, a_2, \dots)\)</span>.
The i-th assignment is given by:</p>
<blockquote>
<div><ul class="simple">
<li><p>the output <a class="reference internal" href="cascada.bitvector.core.html#cascada.bitvector.core.Variable" title="cascada.bitvector.core.Variable"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a> <span class="math notranslate nohighlight">\(x_{i+1}\)</span> that represents
the output of <span class="math notranslate nohighlight">\(f_i(x_i)\)</span>,</p></li>
<li><p>the <a class="reference internal" href="#cascada.bitvector.operation.Operation" title="cascada.bitvector.operation.Operation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Operation</span></code></a> object <span class="math notranslate nohighlight">\(f_i(x_i)\)</span> where the input
<span class="math notranslate nohighlight">\(x_i\)</span> is a previous output <a class="reference internal" href="cascada.bitvector.core.html#cascada.bitvector.core.Variable" title="cascada.bitvector.core.Variable"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a>,
an input <a class="reference internal" href="cascada.bitvector.core.html#cascada.bitvector.core.Variable" title="cascada.bitvector.core.Variable"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Variable</span></code></a> (of <span class="math notranslate nohighlight">\(F(a_1, a_2, \dots)\)</span>),
a <a class="reference internal" href="cascada.bitvector.core.html#cascada.bitvector.core.Constant" title="cascada.bitvector.core.Constant"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a>, a scalar, o a list of them
but not an <a class="reference internal" href="#cascada.bitvector.operation.Operation" title="cascada.bitvector.operation.Operation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Operation</span></code></a> object.</p></li>
</ul>
</div></blockquote>
<p>The list of assignments is given as a <a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.MemoizationTable" title="cascada.bitvector.context.MemoizationTable"><code class="xref any py py-class docutils literal notranslate"><span class="pre">MemoizationTable</span></code></a>,
and it is obtained by re-evaluating the current operation
under the <a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.Memoization" title="cascada.bitvector.context.Memoization"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Memoization</span></code></a> context.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">id_prefix</span></code> is the string prefix used to name
intermediate variables and the argument <code class="docutils literal notranslate"><span class="pre">decompose_sec_ops</span></code>
determines whether to use the context <a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.SecondaryOperationEvaluation" title="cascada.bitvector.context.SecondaryOperationEvaluation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SecondaryOperationEvaluation</span></code></a>.
In other words, if <code class="docutils literal notranslate"><span class="pre">decompose_sec_ops</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>,
<a class="reference internal" href="#cascada.bitvector.operation.SecondaryOperation" title="cascada.bitvector.operation.SecondaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SecondaryOperation</span></code></a> objects are not allowed in the list of
assignments and they are replaced by their
decomposition into  <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> objects.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.secondaryop</span> <span class="kn">import</span> <span class="n">BvMaj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">BvMaj</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;a_1&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">3</span> <span class="o">|</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;a_2&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">memoization_table</span><span class="p">()</span>  
<span class="go">MemoizationTable([(x0, a_2 | 0x03), (x1, 0x02 &amp; a_1), (x2, 0x02 &amp; x0),</span>
<span class="go">(x3, x1 | x2), (x4, a_1 &amp; x0), (x5, x3 | x4), (x6, x5 + 0x01), (x7, Id(x6))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">memoization_table</span><span class="p">(</span><span class="n">decompose_sec_ops</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">MemoizationTable([(x0, a_2 | 0x03), (x1, BvMaj(0x02, a_1, x0)), (x2, x1 + 0x01), (x3, Id(x2))])</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.PrimaryOperation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">PrimaryOperation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#PrimaryOperation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.PrimaryOperation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.Operation" title="cascada.bitvector.operation.Operation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.Operation</span></code></a></p>
<p>Represent the primary bit-vector operations.</p>
<p>The primary bit-vector operations are those <em>basic</em>
operations that are included in the  bit-vector theory of the
<a class="reference external" href="http://smtlib.cs.uiowa.edu/theories-FixedSizeBitVectors.shtml">SMT_LIBv2</a>
format.</p>
<p>The primary operations are <a class="reference internal" href="#cascada.bitvector.operation.BvAnd" title="cascada.bitvector.operation.BvAnd"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvAnd</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvOr" title="cascada.bitvector.operation.BvOr"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvOr</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvXor" title="cascada.bitvector.operation.BvXor"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvXor</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvComp" title="cascada.bitvector.operation.BvComp"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvComp</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvUlt" title="cascada.bitvector.operation.BvUlt"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvUlt</span></code></a>,
<a class="reference internal" href="#cascada.bitvector.operation.BvUle" title="cascada.bitvector.operation.BvUle"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvUle</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvUgt" title="cascada.bitvector.operation.BvUgt"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvUgt</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvUge" title="cascada.bitvector.operation.BvUge"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvUge</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvShl" title="cascada.bitvector.operation.BvShl"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvShl</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvLshr" title="cascada.bitvector.operation.BvLshr"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvLshr</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.RotateLeft" title="cascada.bitvector.operation.RotateLeft"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RotateLeft</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.RotateRight" title="cascada.bitvector.operation.RotateRight"><code class="xref any py py-class docutils literal notranslate"><span class="pre">RotateRight</span></code></a>,
<a class="reference internal" href="#cascada.bitvector.operation.Concat" title="cascada.bitvector.operation.Concat"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Concat</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvAdd" title="cascada.bitvector.operation.BvAdd"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvAdd</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvSub" title="cascada.bitvector.operation.BvSub"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvSub</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvMul" title="cascada.bitvector.operation.BvMul"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvMul</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvUdiv" title="cascada.bitvector.operation.BvUdiv"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvUdiv</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvUrem" title="cascada.bitvector.operation.BvUrem"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvUrem</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvNeg" title="cascada.bitvector.operation.BvNeg"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvNeg</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.BvNot" title="cascada.bitvector.operation.BvNot"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvNot</span></code></a>,
<a class="reference internal" href="#cascada.bitvector.operation.Extract" title="cascada.bitvector.operation.Extract"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Extract</span></code></a>, <a class="reference internal" href="#cascada.bitvector.operation.Ite" title="cascada.bitvector.operation.Ite"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Ite</span></code></a> and <a class="reference internal" href="#cascada.bitvector.operation.BvIdentity" title="cascada.bitvector.operation.BvIdentity"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvIdentity</span></code></a>.</p>
<p>This class is not meant to be instantiated but to provide a base
class to define primary operators.</p>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.PrimaryOperation.class_key">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">class_key</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#PrimaryOperation.class_key"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.PrimaryOperation.class_key" title="Permalink to this definition"></a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.SecondaryOperation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">SecondaryOperation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#SecondaryOperation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.SecondaryOperation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.Operation" title="cascada.bitvector.operation.Operation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.Operation</span></code></a></p>
<p>Represent secondary bit-vector operations.</p>
<p>Secondary bit-vector operations are those bit-vector operations
that are not primary operations (see <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a>).
Secondary operations must be defined in terms of primary operations.</p>
<p>By default, secondary operations are fully evaluated (<a class="reference internal" href="#cascada.bitvector.operation.Operation.eval" title="cascada.bitvector.operation.Operation.eval"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Operation.eval</span></code></a>
is used) if all the operands are scalar or <a class="reference internal" href="cascada.bitvector.core.html#cascada.bitvector.core.Constant" title="cascada.bitvector.core.Constant"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a> objects (see also
<a class="reference internal" href="cascada.bitvector.context.html#cascada.bitvector.context.SecondaryOperationEvaluation" title="cascada.bitvector.context.SecondaryOperationEvaluation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">context.SecondaryOperationEvaluation</span></code></a>). On the other hand, <a class="reference internal" href="#cascada.bitvector.operation.SecondaryOperation.pre_eval" title="cascada.bitvector.operation.SecondaryOperation.pre_eval"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">pre_eval</span></code></a>
is always called in the evaluation (even with symbolic inputs).</p>
<p>This class is not meant to be instantiated but to provide a base
class to define secondary operators.</p>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.SecondaryOperation.pre_eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pre_eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#SecondaryOperation.pre_eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.SecondaryOperation.pre_eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator before <a class="reference internal" href="#cascada.bitvector.operation.Operation.eval" title="cascada.bitvector.operation.Operation.eval"><code class="xref any py py-meth docutils literal notranslate"><span class="pre">Operation.eval</span></code></a>.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.SecondaryOperation.class_key">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">class_key</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#SecondaryOperation.class_key"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.SecondaryOperation.class_key" title="Permalink to this definition"></a></dt>
<dd><p>Nice order of classes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.SecondaryOperation.formula_size">
<span class="sig-name descname"><span class="pre">formula_size</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#SecondaryOperation.formula_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.SecondaryOperation.formula_size" title="Permalink to this definition"></a></dt>
<dd><p>The formula size of the operation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.PartialOperation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">PartialOperation</span></span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#PartialOperation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.PartialOperation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.10)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Represent bit-vector operations with fixed operands.</p>
<p>Given a base operator <span class="math notranslate nohighlight">\((x, y) \mapsto  f(x, y)\)</span>,
a partial operator is a function obtained by fixing some
of the inputs to constants, e.g., <span class="math notranslate nohighlight">\(x \mapsto f(x, y=0)\)</span>.</p>
<p>This class is not meant to be instantiated but to provide a base
class for bit-vector operations with fixed operands generated
through <a class="reference internal" href="#cascada.bitvector.operation.make_partial_operation" title="cascada.bitvector.operation.make_partial_operation"><code class="xref any py py-func docutils literal notranslate"><span class="pre">make_partial_operation</span></code></a>.
<a class="reference internal" href="#cascada.bitvector.operation.PartialOperation" title="cascada.bitvector.operation.PartialOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PartialOperation</span></code></a> subclasses generated by <a class="reference internal" href="#cascada.bitvector.operation.make_partial_operation" title="cascada.bitvector.operation.make_partial_operation"><code class="xref any py py-func docutils literal notranslate"><span class="pre">make_partial_operation</span></code></a>
are also subclasses of <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> or <a class="reference internal" href="#cascada.bitvector.operation.SecondaryOperation" title="cascada.bitvector.operation.SecondaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SecondaryOperation</span></code></a>
depending on the type of the base operator.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="cascada.bitvector.operation.PartialOperation.base_op">
<span class="sig-name descname"><span class="pre">base_op</span></span><a class="headerlink" href="#cascada.bitvector.operation.PartialOperation.base_op" title="Permalink to this definition"></a></dt>
<dd><p>a subclass of <a class="reference internal" href="#cascada.bitvector.operation.Operation" title="cascada.bitvector.operation.Operation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Operation</span></code></a> denoting the base operator.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cascada.bitvector.operation.PartialOperation.fixed_args">
<span class="sig-name descname"><span class="pre">fixed_args</span></span><a class="headerlink" href="#cascada.bitvector.operation.PartialOperation.fixed_args" title="Permalink to this definition"></a></dt>
<dd><p>a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.10)"><code class="xref any docutils literal notranslate"><span class="pre">tuple</span></code></a> with the same length as the number of operands
of the base function containing <code class="docutils literal notranslate"><span class="pre">None</span></code>, scalar or <a class="reference internal" href="cascada.bitvector.core.html#cascada.bitvector.core.Constant" title="cascada.bitvector.core.Constant"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a> elements.
If <code class="docutils literal notranslate"><span class="pre">fixed_args[i]</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the i-th operand is not fixed;
otherwise, the i-th operand is replaced with <code class="docutils literal notranslate"><span class="pre">fixed_args[i]</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cascada.bitvector.operation.make_partial_operation">
<span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">make_partial_operation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base_op</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#make_partial_operation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.make_partial_operation" title="Permalink to this definition"></a></dt>
<dd><p>Return a new <a class="reference internal" href="#cascada.bitvector.operation.PartialOperation" title="cascada.bitvector.operation.PartialOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PartialOperation</span></code></a> subclass with the given base operator and fixed arguments.</p>
<p>The argument <code class="docutils literal notranslate"><span class="pre">fixed_args</span></code> is a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.10)"><code class="xref any docutils literal notranslate"><span class="pre">tuple</span></code></a>, with the same length as
the number of operands of the base operator, containing <code class="docutils literal notranslate"><span class="pre">None</span></code>,
scalar or <a class="reference internal" href="cascada.bitvector.core.html#cascada.bitvector.core.Constant" title="cascada.bitvector.core.Constant"><code class="xref any py py-class docutils literal notranslate"><span class="pre">Constant</span></code></a> elements. If <code class="docutils literal notranslate"><span class="pre">fixed_args[i]</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>,
the i-th operand is not fixed; otherwise, the i-th operand is
replaced with <code class="docutils literal notranslate"><span class="pre">fixed_args[i]</span></code>.</p>
<p>The resulting class is also a subclass of <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> or
<a class="reference internal" href="#cascada.bitvector.operation.SecondaryOperation" title="cascada.bitvector.operation.SecondaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">SecondaryOperation</span></code></a>, depending on the type of the base operator.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvAdd</span><span class="p">,</span> <span class="n">Extract</span><span class="p">,</span> <span class="n">make_partial_operation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.secondaryop</span> <span class="kn">import</span> <span class="n">BvMaj</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvAddCte</span> <span class="o">=</span> <span class="n">make_partial_operation</span><span class="p">(</span><span class="n">BvAdd</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvAddCte</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;BvAdd_{·, 0x1}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">BvAddCte</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span>
<span class="go">a + 0x1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">vrepr</span><span class="p">()</span>
<span class="go">&quot;make_partial_operation(BvAdd, (None, Constant(0b0001, width=4)))(Variable(&#39;a&#39;, width=4))&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtractLSB</span> <span class="o">=</span> <span class="n">make_partial_operation</span><span class="p">(</span><span class="n">Extract</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtractLSB</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;Extract_{·, 0, 0}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExtractLSB</span><span class="p">(</span><span class="n">Extract</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1"># result is simplified</span>
<span class="go">a[0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvCteMaj</span> <span class="o">=</span> <span class="n">make_partial_operation</span><span class="p">(</span><span class="n">BvMaj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvCteMaj</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;BvMaj_{·, ·, 0x1}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvCteMaj</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="n">BvCteMaj</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span>
<span class="go">BvMaj_{·, ·, 0x1}(a, b)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">doit</span><span class="p">()</span>
<span class="go">(a &amp; b) | (a &amp; 0x1) | (b &amp; 0x1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span><span class="o">.</span><span class="n">memoization_table</span><span class="p">()</span>
<span class="go">MemoizationTable([(x0, a &amp; b), (x1, a &amp; 0x1), (x2, x0 | x1), (x3, b &amp; 0x1), (x4, x2 | x3), (x5, Id(x4))])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvCteMaj_v2</span> <span class="o">=</span> <span class="n">make_partial_operation</span><span class="p">(</span><span class="n">BvCteMaj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="kc">None</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvCteMaj_v2</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;BvMaj_{0x2, ·, 0x1}&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvCteMaj_v2</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">BvMaj_{0x2, ·, 0x1}(a)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvNot">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvNot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvNot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvNot" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Bitwise negation operation.</p>
<p>It overrides the operator ~. See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvNot</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvNot</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b1010101</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="go">0b0101010</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b1010101</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="go">0b0101010</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">~</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">~x</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvNot.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvNot.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvNot.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvNot.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvNot.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvNot.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvAnd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvAnd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvAnd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvAnd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Bitwise AND (logical conjunction) operation.</p>
<p>It overrides the operator &amp; and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvAnd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvAnd</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0x01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvAnd</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">0x01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span>
<span class="go">0x01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x &amp; y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvAnd.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvAnd.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvAnd.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvAnd.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvAnd.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvAnd.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvAnd.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvAnd.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvAnd.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvOr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvOr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvOr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvOr" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Bitwise OR (logical disjunction) operation.</p>
<p>It overrides the operator | and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvOr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvOr</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0x07</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvOr</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">0x07</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="mi">3</span>
<span class="go">0x07</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x | y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvOr.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvOr.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvOr.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvOr.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvOr.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvOr.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvOr.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvOr.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvOr.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvXor">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvXor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvXor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvXor" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Bitwise XOR (exclusive-or) operation.</p>
<p>It overrides the operator ^ and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvXor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvXor</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0x06</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvXor</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">0x06</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">^</span> <span class="mi">3</span>
<span class="go">0x06</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">^</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x ^ y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvXor.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvXor.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvXor.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvXor.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvXor.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvXor.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvXor.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvXor.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvXor.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvComp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvComp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvComp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvComp" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Equality operator.</p>
<p>Provides Automatic Constant Conversion. See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more
information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvComp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvComp</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0b0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvComp</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0b0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvComp</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0x01 == y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">bool</span><span class="p">(</span><span class="n">BvComp</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The operator == is used for exact structural equality testing and
it returns either True or False. On the other hand, BvComp
performs symbolic equality testing and it leaves the relation unevaluated
if it cannot prove the objects are equal (or unequal).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvComp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># symbolic equality</span>
<span class="go">x == y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvComp.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvComp.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvComp.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvComp.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvComp.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvComp.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvComp.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvComp.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvComp.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUlt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvUlt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUlt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUlt" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Unsigned less than operator.</p>
<p>It overrides &lt; and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvUlt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUlt</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUlt</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span>
<span class="go">0b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">0x01 &lt; y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUlt.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUlt.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUlt.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUlt.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUlt.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUlt.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUlt.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUlt.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUlt.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUle">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvUle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUle" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Unsigned less than or equal operator.</p>
<p>It overrides &lt;= and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvUle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUle</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUle</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span>
<span class="go">0b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">0x02 &lt;= y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUle.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUle.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUle.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUle.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUle.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUle.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUle.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUle.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUle.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUgt">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvUgt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUgt"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUgt" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Unsigned greater than operator.</p>
<p>It overrides &gt; and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvUgt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUgt</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0b0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUgt</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0b0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="go">0b0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">0x01 &gt; y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUgt.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUgt.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUgt.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUgt.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUgt.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUgt.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUgt.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUgt.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUgt.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUge">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvUge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUge" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Unsigned greater than or equal operator.</p>
<p>It overrides &gt;= and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvUgt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUge</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUge</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="go">0b1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">0x02 &gt;= y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUge.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUge.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUge.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUge.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUge.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUge.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUge.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUge.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUge.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvShl">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvShl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvShl"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvShl" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Shift left operation.</p>
<p>It overrides &lt;&lt; and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvShl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvShl</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b10001</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">0b00010</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvShl</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b10001</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0b00010</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b10001</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
<span class="go">0b00010</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x &lt;&lt; y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvShl.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvShl.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvShl.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvShl.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvShl.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvShl.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvShl.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvShl.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvShl.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvLshr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvLshr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvLshr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvLshr" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Logical right shift operation.</p>
<p>It overrides &gt;&gt; and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvLshr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvLshr</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b10001</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="go">0b01000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvLshr</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b10001</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">0b01000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b10001</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
<span class="go">0b01000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x &gt;&gt; y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvLshr.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvLshr.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvLshr.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvLshr.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvLshr.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvLshr.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvLshr.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvLshr.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvLshr.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.RotateLeft">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">RotateLeft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#RotateLeft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.RotateLeft" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Circular left rotation operation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">RotateLeft</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RotateLeft</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0x5a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RotateLeft</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">x &lt;&lt;&lt; 2</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.RotateLeft.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#RotateLeft.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.RotateLeft.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.RotateLeft.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#RotateLeft.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.RotateLeft.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.RotateLeft.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#RotateLeft.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.RotateLeft.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.RotateRight">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">RotateRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#RotateRight"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.RotateRight" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Circular right rotation operation.</p>
<p>It provides Automatic Constant Conversion. See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more
information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">RotateRight</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RotateRight</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">150</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">0xd2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RotateRight</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">x &gt;&gt;&gt; 3</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.RotateRight.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#RotateRight.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.RotateRight.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.RotateRight.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#RotateRight.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.RotateRight.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.RotateRight.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#RotateRight.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.RotateRight.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Ite">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">Ite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Ite"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Ite" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>If-then-else operator.</p>
<p><code class="docutils literal notranslate"><span class="pre">Ite(b,</span> <span class="pre">x,</span> <span class="pre">y)</span></code> returns <code class="docutils literal notranslate"><span class="pre">x</span></code> if <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">==</span> <span class="pre">0b1</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> otherwise.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">Ite</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ite</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mb">0b11</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mb">0b00</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">0b00</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Ite</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mh">0x0</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">0x1</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Ite.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Ite.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Ite.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Ite.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Ite.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Ite.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Ite.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Ite.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Ite.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Extract">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">Extract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Extract"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Extract" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Extraction of bits.</p>
<p><code class="docutils literal notranslate"><span class="pre">Extract(t,</span> <span class="pre">i,</span> <span class="pre">j)</span></code> extracts the bits from position <code class="docutils literal notranslate"><span class="pre">i</span></code> down
position <code class="docutils literal notranslate"><span class="pre">j</span></code> (end points included, position 0 corresponding
to the least significant bit).</p>
<p>It overrides the operation [], that is, <code class="docutils literal notranslate"><span class="pre">Extract(t,</span> <span class="pre">i,</span> <span class="pre">j)</span></code>
is equivalent to <code class="docutils literal notranslate"><span class="pre">t[i:j]</span></code>.</p>
<p>Note that the indices can be omitted when they point the most
significant bit or the least significant bit.
For example, if <code class="docutils literal notranslate"><span class="pre">t</span></code> is a bit-vector of length <code class="docutils literal notranslate"><span class="pre">n</span></code>,
then <code class="docutils literal notranslate"><span class="pre">t[n-1:j]</span> <span class="pre">=</span> <span class="pre">t[:j]</span></code> and <code class="docutils literal notranslate"><span class="pre">t[i:0]</span> <span class="pre">=</span> <span class="pre">t[i:]</span></code></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In python, given a list <code class="docutils literal notranslate"><span class="pre">l</span></code>, <code class="docutils literal notranslate"><span class="pre">l[i:j]</span></code> denotes the elements
from position <code class="docutils literal notranslate"><span class="pre">i</span></code> up to (but not included) position <code class="docutils literal notranslate"><span class="pre">j</span></code>.
Note that with bit-vectors, the order of the arguments is
swapped and both end points are included.</p>
<p>For example, for a given list <code class="docutils literal notranslate"><span class="pre">l</span></code> and bit-vector <code class="docutils literal notranslate"><span class="pre">t</span></code>,
<code class="docutils literal notranslate"><span class="pre">l[0:1]</span> <span class="pre">==</span> <span class="pre">l[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">t[1:0]</span> <span class="pre">==</span> <span class="pre">(t[0],</span> <span class="pre">t[1])</span></code>.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">Extract</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Extract</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b11100</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,)</span>
<span class="go">0b111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mb">0b11100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)[</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">0b111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)[</span><span class="mi">4</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="go">x[4:2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)[</span><span class="mi">7</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
<span class="go">x</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Extract.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Extract.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Extract.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Extract.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Extract.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Extract.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Extract.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Extract.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Extract.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Concat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">Concat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Concat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Concat" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Concatenation operation.</p>
<p>Given the bit-vectors <span class="math notranslate nohighlight">\((x_{n-1}, \dots, x_0)\)</span> and
<span class="math notranslate nohighlight">\((y_{m-1}, \dots, y_0)\)</span>, <code class="docutils literal notranslate"><span class="pre">Concat(x,</span> <span class="pre">y)</span></code> returns the bit-vector
<span class="math notranslate nohighlight">\((x_{n-1}, \dots, x_0, y_{m-1}, \dots, y_0)\)</span>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">Concat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Concat</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x12</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mh">0x345</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="go">0x12345</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Concat</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">x :: y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Concat.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Concat.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Concat.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.Concat.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#Concat.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.Concat.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvNeg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvNeg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvNeg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvNeg" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Unary minus operation.</p>
<p>It overrides the unary operator -. See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvNeg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvNeg</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0xff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">-</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">0xff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvNeg</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">-x</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvNeg.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvNeg.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvNeg.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvNeg.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvNeg.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvNeg.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvAdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvAdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvAdd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvAdd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Modular addition operation.</p>
<p>It overrides the operator + and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvAdd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvAdd</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0x03</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvAdd</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0x03</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
<span class="go">0x03</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x + y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvAdd.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvAdd.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvAdd.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvAdd.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvAdd.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvAdd.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvAdd.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvAdd.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvAdd.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvSub">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvSub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvSub"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvSub" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Modular subtraction operation.</p>
<p>It overrides the operator - and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvSub</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvSub</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0xff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvSub</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0xff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
<span class="go">0xff</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x - y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvSub.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvSub.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvSub.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvSub.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvSub.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvSub.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvSub.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvSub.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvSub.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvMul">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvMul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvMul"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvMul" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Modular multiplication operation.</p>
<p>It overrides the operator * and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvMul</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvMul</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0x0c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvMul</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">0x0c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
<span class="go">0x0c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">*</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x * y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvMul.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvMul.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvMul.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvMul.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvMul.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvMul.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvMul.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvMul.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvMul.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUdiv">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvUdiv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUdiv"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUdiv" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Unsigned and truncated division operation.</p>
<p>It overrides the operator / and provides Automatic Constant Conversion.
See <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref any py py-class docutils literal notranslate"><span class="pre">PrimaryOperation</span></code></a> for more information.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvUdiv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUdiv</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x0c</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0x04</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUdiv</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x0c</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">0x04</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x0c</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
<span class="go">0x04</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x / y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUdiv.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUdiv.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUdiv.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUdiv.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUdiv.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUdiv.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUdiv.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUdiv.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUdiv.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUrem">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvUrem</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUrem"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUrem" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>Unsigned remainder (modulus) operation.</p>
<p>Usage:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvUrem</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUrem</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x0d</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">0x01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvUrem</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x0d</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">0x01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x0d</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
<span class="go">0x01</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="o">%</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="go">x % y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUrem.condition">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUrem.condition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUrem.condition" title="Permalink to this definition"></a></dt>
<dd><p>Check if the operands verify the restrictions of the operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUrem.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUrem.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUrem.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvUrem.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvUrem.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvUrem.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvIdentity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">BvIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvIdentity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#cascada.bitvector.operation.PrimaryOperation" title="cascada.bitvector.operation.PrimaryOperation"><code class="xref py py-class docutils literal notranslate"><span class="pre">cascada.bitvector.operation.PrimaryOperation</span></code></a></p>
<p>The identity operation.</p>
<p>Return the same value when the input is constant and
a <a class="reference internal" href="#cascada.bitvector.operation.BvIdentity" title="cascada.bitvector.operation.BvIdentity"><code class="xref any py py-class docutils literal notranslate"><span class="pre">BvIdentity</span></code></a> object when the input is symbolic:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">BvIdentity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvIdentity</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">0x1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">BvIdentity</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="go">Id(x)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvIdentity.output_width">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvIdentity.output_width"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvIdentity.output_width" title="Permalink to this definition"></a></dt>
<dd><p>Return the bit-width of the resulting bit-vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cascada.bitvector.operation.BvIdentity.eval">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#BvIdentity.eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.BvIdentity.eval" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the operator with given operands.</p>
<p>This is an internal method that assumes the list <code class="docutils literal notranslate"><span class="pre">args</span></code> has been parsed.
To evaluate a bit-vector operation, instantiate a new object with
the operands as the object arguments (i.e., use the Python operator <code class="docutils literal notranslate"><span class="pre">()</span></code>).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cascada.bitvector.operation.zero_extend">
<span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">zero_extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#zero_extend"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.zero_extend" title="Permalink to this definition"></a></dt>
<dd><p>Extend with zeroes preserving the unsigned value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">zero_extend</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_extend</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x12</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">0x012</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zero_extend</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">0x0 :: x</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cascada.bitvector.operation.repeat">
<span class="sig-prename descclassname"><span class="pre">cascada.bitvector.operation.</span></span><span class="sig-name descname"><span class="pre">repeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cascada/bitvector/operation.html#repeat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cascada.bitvector.operation.repeat" title="Permalink to this definition"></a></dt>
<dd><p>Concatenate a bit-vector with itself a given number of times.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.core</span> <span class="kn">import</span> <span class="n">Constant</span><span class="p">,</span> <span class="n">Variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cascada.bitvector.operation</span> <span class="kn">import</span> <span class="n">repeat</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repeat</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="mh">0x1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">0x1111</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">repeat</span><span class="p">(</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">x :: x :: x :: x</span>
</pre></div>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="cascada.bitvector.secondaryop.html" class="btn btn-neutral float-left" title="cascada.bitvector.secondaryop module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="cascada.bitvector.printing.html" class="btn btn-neutral float-right" title="cascada.bitvector.printing module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Adrián Ranea.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>